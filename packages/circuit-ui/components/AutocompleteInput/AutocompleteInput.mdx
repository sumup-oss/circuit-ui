import { Meta, Status, Props, Story } from "../../../../.storybook/components";
import * as Stories from "./AutocompleteInput.stories";

<Meta of={Stories} />

# AutocompleteInput

<Status variant="experimental" />

An input field that allows users to filter and select an option from a provided set of suggestions.

<Story of={Stories.Base} />
<Props />

## When to use

Use the AutocompleteInput component when you want to help users find and select from a large set of options. Common use cases:

- Location picker: Address or city field
- Product catalog: choosing from a long list of products

For short lists, consider using the [Select](Forms/Select/Docs) component instead.

While the AutocompleteInput component is accessible, it can be complex to interact with, especially for keyboard and screen reader users. Use it only when necessary and aim to keep the interaction simple and respect the component usage recommendations as much as possible.

## How to use

- Use the `onChange` prop to update the list of suggestions as the user types. You can optionally set the `minQueryLength` prop to delay this behavior until a minimum number of characters has been entered.
- Use the `onSelect` prop to handle the selection of an option, and set the input's `value` prop to the selected option.
- Use the `onClear` prop to handle the clearing of the input field, and reset the input's `value` prop to an empty string to reflect this change.
- The component can receive a flat list or a list of grouped suggestion via the `suggestions` prop. To ensure a consistent and user-friendly experience, keep the visual format uniform. For example, all suggestions include (or not) an icon or a description. Keep labels and descriptions short and easy to scan.
- To support custom input values not present in the suggestion box, enable the `allowNewItems` prop. This will trigger the `onSelection` callback with the user's typed value as argument.

<Story of={Stories.AllowNewItems} />

- For a mobile-optimized experience, use the "immersive" `variant` to open the AutocompleteInput in a modal dialog on narrow viewports.

## Customisation

- The "no results" screen can be customised using the `noResultsMessage` prop.
- The "loading" screen can be customised using the `loadingLabel` prop.
- The "load more" button label can be customised using the `loadMoreLabel` prop.
- The suggestions can be customised by adding avatar images or icons and a description.
- Use the `action` prop to add contextual actions at the bottom of the suggestion box, such as a button to create a new item.

<Story of={Stories.WithAction} />

## Performance

The component's `onChange` callback is debounced by default to avoid excessive calls while the user types. The default debounce delay is set to 300 ms.

For better performance and scalability when loading dynamic, paginated results, use the `loadMore` prop to fetch additional suggestions. When this prop is provided, a "Load more" button appears at the bottom of the suggestion box. You can customize the button label with `loadMoreLabel`. Use `isLoadingMore` to indicate that more suggestions are being fetched, and `aria-setsize` to convey the total number of suggestions available to assistive technologies. Learn more about `aria-setsize` in the [MDN documentation](https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Reference/Attributes/aria-setsize).

<Story of={Stories.LoadMore} />

To ensure you always show the most relevant suggestions, consider using an [Abort Controller](https://developer.mozilla.org/en-US/docs/Web/API/AbortController) to cancel previous requests when the user types a new query. This prevents showing outdated suggestions and improves the user experience.

```tsx
import { useState, useCallback, useRef } from "react";
import { AutocompleteInput } from "@sumup-oss/circuit-ui";

const MyComponent = () => {
  const [suggestions, setSuggestions] = useState([]);
  const abortControllerRef = useRef<AbortController | null>(null);

  const fetchSuggestions = useCallback(async (query: string) => {
    // Abort previous request if it exists
    if (abortControllerRef.current) {
      abortControllerRef.current.abort();
    }
    // Create a new AbortController for the new request
    const controller = new AbortController();
    abortControllerRef.current = controller;

    try {
      const results = await getSuggestions(query, controller.signal);
      setSuggestions(results);
    } catch (error) {
      if (error.name !== "AbortError") {
        // Handle non-abort errors (e.g., server issues)
      }
    }
  }, []);

  return (
    <AutocompleteInput
      label="Customer"
      placeholder="Search for a customer"
      suggestions={suggestions}
      onSearch={fetchSuggestions}
    />
  );
};

async function getSuggestions(query: string, signal: AbortSignal) {
  const response = await fetch(`https://my-search-api.com?query=${query}`, {
    signal,
  });
  if (!response.ok) {
    throw new Error("Network response was not ok");
  }
  return response.json();
}
```

## Accessibility

The AutocompleteInput component is designed to be accessible, adopting ARIA's [Combobox pattern](https://www.w3.org/WAI/ARIA/apg/patterns/combobox/). It includes:

- Keyboard navigation: Users can open the suggestion box by pressing the arrow down key, close it by pressing the Escape key, navigate through suggestions using the up and down arrow keys, and select an option with Enter.
- Screen reader support: The component announces the number of suggestions available and the selected option, if any.
- Focus management: The component manages focus appropriately, focus remains on the input field when the suggestion box is open, and navigated options are announced properly as users navigate through them.
