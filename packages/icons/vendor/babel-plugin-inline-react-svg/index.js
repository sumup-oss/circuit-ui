"use strict";
var __getOwnPropNames = Object.getOwnPropertyNames;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};

// node_modules/@babel/parser/lib/index.js
var require_lib = __commonJS({
  "node_modules/@babel/parser/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    function _objectWithoutPropertiesLoose(source, excluded) {
      if (source == null) return {};
      var target = {};
      var sourceKeys = Object.keys(source);
      var key, i;
      for (i = 0; i < sourceKeys.length; i++) {
        key = sourceKeys[i];
        if (excluded.indexOf(key) >= 0) continue;
        target[key] = source[key];
      }
      return target;
    }
    var Position = class {
      constructor(line, col, index) {
        this.line = void 0;
        this.column = void 0;
        this.index = void 0;
        this.line = line;
        this.column = col;
        this.index = index;
      }
    };
    var SourceLocation = class {
      constructor(start, end) {
        this.start = void 0;
        this.end = void 0;
        this.filename = void 0;
        this.identifierName = void 0;
        this.start = start;
        this.end = end;
      }
    };
    function createPositionWithColumnOffset(position, columnOffset) {
      const {
        line,
        column,
        index
      } = position;
      return new Position(line, column + columnOffset, index + columnOffset);
    }
    var code = "BABEL_PARSER_SOURCETYPE_MODULE_REQUIRED";
    var ModuleErrors = {
      ImportMetaOutsideModule: {
        message: `import.meta may appear only with 'sourceType: "module"'`,
        code
      },
      ImportOutsideModule: {
        message: `'import' and 'export' may appear only with 'sourceType: "module"'`,
        code
      }
    };
    var NodeDescriptions = {
      ArrayPattern: "array destructuring pattern",
      AssignmentExpression: "assignment expression",
      AssignmentPattern: "assignment expression",
      ArrowFunctionExpression: "arrow function expression",
      ConditionalExpression: "conditional expression",
      CatchClause: "catch clause",
      ForOfStatement: "for-of statement",
      ForInStatement: "for-in statement",
      ForStatement: "for-loop",
      FormalParameters: "function parameter list",
      Identifier: "identifier",
      ImportSpecifier: "import specifier",
      ImportDefaultSpecifier: "import default specifier",
      ImportNamespaceSpecifier: "import namespace specifier",
      ObjectPattern: "object destructuring pattern",
      ParenthesizedExpression: "parenthesized expression",
      RestElement: "rest element",
      UpdateExpression: {
        true: "prefix operation",
        false: "postfix operation"
      },
      VariableDeclarator: "variable declaration",
      YieldExpression: "yield expression"
    };
    var toNodeDescription = (node) => node.type === "UpdateExpression" ? NodeDescriptions.UpdateExpression[`${node.prefix}`] : NodeDescriptions[node.type];
    var StandardErrors = {
      AccessorIsGenerator: ({
        kind
      }) => `A ${kind}ter cannot be a generator.`,
      ArgumentsInClass: "'arguments' is only allowed in functions and class methods.",
      AsyncFunctionInSingleStatementContext: "Async functions can only be declared at the top level or inside a block.",
      AwaitBindingIdentifier: "Can not use 'await' as identifier inside an async function.",
      AwaitBindingIdentifierInStaticBlock: "Can not use 'await' as identifier inside a static block.",
      AwaitExpressionFormalParameter: "'await' is not allowed in async function parameters.",
      AwaitUsingNotInAsyncContext: "'await using' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncContext: "'await' is only allowed within async functions and at the top levels of modules.",
      AwaitNotInAsyncFunction: "'await' is only allowed within async functions.",
      BadGetterArity: "A 'get' accessor must not have any formal parameters.",
      BadSetterArity: "A 'set' accessor must have exactly one formal parameter.",
      BadSetterRestParameter: "A 'set' accessor function argument must not be a rest parameter.",
      ConstructorClassField: "Classes may not have a field named 'constructor'.",
      ConstructorClassPrivateField: "Classes may not have a private field named '#constructor'.",
      ConstructorIsAccessor: "Class constructor may not be an accessor.",
      ConstructorIsAsync: "Constructor can't be an async function.",
      ConstructorIsGenerator: "Constructor can't be a generator.",
      DeclarationMissingInitializer: ({
        kind
      }) => `Missing initializer in ${kind} declaration.`,
      DecoratorArgumentsOutsideParentheses: "Decorator arguments must be moved inside parentheses: use '@(decorator(args))' instead of '@(decorator)(args)'.",
      DecoratorBeforeExport: "Decorators must be placed *before* the 'export' keyword. Remove the 'decoratorsBeforeExport: true' option to use the 'export @decorator class {}' syntax.",
      DecoratorsBeforeAfterExport: "Decorators can be placed *either* before or after the 'export' keyword, but not in both locations at the same time.",
      DecoratorConstructor: "Decorators can't be used with a constructor. Did you mean '@dec class { ... }'?",
      DecoratorExportClass: "Decorators must be placed *after* the 'export' keyword. Remove the 'decoratorsBeforeExport: false' option to use the '@decorator export class {}' syntax.",
      DecoratorSemicolon: "Decorators must not be followed by a semicolon.",
      DecoratorStaticBlock: "Decorators can't be used with a static block.",
      DeferImportRequiresNamespace: 'Only `import defer * as x from "./module"` is valid.',
      DeletePrivateField: "Deleting a private field is not allowed.",
      DestructureNamedImport: "ES2015 named imports do not destructure. Use another statement for destructuring after the import.",
      DuplicateConstructor: "Duplicate constructor in the same class.",
      DuplicateDefaultExport: "Only one default export allowed per module.",
      DuplicateExport: ({
        exportName
      }) => `\`${exportName}\` has already been exported. Exported identifiers must be unique.`,
      DuplicateProto: "Redefinition of __proto__ property.",
      DuplicateRegExpFlags: "Duplicate regular expression flag.",
      DynamicImportPhaseRequiresImportExpressions: ({
        phase
      }) => `'import.${phase}(...)' can only be parsed when using the 'createImportExpressions' option.`,
      ElementAfterRest: "Rest element must be last element.",
      EscapedCharNotAnIdentifier: "Invalid Unicode escape.",
      ExportBindingIsString: ({
        localName,
        exportName
      }) => `A string literal cannot be used as an exported binding without \`from\`.
- Did you mean \`export { '${localName}' as '${exportName}' } from 'some-module'\`?`,
      ExportDefaultFromAsIdentifier: "'from' is not allowed as an identifier after 'export default'.",
      ForInOfLoopInitializer: ({
        type
      }) => `'${type === "ForInStatement" ? "for-in" : "for-of"}' loop variable declaration may not have an initializer.`,
      ForInUsing: "For-in loop may not start with 'using' declaration.",
      ForOfAsync: "The left-hand side of a for-of loop may not be 'async'.",
      ForOfLet: "The left-hand side of a for-of loop may not start with 'let'.",
      GeneratorInSingleStatementContext: "Generators can only be declared at the top level or inside a block.",
      IllegalBreakContinue: ({
        type
      }) => `Unsyntactic ${type === "BreakStatement" ? "break" : "continue"}.`,
      IllegalLanguageModeDirective: "Illegal 'use strict' directive in function with non-simple parameter list.",
      IllegalReturn: "'return' outside of function.",
      ImportAttributesUseAssert: "The `assert` keyword in import attributes is deprecated and it has been replaced by the `with` keyword. You can enable the `deprecatedAssertSyntax: true` option in the import attributes plugin to suppress this error.",
      ImportBindingIsString: ({
        importName
      }) => `A string literal cannot be used as an imported binding.
- Did you mean \`import { "${importName}" as foo }\`?`,
      ImportCallArgumentTrailingComma: "Trailing comma is disallowed inside import(...) arguments.",
      ImportCallArity: ({
        maxArgumentCount
      }) => `\`import()\` requires exactly ${maxArgumentCount === 1 ? "one argument" : "one or two arguments"}.`,
      ImportCallNotNewExpression: "Cannot use new with import(...).",
      ImportCallSpreadArgument: "`...` is not allowed in `import()`.",
      ImportJSONBindingNotDefault: "A JSON module can only be imported with `default`.",
      ImportReflectionHasAssertion: "`import module x` cannot have assertions.",
      ImportReflectionNotBinding: 'Only `import module x from "./module"` is valid.',
      IncompatibleRegExpUVFlags: "The 'u' and 'v' regular expression flags cannot be enabled at the same time.",
      InvalidBigIntLiteral: "Invalid BigIntLiteral.",
      InvalidCodePoint: "Code point out of bounds.",
      InvalidCoverInitializedName: "Invalid shorthand property initializer.",
      InvalidDecimal: "Invalid decimal.",
      InvalidDigit: ({
        radix
      }) => `Expected number in radix ${radix}.`,
      InvalidEscapeSequence: "Bad character escape sequence.",
      InvalidEscapeSequenceTemplate: "Invalid escape sequence in template.",
      InvalidEscapedReservedWord: ({
        reservedWord
      }) => `Escape sequence in keyword ${reservedWord}.`,
      InvalidIdentifier: ({
        identifierName
      }) => `Invalid identifier ${identifierName}.`,
      InvalidLhs: ({
        ancestor
      }) => `Invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsBinding: ({
        ancestor
      }) => `Binding invalid left-hand side in ${toNodeDescription(ancestor)}.`,
      InvalidLhsOptionalChaining: ({
        ancestor
      }) => `Invalid optional chaining in the left-hand side of ${toNodeDescription(ancestor)}.`,
      InvalidNumber: "Invalid number.",
      InvalidOrMissingExponent: "Floating-point numbers require a valid exponent after the 'e'.",
      InvalidOrUnexpectedToken: ({
        unexpected
      }) => `Unexpected character '${unexpected}'.`,
      InvalidParenthesizedAssignment: "Invalid parenthesized assignment pattern.",
      InvalidPrivateFieldResolution: ({
        identifierName
      }) => `Private name #${identifierName} is not defined.`,
      InvalidPropertyBindingPattern: "Binding member expression.",
      InvalidRecordProperty: "Only properties and spread elements are allowed in record definitions.",
      InvalidRestAssignmentPattern: "Invalid rest operator's argument.",
      LabelRedeclaration: ({
        labelName
      }) => `Label '${labelName}' is already declared.`,
      LetInLexicalBinding: "'let' is disallowed as a lexically bound name.",
      LineTerminatorBeforeArrow: "No line break is allowed before '=>'.",
      MalformedRegExpFlags: "Invalid regular expression flag.",
      MissingClassName: "A class name is required.",
      MissingEqInAssignment: "Only '=' operator can be used for specifying default value.",
      MissingSemicolon: "Missing semicolon.",
      MissingPlugin: ({
        missingPlugin
      }) => `This experimental syntax requires enabling the parser plugin: ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingOneOfPlugins: ({
        missingPlugin
      }) => `This experimental syntax requires enabling one of the following parser plugin(s): ${missingPlugin.map((name) => JSON.stringify(name)).join(", ")}.`,
      MissingUnicodeEscape: "Expecting Unicode escape sequence \\uXXXX.",
      MixingCoalesceWithLogical: "Nullish coalescing operator(??) requires parens when mixing with logical operators.",
      ModuleAttributeDifferentFromType: "The only accepted module attribute is `type`.",
      ModuleAttributeInvalidValue: "Only string literals are allowed as module attribute values.",
      ModuleAttributesWithDuplicateKeys: ({
        key
      }) => `Duplicate key "${key}" is not allowed in module attributes.`,
      ModuleExportNameHasLoneSurrogate: ({
        surrogateCharCode
      }) => `An export name cannot include a lone surrogate, found '\\u${surrogateCharCode.toString(16)}'.`,
      ModuleExportUndefined: ({
        localName
      }) => `Export '${localName}' is not defined.`,
      MultipleDefaultsInSwitch: "Multiple default clauses.",
      NewlineAfterThrow: "Illegal newline after throw.",
      NoCatchOrFinally: "Missing catch or finally clause.",
      NumberIdentifier: "Identifier directly after number.",
      NumericSeparatorInEscapeSequence: "Numeric separators are not allowed inside unicode escape sequences or hex escape sequences.",
      ObsoleteAwaitStar: "'await*' has been removed from the async functions proposal. Use Promise.all() instead.",
      OptionalChainingNoNew: "Constructors in/after an Optional Chain are not allowed.",
      OptionalChainingNoTemplate: "Tagged Template Literals are not allowed in optionalChain.",
      OverrideOnConstructor: "'override' modifier cannot appear on a constructor declaration.",
      ParamDupe: "Argument name clash.",
      PatternHasAccessor: "Object pattern can't contain getter or setter.",
      PatternHasMethod: "Object pattern can't contain methods.",
      PrivateInExpectedIn: ({
        identifierName
      }) => `Private names are only allowed in property accesses (\`obj.#${identifierName}\`) or in \`in\` expressions (\`#${identifierName} in obj\`).`,
      PrivateNameRedeclaration: ({
        identifierName
      }) => `Duplicate private name #${identifierName}.`,
      RecordExpressionBarIncorrectEndSyntaxType: "Record expressions ending with '|}' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionBarIncorrectStartSyntaxType: "Record expressions starting with '{|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      RecordExpressionHashIncorrectStartSyntaxType: "Record expressions starting with '#{' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      RecordNoProto: "'__proto__' is not allowed in Record expressions.",
      RestTrailingComma: "Unexpected trailing comma after rest element.",
      SloppyFunction: "In non-strict mode code, functions can only be declared at top level or inside a block.",
      SloppyFunctionAnnexB: "In non-strict mode code, functions can only be declared at top level, inside a block, or as the body of an if statement.",
      SourcePhaseImportRequiresDefault: 'Only `import source x from "./module"` is valid.',
      StaticPrototype: "Classes may not have static property named prototype.",
      SuperNotAllowed: "`super()` is only valid inside a class constructor of a subclass. Maybe a typo in the method name ('constructor') or not extending another class?",
      SuperPrivateField: "Private fields can't be accessed on super.",
      TrailingDecorator: "Decorators must be attached to a class element.",
      TupleExpressionBarIncorrectEndSyntaxType: "Tuple expressions ending with '|]' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionBarIncorrectStartSyntaxType: "Tuple expressions starting with '[|' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'bar'.",
      TupleExpressionHashIncorrectStartSyntaxType: "Tuple expressions starting with '#[' are only allowed when the 'syntaxType' option of the 'recordAndTuple' plugin is set to 'hash'.",
      UnexpectedArgumentPlaceholder: "Unexpected argument placeholder.",
      UnexpectedAwaitAfterPipelineBody: 'Unexpected "await" after pipeline body; await must have parentheses in minimal proposal.',
      UnexpectedDigitAfterHash: "Unexpected digit after hash token.",
      UnexpectedImportExport: "'import' and 'export' may only appear at the top level.",
      UnexpectedKeyword: ({
        keyword
      }) => `Unexpected keyword '${keyword}'.`,
      UnexpectedLeadingDecorator: "Leading decorators must be attached to a class declaration.",
      UnexpectedLexicalDeclaration: "Lexical declaration cannot appear in a single-statement context.",
      UnexpectedNewTarget: "`new.target` can only be used in functions or class properties.",
      UnexpectedNumericSeparator: "A numeric separator is only allowed between two digits.",
      UnexpectedPrivateField: "Unexpected private name.",
      UnexpectedReservedWord: ({
        reservedWord
      }) => `Unexpected reserved word '${reservedWord}'.`,
      UnexpectedSuper: "'super' is only allowed in object methods and classes.",
      UnexpectedToken: ({
        expected,
        unexpected
      }) => `Unexpected token${unexpected ? ` '${unexpected}'.` : ""}${expected ? `, expected "${expected}"` : ""}`,
      UnexpectedTokenUnaryExponentiation: "Illegal expression. Wrap left hand side or entire exponentiation in parentheses.",
      UnexpectedUsingDeclaration: "Using declaration cannot appear in the top level when source type is `script`.",
      UnsupportedBind: "Binding should be performed on object property.",
      UnsupportedDecoratorExport: "A decorated export must export a class declaration.",
      UnsupportedDefaultExport: "Only expressions, functions or classes are allowed as the `default` export.",
      UnsupportedImport: "`import` can only be used in `import()` or `import.meta`.",
      UnsupportedMetaProperty: ({
        target,
        onlyValidPropertyName
      }) => `The only valid meta property for ${target} is ${target}.${onlyValidPropertyName}.`,
      UnsupportedParameterDecorator: "Decorators cannot be used to decorate parameters.",
      UnsupportedPropertyDecorator: "Decorators cannot be used to decorate object literal properties.",
      UnsupportedSuper: "'super' can only be used with function calls (i.e. super()) or in property accesses (i.e. super.prop or super[prop]).",
      UnterminatedComment: "Unterminated comment.",
      UnterminatedRegExp: "Unterminated regular expression.",
      UnterminatedString: "Unterminated string constant.",
      UnterminatedTemplate: "Unterminated template.",
      UsingDeclarationExport: "Using declaration cannot be exported.",
      UsingDeclarationHasBindingPattern: "Using declaration cannot have destructuring patterns.",
      VarRedeclaration: ({
        identifierName
      }) => `Identifier '${identifierName}' has already been declared.`,
      YieldBindingIdentifier: "Can not use 'yield' as identifier inside a generator.",
      YieldInParameter: "Yield expression is not allowed in formal parameters.",
      ZeroDigitNumericSeparator: "Numeric separator can not be used after leading 0."
    };
    var StrictModeErrors = {
      StrictDelete: "Deleting local variable in strict mode.",
      StrictEvalArguments: ({
        referenceName
      }) => `Assigning to '${referenceName}' in strict mode.`,
      StrictEvalArgumentsBinding: ({
        bindingName
      }) => `Binding '${bindingName}' in strict mode.`,
      StrictFunction: "In strict mode code, functions can only be declared at top level or inside a block.",
      StrictNumericEscape: "The only valid numeric escape in strict mode is '\\0'.",
      StrictOctalLiteral: "Legacy octal literals are not allowed in strict mode.",
      StrictWith: "'with' in strict mode."
    };
    var UnparenthesizedPipeBodyDescriptions = /* @__PURE__ */ new Set(["ArrowFunctionExpression", "AssignmentExpression", "ConditionalExpression", "YieldExpression"]);
    var PipelineOperatorErrors = {
      PipeBodyIsTighter: "Unexpected yield after pipeline body; any yield expression acting as Hack-style pipe body must be parenthesized due to its loose operator precedence.",
      PipeTopicRequiresHackPipes: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.',
      PipeTopicUnbound: "Topic reference is unbound; it must be inside a pipe body.",
      PipeTopicUnconfiguredToken: ({
        token
      }) => `Invalid topic token ${token}. In order to use ${token} as a topic reference, the pipelineOperator plugin must be configured with { "proposal": "hack", "topicToken": "${token}" }.`,
      PipeTopicUnused: "Hack-style pipe body does not contain a topic reference; Hack-style pipes must use topic at least once.",
      PipeUnparenthesizedBody: ({
        type
      }) => `Hack-style pipe body cannot be an unparenthesized ${toNodeDescription({
        type
      })}; please wrap it in parentheses.`,
      PipelineBodyNoArrow: 'Unexpected arrow "=>" after pipeline body; arrow function in pipeline body must be parenthesized.',
      PipelineBodySequenceExpression: "Pipeline body may not be a comma-separated sequence expression.",
      PipelineHeadSequenceExpression: "Pipeline head should not be a comma-separated sequence expression.",
      PipelineTopicUnused: "Pipeline is in topic style but does not use topic reference.",
      PrimaryTopicNotAllowed: "Topic reference was used in a lexical context without topic binding.",
      PrimaryTopicRequiresSmartPipeline: 'Topic reference is used, but the pipelineOperator plugin was not passed a "proposal": "hack" or "smart" option.'
    };
    var _excluded = ["toMessage"];
    var _excluded2 = ["message"];
    function defineHidden(obj, key, value) {
      Object.defineProperty(obj, key, {
        enumerable: false,
        configurable: true,
        value
      });
    }
    function toParseErrorConstructor(_ref) {
      let {
        toMessage
      } = _ref, properties = _objectWithoutPropertiesLoose(_ref, _excluded);
      return function constructor(loc, details) {
        const error = new SyntaxError();
        Object.assign(error, properties, {
          loc,
          pos: loc.index
        });
        if ("missingPlugin" in details) {
          Object.assign(error, {
            missingPlugin: details.missingPlugin
          });
        }
        defineHidden(error, "clone", function clone(overrides = {}) {
          var _overrides$loc;
          const {
            line,
            column,
            index
          } = (_overrides$loc = overrides.loc) != null ? _overrides$loc : loc;
          return constructor(new Position(line, column, index), Object.assign({}, details, overrides.details));
        });
        defineHidden(error, "details", details);
        Object.defineProperty(error, "message", {
          configurable: true,
          get() {
            const message = `${toMessage(details)} (${loc.line}:${loc.column})`;
            this.message = message;
            return message;
          },
          set(value) {
            Object.defineProperty(this, "message", {
              value,
              writable: true
            });
          }
        });
        return error;
      };
    }
    function ParseErrorEnum(argument, syntaxPlugin) {
      if (Array.isArray(argument)) {
        return (parseErrorTemplates) => ParseErrorEnum(parseErrorTemplates, argument[0]);
      }
      const ParseErrorConstructors = {};
      for (const reasonCode of Object.keys(argument)) {
        const template = argument[reasonCode];
        const _ref2 = typeof template === "string" ? {
          message: () => template
        } : typeof template === "function" ? {
          message: template
        } : template, {
          message
        } = _ref2, rest = _objectWithoutPropertiesLoose(_ref2, _excluded2);
        const toMessage = typeof message === "string" ? () => message : message;
        ParseErrorConstructors[reasonCode] = toParseErrorConstructor(Object.assign({
          code: "BABEL_PARSER_SYNTAX_ERROR",
          reasonCode,
          toMessage
        }, syntaxPlugin ? {
          syntaxPlugin
        } : {}, rest));
      }
      return ParseErrorConstructors;
    }
    var Errors = Object.assign({}, ParseErrorEnum(ModuleErrors), ParseErrorEnum(StandardErrors), ParseErrorEnum(StrictModeErrors), ParseErrorEnum`pipelineOperator`(PipelineOperatorErrors));
    var {
      defineProperty
    } = Object;
    var toUnenumerable = (object, key) => {
      if (object) {
        defineProperty(object, key, {
          enumerable: false,
          value: object[key]
        });
      }
    };
    function toESTreeLocation(node) {
      toUnenumerable(node.loc.start, "index");
      toUnenumerable(node.loc.end, "index");
      return node;
    }
    var estree = (superClass) => class ESTreeParserMixin extends superClass {
      parse() {
        const file = toESTreeLocation(super.parse());
        if (this.options.tokens) {
          file.tokens = file.tokens.map(toESTreeLocation);
        }
        return file;
      }
      parseRegExpLiteral({
        pattern,
        flags
      }) {
        let regex = null;
        try {
          regex = new RegExp(pattern, flags);
        } catch (_) {
        }
        const node = this.estreeParseLiteral(regex);
        node.regex = {
          pattern,
          flags
        };
        return node;
      }
      parseBigIntLiteral(value) {
        let bigInt;
        try {
          bigInt = BigInt(value);
        } catch (_unused) {
          bigInt = null;
        }
        const node = this.estreeParseLiteral(bigInt);
        node.bigint = String(node.value || value);
        return node;
      }
      parseDecimalLiteral(value) {
        const decimal = null;
        const node = this.estreeParseLiteral(decimal);
        node.decimal = String(node.value || value);
        return node;
      }
      estreeParseLiteral(value) {
        return this.parseLiteral(value, "Literal");
      }
      parseStringLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNumericLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      parseNullLiteral() {
        return this.estreeParseLiteral(null);
      }
      parseBooleanLiteral(value) {
        return this.estreeParseLiteral(value);
      }
      directiveToStmt(directive) {
        const expression = directive.value;
        delete directive.value;
        expression.type = "Literal";
        expression.raw = expression.extra.raw;
        expression.value = expression.extra.expressionValue;
        const stmt = directive;
        stmt.type = "ExpressionStatement";
        stmt.expression = expression;
        stmt.directive = expression.extra.rawValue;
        delete expression.extra;
        return stmt;
      }
      initFunction(node, isAsync) {
        super.initFunction(node, isAsync);
        node.expression = false;
      }
      checkDeclaration(node) {
        if (node != null && this.isObjectProperty(node)) {
          this.checkDeclaration(node.value);
        } else {
          super.checkDeclaration(node);
        }
      }
      getObjectOrClassMethodParams(method) {
        return method.value.params;
      }
      isValidDirective(stmt) {
        var _stmt$expression$extr;
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "Literal" && typeof stmt.expression.value === "string" && !((_stmt$expression$extr = stmt.expression.extra) != null && _stmt$expression$extr.parenthesized);
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        super.parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse);
        const directiveStatements = node.directives.map((d) => this.directiveToStmt(d));
        node.body = directiveStatements.concat(node.body);
        delete node.directives;
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true);
        if (method.typeParameters) {
          method.value.typeParameters = method.typeParameters;
          delete method.typeParameters;
        }
        classBody.body.push(method);
      }
      parsePrivateName() {
        const node = super.parsePrivateName();
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return node;
          }
        }
        return this.convertPrivateNameToPrivateIdentifier(node);
      }
      convertPrivateNameToPrivateIdentifier(node) {
        const name = super.getPrivateNameSV(node);
        node = node;
        delete node.id;
        node.name = name;
        node.type = "PrivateIdentifier";
        return node;
      }
      isPrivateName(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.isPrivateName(node);
          }
        }
        return node.type === "PrivateIdentifier";
      }
      getPrivateNameSV(node) {
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return super.getPrivateNameSV(node);
          }
        }
        return node.name;
      }
      parseLiteral(value, type) {
        const node = super.parseLiteral(value, type);
        node.raw = node.extra.raw;
        delete node.extra;
        return node;
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        super.parseFunctionBody(node, allowExpression, isMethod);
        node.expression = node.body.type !== "BlockStatement";
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        let funcNode = this.startNode();
        funcNode.kind = node.kind;
        funcNode = super.parseMethod(funcNode, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        funcNode.type = "FunctionExpression";
        delete funcNode.kind;
        node.value = funcNode;
        if (type === "ClassPrivateMethod") {
          node.computed = false;
        }
        return this.finishNode(node, "MethodDefinition");
      }
      nameIsConstructor(key) {
        if (key.type === "Literal") return key.value === "constructor";
        return super.nameIsConstructor(key);
      }
      parseClassProperty(...args) {
        const propertyNode = super.parseClassProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        return propertyNode;
      }
      parseClassPrivateProperty(...args) {
        const propertyNode = super.parseClassPrivateProperty(...args);
        {
          if (!this.getPluginOption("estree", "classFeatures")) {
            return propertyNode;
          }
        }
        propertyNode.type = "PropertyDefinition";
        propertyNode.computed = false;
        return propertyNode;
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        const node = super.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor);
        if (node) {
          node.type = "Property";
          if (node.kind === "method") {
            node.kind = "init";
          }
          node.shorthand = false;
        }
        return node;
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        const node = super.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (node) {
          node.kind = "init";
          node.type = "Property";
        }
        return node;
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return type === "Property" ? "value" : super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      isAssignable(node, isBinding) {
        if (node != null && this.isObjectProperty(node)) {
          return this.isAssignable(node.value, isBinding);
        }
        return super.isAssignable(node, isBinding);
      }
      toAssignable(node, isLHS = false) {
        if (node != null && this.isObjectProperty(node)) {
          const {
            key,
            value
          } = node;
          if (this.isPrivateName(key)) {
            this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
          }
          this.toAssignable(value, isLHS);
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "Property" && (prop.kind === "get" || prop.kind === "set")) {
          this.raise(Errors.PatternHasAccessor, prop.key);
        } else if (prop.type === "Property" && prop.method) {
          this.raise(Errors.PatternHasMethod, prop.key);
        } else {
          super.toAssignableObjectExpressionProp(prop, isLast, isLHS);
        }
      }
      finishCallExpression(unfinished, optional) {
        const node = super.finishCallExpression(unfinished, optional);
        if (node.callee.type === "Import") {
          node.type = "ImportExpression";
          node.source = node.arguments[0];
          if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
            var _ref, _ref2;
            node.options = (_ref = node.arguments[1]) != null ? _ref : null;
            node.attributes = (_ref2 = node.arguments[1]) != null ? _ref2 : null;
          }
          delete node.arguments;
          delete node.callee;
        }
        return node;
      }
      toReferencedArguments(node) {
        if (node.type === "ImportExpression") {
          return;
        }
        super.toReferencedArguments(node);
      }
      parseExport(unfinished, decorators) {
        const exportStartLoc = this.state.lastTokStartLoc;
        const node = super.parseExport(unfinished, decorators);
        switch (node.type) {
          case "ExportAllDeclaration":
            node.exported = null;
            break;
          case "ExportNamedDeclaration":
            if (node.specifiers.length === 1 && node.specifiers[0].type === "ExportNamespaceSpecifier") {
              node.type = "ExportAllDeclaration";
              node.exported = node.specifiers[0].exported;
              delete node.specifiers;
            }
          case "ExportDefaultDeclaration":
            {
              var _declaration$decorato;
              const {
                declaration
              } = node;
              if ((declaration == null ? void 0 : declaration.type) === "ClassDeclaration" && ((_declaration$decorato = declaration.decorators) == null ? void 0 : _declaration$decorato.length) > 0 && declaration.start === node.start) {
                this.resetStartLocation(node, exportStartLoc);
              }
            }
            break;
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const node = super.parseSubscript(base, startLoc, noCalls, state);
        if (state.optionalChainMember) {
          if (node.type === "OptionalMemberExpression" || node.type === "OptionalCallExpression") {
            node.type = node.type.substring(8);
          }
          if (state.stop) {
            const chain = this.startNodeAtNode(node);
            chain.expression = node;
            return this.finishNode(chain, "ChainExpression");
          }
        } else if (node.type === "MemberExpression" || node.type === "CallExpression") {
          node.optional = false;
        }
        return node;
      }
      isOptionalMemberExpression(node) {
        if (node.type === "ChainExpression") {
          return node.expression.type === "MemberExpression";
        }
        return super.isOptionalMemberExpression(node);
      }
      hasPropertyAsPrivateName(node) {
        if (node.type === "ChainExpression") {
          node = node.expression;
        }
        return super.hasPropertyAsPrivateName(node);
      }
      isObjectProperty(node) {
        return node.type === "Property" && node.kind === "init" && !node.method;
      }
      isObjectMethod(node) {
        return node.type === "Property" && (node.method || node.kind === "get" || node.kind === "set");
      }
      finishNodeAt(node, type, endLoc) {
        return toESTreeLocation(super.finishNodeAt(node, type, endLoc));
      }
      resetStartLocation(node, startLoc) {
        super.resetStartLocation(node, startLoc);
        toESTreeLocation(node);
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        super.resetEndLocation(node, endLoc);
        toESTreeLocation(node);
      }
    };
    var TokContext = class {
      constructor(token, preserveSpace) {
        this.token = void 0;
        this.preserveSpace = void 0;
        this.token = token;
        this.preserveSpace = !!preserveSpace;
      }
    };
    var types = {
      brace: new TokContext("{"),
      j_oTag: new TokContext("<tag"),
      j_cTag: new TokContext("</tag"),
      j_expr: new TokContext("<tag>...</tag>", true)
    };
    {
      types.template = new TokContext("`", true);
    }
    var beforeExpr = true;
    var startsExpr = true;
    var isLoop = true;
    var isAssign = true;
    var prefix = true;
    var postfix = true;
    var ExportedTokenType = class {
      constructor(label, conf = {}) {
        this.label = void 0;
        this.keyword = void 0;
        this.beforeExpr = void 0;
        this.startsExpr = void 0;
        this.rightAssociative = void 0;
        this.isLoop = void 0;
        this.isAssign = void 0;
        this.prefix = void 0;
        this.postfix = void 0;
        this.binop = void 0;
        this.label = label;
        this.keyword = conf.keyword;
        this.beforeExpr = !!conf.beforeExpr;
        this.startsExpr = !!conf.startsExpr;
        this.rightAssociative = !!conf.rightAssociative;
        this.isLoop = !!conf.isLoop;
        this.isAssign = !!conf.isAssign;
        this.prefix = !!conf.prefix;
        this.postfix = !!conf.postfix;
        this.binop = conf.binop != null ? conf.binop : null;
        {
          this.updateContext = null;
        }
      }
    };
    var keywords$1 = /* @__PURE__ */ new Map();
    function createKeyword(name, options = {}) {
      options.keyword = name;
      const token = createToken(name, options);
      keywords$1.set(name, token);
      return token;
    }
    function createBinop(name, binop) {
      return createToken(name, {
        beforeExpr,
        binop
      });
    }
    var tokenTypeCounter = -1;
    var tokenTypes = [];
    var tokenLabels = [];
    var tokenBinops = [];
    var tokenBeforeExprs = [];
    var tokenStartsExprs = [];
    var tokenPrefixes = [];
    function createToken(name, options = {}) {
      var _options$binop, _options$beforeExpr, _options$startsExpr, _options$prefix;
      ++tokenTypeCounter;
      tokenLabels.push(name);
      tokenBinops.push((_options$binop = options.binop) != null ? _options$binop : -1);
      tokenBeforeExprs.push((_options$beforeExpr = options.beforeExpr) != null ? _options$beforeExpr : false);
      tokenStartsExprs.push((_options$startsExpr = options.startsExpr) != null ? _options$startsExpr : false);
      tokenPrefixes.push((_options$prefix = options.prefix) != null ? _options$prefix : false);
      tokenTypes.push(new ExportedTokenType(name, options));
      return tokenTypeCounter;
    }
    function createKeywordLike(name, options = {}) {
      var _options$binop2, _options$beforeExpr2, _options$startsExpr2, _options$prefix2;
      ++tokenTypeCounter;
      keywords$1.set(name, tokenTypeCounter);
      tokenLabels.push(name);
      tokenBinops.push((_options$binop2 = options.binop) != null ? _options$binop2 : -1);
      tokenBeforeExprs.push((_options$beforeExpr2 = options.beforeExpr) != null ? _options$beforeExpr2 : false);
      tokenStartsExprs.push((_options$startsExpr2 = options.startsExpr) != null ? _options$startsExpr2 : false);
      tokenPrefixes.push((_options$prefix2 = options.prefix) != null ? _options$prefix2 : false);
      tokenTypes.push(new ExportedTokenType("name", options));
      return tokenTypeCounter;
    }
    var tt = {
      bracketL: createToken("[", {
        beforeExpr,
        startsExpr
      }),
      bracketHashL: createToken("#[", {
        beforeExpr,
        startsExpr
      }),
      bracketBarL: createToken("[|", {
        beforeExpr,
        startsExpr
      }),
      bracketR: createToken("]"),
      bracketBarR: createToken("|]"),
      braceL: createToken("{", {
        beforeExpr,
        startsExpr
      }),
      braceBarL: createToken("{|", {
        beforeExpr,
        startsExpr
      }),
      braceHashL: createToken("#{", {
        beforeExpr,
        startsExpr
      }),
      braceR: createToken("}"),
      braceBarR: createToken("|}"),
      parenL: createToken("(", {
        beforeExpr,
        startsExpr
      }),
      parenR: createToken(")"),
      comma: createToken(",", {
        beforeExpr
      }),
      semi: createToken(";", {
        beforeExpr
      }),
      colon: createToken(":", {
        beforeExpr
      }),
      doubleColon: createToken("::", {
        beforeExpr
      }),
      dot: createToken("."),
      question: createToken("?", {
        beforeExpr
      }),
      questionDot: createToken("?."),
      arrow: createToken("=>", {
        beforeExpr
      }),
      template: createToken("template"),
      ellipsis: createToken("...", {
        beforeExpr
      }),
      backQuote: createToken("`", {
        startsExpr
      }),
      dollarBraceL: createToken("${", {
        beforeExpr,
        startsExpr
      }),
      templateTail: createToken("...`", {
        startsExpr
      }),
      templateNonTail: createToken("...${", {
        beforeExpr,
        startsExpr
      }),
      at: createToken("@"),
      hash: createToken("#", {
        startsExpr
      }),
      interpreterDirective: createToken("#!..."),
      eq: createToken("=", {
        beforeExpr,
        isAssign
      }),
      assign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      slashAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      xorAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      moduloAssign: createToken("_=", {
        beforeExpr,
        isAssign
      }),
      incDec: createToken("++/--", {
        prefix,
        postfix,
        startsExpr
      }),
      bang: createToken("!", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      tilde: createToken("~", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      doubleCaret: createToken("^^", {
        startsExpr
      }),
      doubleAt: createToken("@@", {
        startsExpr
      }),
      pipeline: createBinop("|>", 0),
      nullishCoalescing: createBinop("??", 1),
      logicalOR: createBinop("||", 1),
      logicalAND: createBinop("&&", 2),
      bitwiseOR: createBinop("|", 3),
      bitwiseXOR: createBinop("^", 4),
      bitwiseAND: createBinop("&", 5),
      equality: createBinop("==/!=/===/!==", 6),
      lt: createBinop("</>/<=/>=", 7),
      gt: createBinop("</>/<=/>=", 7),
      relational: createBinop("</>/<=/>=", 7),
      bitShift: createBinop("<</>>/>>>", 8),
      bitShiftL: createBinop("<</>>/>>>", 8),
      bitShiftR: createBinop("<</>>/>>>", 8),
      plusMin: createToken("+/-", {
        beforeExpr,
        binop: 9,
        prefix,
        startsExpr
      }),
      modulo: createToken("%", {
        binop: 10,
        startsExpr
      }),
      star: createToken("*", {
        binop: 10
      }),
      slash: createBinop("/", 10),
      exponent: createToken("**", {
        beforeExpr,
        binop: 11,
        rightAssociative: true
      }),
      _in: createKeyword("in", {
        beforeExpr,
        binop: 7
      }),
      _instanceof: createKeyword("instanceof", {
        beforeExpr,
        binop: 7
      }),
      _break: createKeyword("break"),
      _case: createKeyword("case", {
        beforeExpr
      }),
      _catch: createKeyword("catch"),
      _continue: createKeyword("continue"),
      _debugger: createKeyword("debugger"),
      _default: createKeyword("default", {
        beforeExpr
      }),
      _else: createKeyword("else", {
        beforeExpr
      }),
      _finally: createKeyword("finally"),
      _function: createKeyword("function", {
        startsExpr
      }),
      _if: createKeyword("if"),
      _return: createKeyword("return", {
        beforeExpr
      }),
      _switch: createKeyword("switch"),
      _throw: createKeyword("throw", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _try: createKeyword("try"),
      _var: createKeyword("var"),
      _const: createKeyword("const"),
      _with: createKeyword("with"),
      _new: createKeyword("new", {
        beforeExpr,
        startsExpr
      }),
      _this: createKeyword("this", {
        startsExpr
      }),
      _super: createKeyword("super", {
        startsExpr
      }),
      _class: createKeyword("class", {
        startsExpr
      }),
      _extends: createKeyword("extends", {
        beforeExpr
      }),
      _export: createKeyword("export"),
      _import: createKeyword("import", {
        startsExpr
      }),
      _null: createKeyword("null", {
        startsExpr
      }),
      _true: createKeyword("true", {
        startsExpr
      }),
      _false: createKeyword("false", {
        startsExpr
      }),
      _typeof: createKeyword("typeof", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _void: createKeyword("void", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _delete: createKeyword("delete", {
        beforeExpr,
        prefix,
        startsExpr
      }),
      _do: createKeyword("do", {
        isLoop,
        beforeExpr
      }),
      _for: createKeyword("for", {
        isLoop
      }),
      _while: createKeyword("while", {
        isLoop
      }),
      _as: createKeywordLike("as", {
        startsExpr
      }),
      _assert: createKeywordLike("assert", {
        startsExpr
      }),
      _async: createKeywordLike("async", {
        startsExpr
      }),
      _await: createKeywordLike("await", {
        startsExpr
      }),
      _defer: createKeywordLike("defer", {
        startsExpr
      }),
      _from: createKeywordLike("from", {
        startsExpr
      }),
      _get: createKeywordLike("get", {
        startsExpr
      }),
      _let: createKeywordLike("let", {
        startsExpr
      }),
      _meta: createKeywordLike("meta", {
        startsExpr
      }),
      _of: createKeywordLike("of", {
        startsExpr
      }),
      _sent: createKeywordLike("sent", {
        startsExpr
      }),
      _set: createKeywordLike("set", {
        startsExpr
      }),
      _source: createKeywordLike("source", {
        startsExpr
      }),
      _static: createKeywordLike("static", {
        startsExpr
      }),
      _using: createKeywordLike("using", {
        startsExpr
      }),
      _yield: createKeywordLike("yield", {
        startsExpr
      }),
      _asserts: createKeywordLike("asserts", {
        startsExpr
      }),
      _checks: createKeywordLike("checks", {
        startsExpr
      }),
      _exports: createKeywordLike("exports", {
        startsExpr
      }),
      _global: createKeywordLike("global", {
        startsExpr
      }),
      _implements: createKeywordLike("implements", {
        startsExpr
      }),
      _intrinsic: createKeywordLike("intrinsic", {
        startsExpr
      }),
      _infer: createKeywordLike("infer", {
        startsExpr
      }),
      _is: createKeywordLike("is", {
        startsExpr
      }),
      _mixins: createKeywordLike("mixins", {
        startsExpr
      }),
      _proto: createKeywordLike("proto", {
        startsExpr
      }),
      _require: createKeywordLike("require", {
        startsExpr
      }),
      _satisfies: createKeywordLike("satisfies", {
        startsExpr
      }),
      _keyof: createKeywordLike("keyof", {
        startsExpr
      }),
      _readonly: createKeywordLike("readonly", {
        startsExpr
      }),
      _unique: createKeywordLike("unique", {
        startsExpr
      }),
      _abstract: createKeywordLike("abstract", {
        startsExpr
      }),
      _declare: createKeywordLike("declare", {
        startsExpr
      }),
      _enum: createKeywordLike("enum", {
        startsExpr
      }),
      _module: createKeywordLike("module", {
        startsExpr
      }),
      _namespace: createKeywordLike("namespace", {
        startsExpr
      }),
      _interface: createKeywordLike("interface", {
        startsExpr
      }),
      _type: createKeywordLike("type", {
        startsExpr
      }),
      _opaque: createKeywordLike("opaque", {
        startsExpr
      }),
      name: createToken("name", {
        startsExpr
      }),
      string: createToken("string", {
        startsExpr
      }),
      num: createToken("num", {
        startsExpr
      }),
      bigint: createToken("bigint", {
        startsExpr
      }),
      decimal: createToken("decimal", {
        startsExpr
      }),
      regexp: createToken("regexp", {
        startsExpr
      }),
      privateName: createToken("#name", {
        startsExpr
      }),
      eof: createToken("eof"),
      jsxName: createToken("jsxName"),
      jsxText: createToken("jsxText", {
        beforeExpr: true
      }),
      jsxTagStart: createToken("jsxTagStart", {
        startsExpr: true
      }),
      jsxTagEnd: createToken("jsxTagEnd"),
      placeholder: createToken("%%", {
        startsExpr: true
      })
    };
    function tokenIsIdentifier(token) {
      return token >= 93 && token <= 132;
    }
    function tokenKeywordOrIdentifierIsKeyword(token) {
      return token <= 92;
    }
    function tokenIsKeywordOrIdentifier(token) {
      return token >= 58 && token <= 132;
    }
    function tokenIsLiteralPropertyName(token) {
      return token >= 58 && token <= 136;
    }
    function tokenComesBeforeExpression(token) {
      return tokenBeforeExprs[token];
    }
    function tokenCanStartExpression(token) {
      return tokenStartsExprs[token];
    }
    function tokenIsAssignment(token) {
      return token >= 29 && token <= 33;
    }
    function tokenIsFlowInterfaceOrTypeOrOpaque(token) {
      return token >= 129 && token <= 131;
    }
    function tokenIsLoop(token) {
      return token >= 90 && token <= 92;
    }
    function tokenIsKeyword(token) {
      return token >= 58 && token <= 92;
    }
    function tokenIsOperator(token) {
      return token >= 39 && token <= 59;
    }
    function tokenIsPostfix(token) {
      return token === 34;
    }
    function tokenIsPrefix(token) {
      return tokenPrefixes[token];
    }
    function tokenIsTSTypeOperator(token) {
      return token >= 121 && token <= 123;
    }
    function tokenIsTSDeclarationStart(token) {
      return token >= 124 && token <= 130;
    }
    function tokenLabelName(token) {
      return tokenLabels[token];
    }
    function tokenOperatorPrecedence(token) {
      return tokenBinops[token];
    }
    function tokenIsRightAssociative(token) {
      return token === 57;
    }
    function tokenIsTemplate(token) {
      return token >= 24 && token <= 25;
    }
    function getExportedToken(token) {
      return tokenTypes[token];
    }
    {
      tokenTypes[8].updateContext = (context) => {
        context.pop();
      };
      tokenTypes[5].updateContext = tokenTypes[7].updateContext = tokenTypes[23].updateContext = (context) => {
        context.push(types.brace);
      };
      tokenTypes[22].updateContext = (context) => {
        if (context[context.length - 1] === types.template) {
          context.pop();
        } else {
          context.push(types.template);
        }
      };
      tokenTypes[142].updateContext = (context) => {
        context.push(types.j_expr, types.j_oTag);
      };
    }
    var nonASCIIidentifierStartChars = "\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0560-\u0588\u05D0-\u05EA\u05EF-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u0860-\u086A\u0870-\u0887\u0889-\u088E\u08A0-\u08C9\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u09FC\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C5D\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D04-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E86-\u0E8A\u0E8C-\u0EA3\u0EA5\u0EA7-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u1711\u171F-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1878\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4C\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1C90-\u1CBA\u1CBD-\u1CBF\u1CE9-\u1CEC\u1CEE-\u1CF3\u1CF5\u1CF6\u1CFA\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312F\u3131-\u318E\u31A0-\u31BF\u31F0-\u31FF\u3400-\u4DBF\u4E00-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7CA\uA7D0\uA7D1\uA7D3\uA7D5-\uA7D9\uA7F2-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA8FE\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB69\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC";
    var nonASCIIidentifierChars = "\u200C\u200D\xB7\u0300-\u036F\u0387\u0483-\u0487\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u0669\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u06F0-\u06F9\u0711\u0730-\u074A\u07A6-\u07B0\u07C0-\u07C9\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u0898-\u089F\u08CA-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0966-\u096F\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09E6-\u09EF\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A66-\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AE6-\u0AEF\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B55-\u0B57\u0B62\u0B63\u0B66-\u0B6F\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0BE6-\u0BEF\u0C00-\u0C04\u0C3C\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0CE6-\u0CEF\u0CF3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D66-\u0D6F\u0D81-\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0E50-\u0E59\u0EB1\u0EB4-\u0EBC\u0EC8-\u0ECE\u0ED0-\u0ED9\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1040-\u1049\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F-\u109D\u135D-\u135F\u1369-\u1371\u1712-\u1715\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u17E0-\u17E9\u180B-\u180D\u180F-\u1819\u18A9\u1920-\u192B\u1930-\u193B\u1946-\u194F\u19D0-\u19DA\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AB0-\u1ABD\u1ABF-\u1ACE\u1B00-\u1B04\u1B34-\u1B44\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BB0-\u1BB9\u1BE6-\u1BF3\u1C24-\u1C37\u1C40-\u1C49\u1C50-\u1C59\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DFF\u200C\u200D\u203F\u2040\u2054\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\u30FB\uA620-\uA629\uA66F\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA82C\uA880\uA881\uA8B4-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F1\uA8FF-\uA909\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9D0-\uA9D9\uA9E5\uA9F0-\uA9F9\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA50-\uAA59\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uABF0-\uABF9\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFF10-\uFF19\uFF3F\uFF65";
    var nonASCIIidentifierStart = new RegExp("[" + nonASCIIidentifierStartChars + "]");
    var nonASCIIidentifier = new RegExp("[" + nonASCIIidentifierStartChars + nonASCIIidentifierChars + "]");
    nonASCIIidentifierStartChars = nonASCIIidentifierChars = null;
    var astralIdentifierStartCodes = [0, 11, 2, 25, 2, 18, 2, 1, 2, 14, 3, 13, 35, 122, 70, 52, 268, 28, 4, 48, 48, 31, 14, 29, 6, 37, 11, 29, 3, 35, 5, 7, 2, 4, 43, 157, 19, 35, 5, 35, 5, 39, 9, 51, 13, 10, 2, 14, 2, 6, 2, 1, 2, 10, 2, 14, 2, 6, 2, 1, 68, 310, 10, 21, 11, 7, 25, 5, 2, 41, 2, 8, 70, 5, 3, 0, 2, 43, 2, 1, 4, 0, 3, 22, 11, 22, 10, 30, 66, 18, 2, 1, 11, 21, 11, 25, 71, 55, 7, 1, 65, 0, 16, 3, 2, 2, 2, 28, 43, 28, 4, 28, 36, 7, 2, 27, 28, 53, 11, 21, 11, 18, 14, 17, 111, 72, 56, 50, 14, 50, 14, 35, 349, 41, 7, 1, 79, 28, 11, 0, 9, 21, 43, 17, 47, 20, 28, 22, 13, 52, 58, 1, 3, 0, 14, 44, 33, 24, 27, 35, 30, 0, 3, 0, 9, 34, 4, 0, 13, 47, 15, 3, 22, 0, 2, 0, 36, 17, 2, 24, 20, 1, 64, 6, 2, 0, 2, 3, 2, 14, 2, 9, 8, 46, 39, 7, 3, 1, 3, 21, 2, 6, 2, 1, 2, 4, 4, 0, 19, 0, 13, 4, 159, 52, 19, 3, 21, 2, 31, 47, 21, 1, 2, 0, 185, 46, 42, 3, 37, 47, 21, 0, 60, 42, 14, 0, 72, 26, 38, 6, 186, 43, 117, 63, 32, 7, 3, 0, 3, 7, 2, 1, 2, 23, 16, 0, 2, 0, 95, 7, 3, 38, 17, 0, 2, 0, 29, 0, 11, 39, 8, 0, 22, 0, 12, 45, 20, 0, 19, 72, 264, 8, 2, 36, 18, 0, 50, 29, 113, 6, 2, 1, 2, 37, 22, 0, 26, 5, 2, 1, 2, 31, 15, 0, 328, 18, 16, 0, 2, 12, 2, 33, 125, 0, 80, 921, 103, 110, 18, 195, 2637, 96, 16, 1071, 18, 5, 4026, 582, 8634, 568, 8, 30, 18, 78, 18, 29, 19, 47, 17, 3, 32, 20, 6, 18, 689, 63, 129, 74, 6, 0, 67, 12, 65, 1, 2, 0, 29, 6135, 9, 1237, 43, 8, 8936, 3, 2, 6, 2, 1, 2, 290, 16, 0, 30, 2, 3, 0, 15, 3, 9, 395, 2309, 106, 6, 12, 4, 8, 8, 9, 5991, 84, 2, 70, 2, 1, 3, 0, 3, 1, 3, 3, 2, 11, 2, 0, 2, 6, 2, 64, 2, 3, 3, 7, 2, 6, 2, 27, 2, 3, 2, 4, 2, 0, 4, 6, 2, 339, 3, 24, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 30, 2, 24, 2, 7, 1845, 30, 7, 5, 262, 61, 147, 44, 11, 6, 17, 0, 322, 29, 19, 43, 485, 27, 757, 6, 2, 3, 2, 1, 2, 14, 2, 196, 60, 67, 8, 0, 1205, 3, 2, 26, 2, 1, 2, 0, 3, 0, 2, 9, 2, 3, 2, 0, 2, 0, 7, 0, 5, 0, 2, 0, 2, 0, 2, 2, 2, 1, 2, 0, 3, 0, 2, 0, 2, 0, 2, 0, 2, 0, 2, 1, 2, 0, 3, 3, 2, 6, 2, 3, 2, 3, 2, 0, 2, 9, 2, 16, 6, 2, 2, 4, 2, 16, 4421, 42719, 33, 4153, 7, 221, 3, 5761, 15, 7472, 16, 621, 2467, 541, 1507, 4938, 6, 4191];
    var astralIdentifierCodes = [509, 0, 227, 0, 150, 4, 294, 9, 1368, 2, 2, 1, 6, 3, 41, 2, 5, 0, 166, 1, 574, 3, 9, 9, 370, 1, 81, 2, 71, 10, 50, 3, 123, 2, 54, 14, 32, 10, 3, 1, 11, 3, 46, 10, 8, 0, 46, 9, 7, 2, 37, 13, 2, 9, 6, 1, 45, 0, 13, 2, 49, 13, 9, 3, 2, 11, 83, 11, 7, 0, 3, 0, 158, 11, 6, 9, 7, 3, 56, 1, 2, 6, 3, 1, 3, 2, 10, 0, 11, 1, 3, 6, 4, 4, 193, 17, 10, 9, 5, 0, 82, 19, 13, 9, 214, 6, 3, 8, 28, 1, 83, 16, 16, 9, 82, 12, 9, 9, 84, 14, 5, 9, 243, 14, 166, 9, 71, 5, 2, 1, 3, 3, 2, 0, 2, 1, 13, 9, 120, 6, 3, 6, 4, 0, 29, 9, 41, 6, 2, 3, 9, 0, 10, 10, 47, 15, 406, 7, 2, 7, 17, 9, 57, 21, 2, 13, 123, 5, 4, 0, 2, 1, 2, 6, 2, 0, 9, 9, 49, 4, 2, 1, 2, 4, 9, 9, 330, 3, 10, 1, 2, 0, 49, 6, 4, 4, 14, 9, 5351, 0, 7, 14, 13835, 9, 87, 9, 39, 4, 60, 6, 26, 9, 1014, 0, 2, 54, 8, 3, 82, 0, 12, 1, 19628, 1, 4706, 45, 3, 22, 543, 4, 4, 5, 9, 7, 3, 6, 31, 3, 149, 2, 1418, 49, 513, 54, 5, 49, 9, 0, 15, 0, 23, 4, 2, 14, 1361, 6, 2, 16, 3, 6, 2, 1, 2, 4, 101, 0, 161, 6, 10, 9, 357, 0, 62, 13, 499, 13, 983, 6, 110, 6, 6, 9, 4759, 9, 787719, 239];
    function isInAstralSet(code2, set) {
      let pos = 65536;
      for (let i = 0, length = set.length; i < length; i += 2) {
        pos += set[i];
        if (pos > code2) return false;
        pos += set[i + 1];
        if (pos >= code2) return true;
      }
      return false;
    }
    function isIdentifierStart(code2) {
      if (code2 < 65) return code2 === 36;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifierStart.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes);
    }
    function isIdentifierChar(code2) {
      if (code2 < 48) return code2 === 36;
      if (code2 < 58) return true;
      if (code2 < 65) return false;
      if (code2 <= 90) return true;
      if (code2 < 97) return code2 === 95;
      if (code2 <= 122) return true;
      if (code2 <= 65535) {
        return code2 >= 170 && nonASCIIidentifier.test(String.fromCharCode(code2));
      }
      return isInAstralSet(code2, astralIdentifierStartCodes) || isInAstralSet(code2, astralIdentifierCodes);
    }
    var reservedWords = {
      keyword: ["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete"],
      strict: ["implements", "interface", "let", "package", "private", "protected", "public", "static", "yield"],
      strictBind: ["eval", "arguments"]
    };
    var keywords = new Set(reservedWords.keyword);
    var reservedWordsStrictSet = new Set(reservedWords.strict);
    var reservedWordsStrictBindSet = new Set(reservedWords.strictBind);
    function isReservedWord(word, inModule) {
      return inModule && word === "await" || word === "enum";
    }
    function isStrictReservedWord(word, inModule) {
      return isReservedWord(word, inModule) || reservedWordsStrictSet.has(word);
    }
    function isStrictBindOnlyReservedWord(word) {
      return reservedWordsStrictBindSet.has(word);
    }
    function isStrictBindReservedWord(word, inModule) {
      return isStrictReservedWord(word, inModule) || isStrictBindOnlyReservedWord(word);
    }
    function isKeyword(word) {
      return keywords.has(word);
    }
    function isIteratorStart(current, next, next2) {
      return current === 64 && next === 64 && isIdentifierStart(next2);
    }
    var reservedWordLikeSet = /* @__PURE__ */ new Set(["break", "case", "catch", "continue", "debugger", "default", "do", "else", "finally", "for", "function", "if", "return", "switch", "throw", "try", "var", "const", "while", "with", "new", "this", "super", "class", "extends", "export", "import", "null", "true", "false", "in", "instanceof", "typeof", "void", "delete", "implements", "interface", "let", "package", "private", "protected", "public", "static", "yield", "eval", "arguments", "enum", "await"]);
    function canBeReservedWord(word) {
      return reservedWordLikeSet.has(word);
    }
    var Scope = class {
      constructor(flags) {
        this.flags = 0;
        this.names = /* @__PURE__ */ new Map();
        this.firstLexicalName = "";
        this.flags = flags;
      }
    };
    var ScopeHandler = class {
      constructor(parser, inModule) {
        this.parser = void 0;
        this.scopeStack = [];
        this.inModule = void 0;
        this.undefinedExports = /* @__PURE__ */ new Map();
        this.parser = parser;
        this.inModule = inModule;
      }
      get inTopLevel() {
        return (this.currentScope().flags & 1) > 0;
      }
      get inFunction() {
        return (this.currentVarScopeFlags() & 2) > 0;
      }
      get allowSuper() {
        return (this.currentThisScopeFlags() & 16) > 0;
      }
      get allowDirectSuper() {
        return (this.currentThisScopeFlags() & 32) > 0;
      }
      get inClass() {
        return (this.currentThisScopeFlags() & 64) > 0;
      }
      get inClassAndNotInNonArrowFunction() {
        const flags = this.currentThisScopeFlags();
        return (flags & 64) > 0 && (flags & 2) === 0;
      }
      get inStaticBlock() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 128) {
            return true;
          }
          if (flags & (387 | 64)) {
            return false;
          }
        }
      }
      get inNonArrowFunction() {
        return (this.currentThisScopeFlags() & 2) > 0;
      }
      get treatFunctionsAsVar() {
        return this.treatFunctionsAsVarInScope(this.currentScope());
      }
      createScope(flags) {
        return new Scope(flags);
      }
      enter(flags) {
        this.scopeStack.push(this.createScope(flags));
      }
      exit() {
        const scope = this.scopeStack.pop();
        return scope.flags;
      }
      treatFunctionsAsVarInScope(scope) {
        return !!(scope.flags & (2 | 128) || !this.parser.inModule && scope.flags & 1);
      }
      declareName(name, bindingType, loc) {
        let scope = this.currentScope();
        if (bindingType & 8 || bindingType & 16) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          let type = scope.names.get(name) || 0;
          if (bindingType & 16) {
            type = type | 4;
          } else {
            if (!scope.firstLexicalName) {
              scope.firstLexicalName = name;
            }
            type = type | 2;
          }
          scope.names.set(name, type);
          if (bindingType & 8) {
            this.maybeExportDefined(scope, name);
          }
        } else if (bindingType & 4) {
          for (let i = this.scopeStack.length - 1; i >= 0; --i) {
            scope = this.scopeStack[i];
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            scope.names.set(name, (scope.names.get(name) || 0) | 1);
            this.maybeExportDefined(scope, name);
            if (scope.flags & 387) break;
          }
        }
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name);
        }
      }
      maybeExportDefined(scope, name) {
        if (this.parser.inModule && scope.flags & 1) {
          this.undefinedExports.delete(name);
        }
      }
      checkRedeclarationInScope(scope, name, bindingType, loc) {
        if (this.isRedeclaredInScope(scope, name, bindingType)) {
          this.parser.raise(Errors.VarRedeclaration, loc, {
            identifierName: name
          });
        }
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (!(bindingType & 1)) return false;
        if (bindingType & 8) {
          return scope.names.has(name);
        }
        const type = scope.names.get(name);
        if (bindingType & 16) {
          return (type & 2) > 0 || !this.treatFunctionsAsVarInScope(scope) && (type & 1) > 0;
        }
        return (type & 2) > 0 && !(scope.flags & 8 && scope.firstLexicalName === name) || !this.treatFunctionsAsVarInScope(scope) && (type & 4) > 0;
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        const topLevelScope = this.scopeStack[0];
        if (!topLevelScope.names.has(name)) {
          this.undefinedExports.set(name, id.loc.start);
        }
      }
      currentScope() {
        return this.scopeStack[this.scopeStack.length - 1];
      }
      currentVarScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & 387) {
            return flags;
          }
        }
      }
      currentThisScopeFlags() {
        for (let i = this.scopeStack.length - 1; ; i--) {
          const {
            flags
          } = this.scopeStack[i];
          if (flags & (387 | 64) && !(flags & 4)) {
            return flags;
          }
        }
      }
    };
    var FlowScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.declareFunctions = /* @__PURE__ */ new Set();
      }
    };
    var FlowScopeHandler = class extends ScopeHandler {
      createScope(flags) {
        return new FlowScope(flags);
      }
      declareName(name, bindingType, loc) {
        const scope = this.currentScope();
        if (bindingType & 2048) {
          this.checkRedeclarationInScope(scope, name, bindingType, loc);
          this.maybeExportDefined(scope, name);
          scope.declareFunctions.add(name);
          return;
        }
        super.declareName(name, bindingType, loc);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        if (super.isRedeclaredInScope(scope, name, bindingType)) return true;
        if (bindingType & 2048 && !scope.declareFunctions.has(name)) {
          const type = scope.names.get(name);
          return (type & 4) > 0 || (type & 2) > 0;
        }
        return false;
      }
      checkLocalExport(id) {
        if (!this.scopeStack[0].declareFunctions.has(id.name)) {
          super.checkLocalExport(id);
        }
      }
    };
    var BaseParser = class {
      constructor() {
        this.sawUnambiguousESM = false;
        this.ambiguousScriptDifferentAst = false;
      }
      hasPlugin(pluginConfig) {
        if (typeof pluginConfig === "string") {
          return this.plugins.has(pluginConfig);
        } else {
          const [pluginName, pluginOptions] = pluginConfig;
          if (!this.hasPlugin(pluginName)) {
            return false;
          }
          const actualOptions = this.plugins.get(pluginName);
          for (const key of Object.keys(pluginOptions)) {
            if ((actualOptions == null ? void 0 : actualOptions[key]) !== pluginOptions[key]) {
              return false;
            }
          }
          return true;
        }
      }
      getPluginOption(plugin, name) {
        var _this$plugins$get;
        return (_this$plugins$get = this.plugins.get(plugin)) == null ? void 0 : _this$plugins$get[name];
      }
    };
    function setTrailingComments(node, comments) {
      if (node.trailingComments === void 0) {
        node.trailingComments = comments;
      } else {
        node.trailingComments.unshift(...comments);
      }
    }
    function setLeadingComments(node, comments) {
      if (node.leadingComments === void 0) {
        node.leadingComments = comments;
      } else {
        node.leadingComments.unshift(...comments);
      }
    }
    function setInnerComments(node, comments) {
      if (node.innerComments === void 0) {
        node.innerComments = comments;
      } else {
        node.innerComments.unshift(...comments);
      }
    }
    function adjustInnerComments(node, elements, commentWS) {
      let lastElement = null;
      let i = elements.length;
      while (lastElement === null && i > 0) {
        lastElement = elements[--i];
      }
      if (lastElement === null || lastElement.start > commentWS.start) {
        setInnerComments(node, commentWS.comments);
      } else {
        setTrailingComments(lastElement, commentWS.comments);
      }
    }
    var CommentsParser = class extends BaseParser {
      addComment(comment) {
        if (this.filename) comment.loc.filename = this.filename;
        const {
          commentsLen
        } = this.state;
        if (this.comments.length !== commentsLen) {
          this.comments.length = commentsLen;
        }
        this.comments.push(comment);
        this.state.commentsLen++;
      }
      processComment(node) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        const lastCommentWS = commentStack[i];
        if (lastCommentWS.start === node.end) {
          lastCommentWS.leadingNode = node;
          i--;
        }
        const {
          start: nodeStart
        } = node;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          if (commentEnd > nodeStart) {
            commentWS.containingNode = node;
            this.finalizeComment(commentWS);
            commentStack.splice(i, 1);
          } else {
            if (commentEnd === nodeStart) {
              commentWS.trailingNode = node;
            }
            break;
          }
        }
      }
      finalizeComment(commentWS) {
        const {
          comments
        } = commentWS;
        if (commentWS.leadingNode !== null || commentWS.trailingNode !== null) {
          if (commentWS.leadingNode !== null) {
            setTrailingComments(commentWS.leadingNode, comments);
          }
          if (commentWS.trailingNode !== null) {
            setLeadingComments(commentWS.trailingNode, comments);
          }
        } else {
          const {
            containingNode: node,
            start: commentStart
          } = commentWS;
          if (this.input.charCodeAt(commentStart - 1) === 44) {
            switch (node.type) {
              case "ObjectExpression":
              case "ObjectPattern":
              case "RecordExpression":
                adjustInnerComments(node, node.properties, commentWS);
                break;
              case "CallExpression":
              case "OptionalCallExpression":
                adjustInnerComments(node, node.arguments, commentWS);
                break;
              case "FunctionDeclaration":
              case "FunctionExpression":
              case "ArrowFunctionExpression":
              case "ObjectMethod":
              case "ClassMethod":
              case "ClassPrivateMethod":
                adjustInnerComments(node, node.params, commentWS);
                break;
              case "ArrayExpression":
              case "ArrayPattern":
              case "TupleExpression":
                adjustInnerComments(node, node.elements, commentWS);
                break;
              case "ExportNamedDeclaration":
              case "ImportDeclaration":
                adjustInnerComments(node, node.specifiers, commentWS);
                break;
              default: {
                setInnerComments(node, comments);
              }
            }
          } else {
            setInnerComments(node, comments);
          }
        }
      }
      finalizeRemainingComments() {
        const {
          commentStack
        } = this.state;
        for (let i = commentStack.length - 1; i >= 0; i--) {
          this.finalizeComment(commentStack[i]);
        }
        this.state.commentStack = [];
      }
      resetPreviousNodeTrailingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0) return;
        const commentWS = commentStack[length - 1];
        if (commentWS.leadingNode === node) {
          commentWS.leadingNode = null;
        }
      }
      resetPreviousIdentifierLeadingComments(node) {
        const {
          commentStack
        } = this.state;
        const {
          length
        } = commentStack;
        if (length === 0) return;
        if (commentStack[length - 1].trailingNode === node) {
          commentStack[length - 1].trailingNode = null;
        } else if (length >= 2 && commentStack[length - 2].trailingNode === node) {
          commentStack[length - 2].trailingNode = null;
        }
      }
      takeSurroundingComments(node, start, end) {
        const {
          commentStack
        } = this.state;
        const commentStackLength = commentStack.length;
        if (commentStackLength === 0) return;
        let i = commentStackLength - 1;
        for (; i >= 0; i--) {
          const commentWS = commentStack[i];
          const commentEnd = commentWS.end;
          const commentStart = commentWS.start;
          if (commentStart === end) {
            commentWS.leadingNode = node;
          } else if (commentEnd === start) {
            commentWS.trailingNode = node;
          } else if (commentEnd < start) {
            break;
          }
        }
      }
    };
    var lineBreak = /\r\n?|[\n\u2028\u2029]/;
    var lineBreakG = new RegExp(lineBreak.source, "g");
    function isNewLine(code2) {
      switch (code2) {
        case 10:
        case 13:
        case 8232:
        case 8233:
          return true;
        default:
          return false;
      }
    }
    var skipWhiteSpace = /(?:\s|\/\/.*|\/\*[^]*?\*\/)*/g;
    var skipWhiteSpaceInLine = /(?:[^\S\n\r\u2028\u2029]|\/\/.*|\/\*.*?\*\/)*/g;
    var skipWhiteSpaceToLineBreak = new RegExp("(?=(" + skipWhiteSpaceInLine.source + "))\\1" + /(?=[\n\r\u2028\u2029]|\/\*(?!.*?\*\/)|$)/.source, "y");
    function isWhitespace(code2) {
      switch (code2) {
        case 9:
        case 11:
        case 12:
        case 32:
        case 160:
        case 5760:
        case 8192:
        case 8193:
        case 8194:
        case 8195:
        case 8196:
        case 8197:
        case 8198:
        case 8199:
        case 8200:
        case 8201:
        case 8202:
        case 8239:
        case 8287:
        case 12288:
        case 65279:
          return true;
        default:
          return false;
      }
    }
    var State = class _State {
      constructor() {
        this.flags = 1024;
        this.curLine = void 0;
        this.lineStart = void 0;
        this.startLoc = void 0;
        this.endLoc = void 0;
        this.errors = [];
        this.potentialArrowAt = -1;
        this.noArrowAt = [];
        this.noArrowParamsConversionAt = [];
        this.topicContext = {
          maxNumOfResolvableTopics: 0,
          maxTopicIndex: null
        };
        this.labels = [];
        this.commentsLen = 0;
        this.commentStack = [];
        this.pos = 0;
        this.type = 139;
        this.value = null;
        this.start = 0;
        this.end = 0;
        this.lastTokEndLoc = null;
        this.lastTokStartLoc = null;
        this.context = [types.brace];
        this.firstInvalidTemplateEscapePos = null;
        this.strictErrors = /* @__PURE__ */ new Map();
        this.tokensLength = 0;
      }
      get strict() {
        return (this.flags & 1) > 0;
      }
      set strict(v) {
        if (v) this.flags |= 1;
        else this.flags &= -2;
      }
      init({
        strictMode,
        sourceType,
        startLine,
        startColumn
      }) {
        this.strict = strictMode === false ? false : strictMode === true ? true : sourceType === "module";
        this.curLine = startLine;
        this.lineStart = -startColumn;
        this.startLoc = this.endLoc = new Position(startLine, startColumn, 0);
      }
      get maybeInArrowParameters() {
        return (this.flags & 2) > 0;
      }
      set maybeInArrowParameters(v) {
        if (v) this.flags |= 2;
        else this.flags &= -3;
      }
      get inType() {
        return (this.flags & 4) > 0;
      }
      set inType(v) {
        if (v) this.flags |= 4;
        else this.flags &= -5;
      }
      get noAnonFunctionType() {
        return (this.flags & 8) > 0;
      }
      set noAnonFunctionType(v) {
        if (v) this.flags |= 8;
        else this.flags &= -9;
      }
      get hasFlowComment() {
        return (this.flags & 16) > 0;
      }
      set hasFlowComment(v) {
        if (v) this.flags |= 16;
        else this.flags &= -17;
      }
      get isAmbientContext() {
        return (this.flags & 32) > 0;
      }
      set isAmbientContext(v) {
        if (v) this.flags |= 32;
        else this.flags &= -33;
      }
      get inAbstractClass() {
        return (this.flags & 64) > 0;
      }
      set inAbstractClass(v) {
        if (v) this.flags |= 64;
        else this.flags &= -65;
      }
      get inDisallowConditionalTypesContext() {
        return (this.flags & 128) > 0;
      }
      set inDisallowConditionalTypesContext(v) {
        if (v) this.flags |= 128;
        else this.flags &= -129;
      }
      get soloAwait() {
        return (this.flags & 256) > 0;
      }
      set soloAwait(v) {
        if (v) this.flags |= 256;
        else this.flags &= -257;
      }
      get inFSharpPipelineDirectBody() {
        return (this.flags & 512) > 0;
      }
      set inFSharpPipelineDirectBody(v) {
        if (v) this.flags |= 512;
        else this.flags &= -513;
      }
      get canStartJSXElement() {
        return (this.flags & 1024) > 0;
      }
      set canStartJSXElement(v) {
        if (v) this.flags |= 1024;
        else this.flags &= -1025;
      }
      get containsEsc() {
        return (this.flags & 2048) > 0;
      }
      set containsEsc(v) {
        if (v) this.flags |= 2048;
        else this.flags &= -2049;
      }
      curPosition() {
        return new Position(this.curLine, this.pos - this.lineStart, this.pos);
      }
      clone() {
        const state = new _State();
        state.flags = this.flags;
        state.curLine = this.curLine;
        state.lineStart = this.lineStart;
        state.startLoc = this.startLoc;
        state.endLoc = this.endLoc;
        state.errors = this.errors.slice();
        state.potentialArrowAt = this.potentialArrowAt;
        state.noArrowAt = this.noArrowAt.slice();
        state.noArrowParamsConversionAt = this.noArrowParamsConversionAt.slice();
        state.topicContext = this.topicContext;
        state.labels = this.labels.slice();
        state.commentsLen = this.commentsLen;
        state.commentStack = this.commentStack.slice();
        state.pos = this.pos;
        state.type = this.type;
        state.value = this.value;
        state.start = this.start;
        state.end = this.end;
        state.lastTokEndLoc = this.lastTokEndLoc;
        state.lastTokStartLoc = this.lastTokStartLoc;
        state.context = this.context.slice();
        state.firstInvalidTemplateEscapePos = this.firstInvalidTemplateEscapePos;
        state.strictErrors = this.strictErrors;
        state.tokensLength = this.tokensLength;
        return state;
      }
    };
    var _isDigit = function isDigit(code2) {
      return code2 >= 48 && code2 <= 57;
    };
    var forbiddenNumericSeparatorSiblings = {
      decBinOct: /* @__PURE__ */ new Set([46, 66, 69, 79, 95, 98, 101, 111]),
      hex: /* @__PURE__ */ new Set([46, 88, 95, 120])
    };
    var isAllowedNumericSeparatorSibling = {
      bin: (ch) => ch === 48 || ch === 49,
      oct: (ch) => ch >= 48 && ch <= 55,
      dec: (ch) => ch >= 48 && ch <= 57,
      hex: (ch) => ch >= 48 && ch <= 57 || ch >= 65 && ch <= 70 || ch >= 97 && ch <= 102
    };
    function readStringContents(type, input, pos, lineStart, curLine, errors) {
      const initialPos = pos;
      const initialLineStart = lineStart;
      const initialCurLine = curLine;
      let out = "";
      let firstInvalidLoc = null;
      let chunkStart = pos;
      const {
        length
      } = input;
      for (; ; ) {
        if (pos >= length) {
          errors.unterminated(initialPos, initialLineStart, initialCurLine);
          out += input.slice(chunkStart, pos);
          break;
        }
        const ch = input.charCodeAt(pos);
        if (isStringEnd(type, ch, input, pos)) {
          out += input.slice(chunkStart, pos);
          break;
        }
        if (ch === 92) {
          out += input.slice(chunkStart, pos);
          const res = readEscapedChar(input, pos, lineStart, curLine, type === "template", errors);
          if (res.ch === null && !firstInvalidLoc) {
            firstInvalidLoc = {
              pos,
              lineStart,
              curLine
            };
          } else {
            out += res.ch;
          }
          ({
            pos,
            lineStart,
            curLine
          } = res);
          chunkStart = pos;
        } else if (ch === 8232 || ch === 8233) {
          ++pos;
          ++curLine;
          lineStart = pos;
        } else if (ch === 10 || ch === 13) {
          if (type === "template") {
            out += input.slice(chunkStart, pos) + "\n";
            ++pos;
            if (ch === 13 && input.charCodeAt(pos) === 10) {
              ++pos;
            }
            ++curLine;
            chunkStart = lineStart = pos;
          } else {
            errors.unterminated(initialPos, initialLineStart, initialCurLine);
          }
        } else {
          ++pos;
        }
      }
      return {
        pos,
        str: out,
        firstInvalidLoc,
        lineStart,
        curLine,
        containsInvalid: !!firstInvalidLoc
      };
    }
    function isStringEnd(type, ch, input, pos) {
      if (type === "template") {
        return ch === 96 || ch === 36 && input.charCodeAt(pos + 1) === 123;
      }
      return ch === (type === "double" ? 34 : 39);
    }
    function readEscapedChar(input, pos, lineStart, curLine, inTemplate, errors) {
      const throwOnInvalid = !inTemplate;
      pos++;
      const res = (ch2) => ({
        pos,
        ch: ch2,
        lineStart,
        curLine
      });
      const ch = input.charCodeAt(pos++);
      switch (ch) {
        case 110:
          return res("\n");
        case 114:
          return res("\r");
        case 120: {
          let code2;
          ({
            code: code2,
            pos
          } = readHexChar(input, pos, lineStart, curLine, 2, false, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCharCode(code2));
        }
        case 117: {
          let code2;
          ({
            code: code2,
            pos
          } = readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors));
          return res(code2 === null ? null : String.fromCodePoint(code2));
        }
        case 116:
          return res("	");
        case 98:
          return res("\b");
        case 118:
          return res("\v");
        case 102:
          return res("\f");
        case 13:
          if (input.charCodeAt(pos) === 10) {
            ++pos;
          }
        case 10:
          lineStart = pos;
          ++curLine;
        case 8232:
        case 8233:
          return res("");
        case 56:
        case 57:
          if (inTemplate) {
            return res(null);
          } else {
            errors.strictNumericEscape(pos - 1, lineStart, curLine);
          }
        default:
          if (ch >= 48 && ch <= 55) {
            const startPos = pos - 1;
            const match = /^[0-7]+/.exec(input.slice(startPos, pos + 2));
            let octalStr = match[0];
            let octal = parseInt(octalStr, 8);
            if (octal > 255) {
              octalStr = octalStr.slice(0, -1);
              octal = parseInt(octalStr, 8);
            }
            pos += octalStr.length - 1;
            const next = input.charCodeAt(pos);
            if (octalStr !== "0" || next === 56 || next === 57) {
              if (inTemplate) {
                return res(null);
              } else {
                errors.strictNumericEscape(startPos, lineStart, curLine);
              }
            }
            return res(String.fromCharCode(octal));
          }
          return res(String.fromCharCode(ch));
      }
    }
    function readHexChar(input, pos, lineStart, curLine, len, forceLen, throwOnInvalid, errors) {
      const initialPos = pos;
      let n;
      ({
        n,
        pos
      } = readInt(input, pos, lineStart, curLine, 16, len, forceLen, false, errors, !throwOnInvalid));
      if (n === null) {
        if (throwOnInvalid) {
          errors.invalidEscapeSequence(initialPos, lineStart, curLine);
        } else {
          pos = initialPos - 1;
        }
      }
      return {
        code: n,
        pos
      };
    }
    function readInt(input, pos, lineStart, curLine, radix, len, forceLen, allowNumSeparator, errors, bailOnError) {
      const start = pos;
      const forbiddenSiblings = radix === 16 ? forbiddenNumericSeparatorSiblings.hex : forbiddenNumericSeparatorSiblings.decBinOct;
      const isAllowedSibling = radix === 16 ? isAllowedNumericSeparatorSibling.hex : radix === 10 ? isAllowedNumericSeparatorSibling.dec : radix === 8 ? isAllowedNumericSeparatorSibling.oct : isAllowedNumericSeparatorSibling.bin;
      let invalid = false;
      let total = 0;
      for (let i = 0, e = len == null ? Infinity : len; i < e; ++i) {
        const code2 = input.charCodeAt(pos);
        let val;
        if (code2 === 95 && allowNumSeparator !== "bail") {
          const prev = input.charCodeAt(pos - 1);
          const next = input.charCodeAt(pos + 1);
          if (!allowNumSeparator) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.numericSeparatorInEscapeSequence(pos, lineStart, curLine);
          } else if (Number.isNaN(next) || !isAllowedSibling(next) || forbiddenSiblings.has(prev) || forbiddenSiblings.has(next)) {
            if (bailOnError) return {
              n: null,
              pos
            };
            errors.unexpectedNumericSeparator(pos, lineStart, curLine);
          }
          ++pos;
          continue;
        }
        if (code2 >= 97) {
          val = code2 - 97 + 10;
        } else if (code2 >= 65) {
          val = code2 - 65 + 10;
        } else if (_isDigit(code2)) {
          val = code2 - 48;
        } else {
          val = Infinity;
        }
        if (val >= radix) {
          if (val <= 9 && bailOnError) {
            return {
              n: null,
              pos
            };
          } else if (val <= 9 && errors.invalidDigit(pos, lineStart, curLine, radix)) {
            val = 0;
          } else if (forceLen) {
            val = 0;
            invalid = true;
          } else {
            break;
          }
        }
        ++pos;
        total = total * radix + val;
      }
      if (pos === start || len != null && pos - start !== len || invalid) {
        return {
          n: null,
          pos
        };
      }
      return {
        n: total,
        pos
      };
    }
    function readCodePoint(input, pos, lineStart, curLine, throwOnInvalid, errors) {
      const ch = input.charCodeAt(pos);
      let code2;
      if (ch === 123) {
        ++pos;
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, input.indexOf("}", pos) - pos, true, throwOnInvalid, errors));
        ++pos;
        if (code2 !== null && code2 > 1114111) {
          if (throwOnInvalid) {
            errors.invalidCodePoint(pos, lineStart, curLine);
          } else {
            return {
              code: null,
              pos
            };
          }
        }
      } else {
        ({
          code: code2,
          pos
        } = readHexChar(input, pos, lineStart, curLine, 4, false, throwOnInvalid, errors));
      }
      return {
        code: code2,
        pos
      };
    }
    function buildPosition(pos, lineStart, curLine) {
      return new Position(curLine, pos - lineStart, pos);
    }
    var VALID_REGEX_FLAGS = /* @__PURE__ */ new Set([103, 109, 115, 105, 121, 117, 100, 118]);
    var Token = class {
      constructor(state) {
        this.type = state.type;
        this.value = state.value;
        this.start = state.start;
        this.end = state.end;
        this.loc = new SourceLocation(state.startLoc, state.endLoc);
      }
    };
    var Tokenizer = class extends CommentsParser {
      constructor(options, input) {
        super();
        this.isLookahead = void 0;
        this.tokens = [];
        this.errorHandlers_readInt = {
          invalidDigit: (pos, lineStart, curLine, radix) => {
            if (!this.options.errorRecovery) return false;
            this.raise(Errors.InvalidDigit, buildPosition(pos, lineStart, curLine), {
              radix
            });
            return true;
          },
          numericSeparatorInEscapeSequence: this.errorBuilder(Errors.NumericSeparatorInEscapeSequence),
          unexpectedNumericSeparator: this.errorBuilder(Errors.UnexpectedNumericSeparator)
        };
        this.errorHandlers_readCodePoint = Object.assign({}, this.errorHandlers_readInt, {
          invalidEscapeSequence: this.errorBuilder(Errors.InvalidEscapeSequence),
          invalidCodePoint: this.errorBuilder(Errors.InvalidCodePoint)
        });
        this.errorHandlers_readStringContents_string = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: (pos, lineStart, curLine) => {
            this.recordStrictModeErrors(Errors.StrictNumericEscape, buildPosition(pos, lineStart, curLine));
          },
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedString, buildPosition(pos - 1, lineStart, curLine));
          }
        });
        this.errorHandlers_readStringContents_template = Object.assign({}, this.errorHandlers_readCodePoint, {
          strictNumericEscape: this.errorBuilder(Errors.StrictNumericEscape),
          unterminated: (pos, lineStart, curLine) => {
            throw this.raise(Errors.UnterminatedTemplate, buildPosition(pos, lineStart, curLine));
          }
        });
        this.state = new State();
        this.state.init(options);
        this.input = input;
        this.length = input.length;
        this.comments = [];
        this.isLookahead = false;
      }
      pushToken(token) {
        this.tokens.length = this.state.tokensLength;
        this.tokens.push(token);
        ++this.state.tokensLength;
      }
      next() {
        this.checkKeywordEscapes();
        if (this.options.tokens) {
          this.pushToken(new Token(this.state));
        }
        this.state.lastTokEndLoc = this.state.endLoc;
        this.state.lastTokStartLoc = this.state.startLoc;
        this.nextToken();
      }
      eat(type) {
        if (this.match(type)) {
          this.next();
          return true;
        } else {
          return false;
        }
      }
      match(type) {
        return this.state.type === type;
      }
      createLookaheadState(state) {
        return {
          pos: state.pos,
          value: null,
          type: state.type,
          start: state.start,
          end: state.end,
          context: [this.curContext()],
          inType: state.inType,
          startLoc: state.startLoc,
          lastTokEndLoc: state.lastTokEndLoc,
          curLine: state.curLine,
          lineStart: state.lineStart,
          curPosition: state.curPosition
        };
      }
      lookahead() {
        const old = this.state;
        this.state = this.createLookaheadState(old);
        this.isLookahead = true;
        this.nextToken();
        this.isLookahead = false;
        const curr = this.state;
        this.state = old;
        return curr;
      }
      nextTokenStart() {
        return this.nextTokenStartSince(this.state.pos);
      }
      nextTokenStartSince(pos) {
        skipWhiteSpace.lastIndex = pos;
        return skipWhiteSpace.test(this.input) ? skipWhiteSpace.lastIndex : pos;
      }
      lookaheadCharCode() {
        return this.input.charCodeAt(this.nextTokenStart());
      }
      nextTokenInLineStart() {
        return this.nextTokenInLineStartSince(this.state.pos);
      }
      nextTokenInLineStartSince(pos) {
        skipWhiteSpaceInLine.lastIndex = pos;
        return skipWhiteSpaceInLine.test(this.input) ? skipWhiteSpaceInLine.lastIndex : pos;
      }
      lookaheadInLineCharCode() {
        return this.input.charCodeAt(this.nextTokenInLineStart());
      }
      codePointAtPos(pos) {
        let cp = this.input.charCodeAt(pos);
        if ((cp & 64512) === 55296 && ++pos < this.input.length) {
          const trail = this.input.charCodeAt(pos);
          if ((trail & 64512) === 56320) {
            cp = 65536 + ((cp & 1023) << 10) + (trail & 1023);
          }
        }
        return cp;
      }
      setStrict(strict) {
        this.state.strict = strict;
        if (strict) {
          this.state.strictErrors.forEach(([toParseError, at]) => this.raise(toParseError, at));
          this.state.strictErrors.clear();
        }
      }
      curContext() {
        return this.state.context[this.state.context.length - 1];
      }
      nextToken() {
        this.skipSpace();
        this.state.start = this.state.pos;
        if (!this.isLookahead) this.state.startLoc = this.state.curPosition();
        if (this.state.pos >= this.length) {
          this.finishToken(139);
          return;
        }
        this.getTokenFromCode(this.codePointAtPos(this.state.pos));
      }
      skipBlockComment(commentEnd) {
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        const start = this.state.pos;
        const end = this.input.indexOf(commentEnd, start + 2);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
        this.state.pos = end + commentEnd.length;
        lineBreakG.lastIndex = start + 2;
        while (lineBreakG.test(this.input) && lineBreakG.lastIndex <= end) {
          ++this.state.curLine;
          this.state.lineStart = lineBreakG.lastIndex;
        }
        if (this.isLookahead) return;
        const comment = {
          type: "CommentBlock",
          value: this.input.slice(start + 2, end),
          start,
          end: end + commentEnd.length,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens) this.pushToken(comment);
        return comment;
      }
      skipLineComment(startSkip) {
        const start = this.state.pos;
        let startLoc;
        if (!this.isLookahead) startLoc = this.state.curPosition();
        let ch = this.input.charCodeAt(this.state.pos += startSkip);
        if (this.state.pos < this.length) {
          while (!isNewLine(ch) && ++this.state.pos < this.length) {
            ch = this.input.charCodeAt(this.state.pos);
          }
        }
        if (this.isLookahead) return;
        const end = this.state.pos;
        const value = this.input.slice(start + startSkip, end);
        const comment = {
          type: "CommentLine",
          value,
          start,
          end,
          loc: new SourceLocation(startLoc, this.state.curPosition())
        };
        if (this.options.tokens) this.pushToken(comment);
        return comment;
      }
      skipSpace() {
        const spaceStart = this.state.pos;
        const comments = [];
        loop: while (this.state.pos < this.length) {
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 32:
            case 160:
            case 9:
              ++this.state.pos;
              break;
            case 13:
              if (this.input.charCodeAt(this.state.pos + 1) === 10) {
                ++this.state.pos;
              }
            case 10:
            case 8232:
            case 8233:
              ++this.state.pos;
              ++this.state.curLine;
              this.state.lineStart = this.state.pos;
              break;
            case 47:
              switch (this.input.charCodeAt(this.state.pos + 1)) {
                case 42: {
                  const comment = this.skipBlockComment("*/");
                  if (comment !== void 0) {
                    this.addComment(comment);
                    if (this.options.attachComment) comments.push(comment);
                  }
                  break;
                }
                case 47: {
                  const comment = this.skipLineComment(2);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    if (this.options.attachComment) comments.push(comment);
                  }
                  break;
                }
                default:
                  break loop;
              }
              break;
            default:
              if (isWhitespace(ch)) {
                ++this.state.pos;
              } else if (ch === 45 && !this.inModule && this.options.annexB) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 45 && this.input.charCodeAt(pos + 2) === 62 && (spaceStart === 0 || this.state.lineStart > spaceStart)) {
                  const comment = this.skipLineComment(3);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    if (this.options.attachComment) comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else if (ch === 60 && !this.inModule && this.options.annexB) {
                const pos = this.state.pos;
                if (this.input.charCodeAt(pos + 1) === 33 && this.input.charCodeAt(pos + 2) === 45 && this.input.charCodeAt(pos + 3) === 45) {
                  const comment = this.skipLineComment(4);
                  if (comment !== void 0) {
                    this.addComment(comment);
                    if (this.options.attachComment) comments.push(comment);
                  }
                } else {
                  break loop;
                }
              } else {
                break loop;
              }
          }
        }
        if (comments.length > 0) {
          const end = this.state.pos;
          const commentWhitespace = {
            start: spaceStart,
            end,
            comments,
            leadingNode: null,
            trailingNode: null,
            containingNode: null
          };
          this.state.commentStack.push(commentWhitespace);
        }
      }
      finishToken(type, val) {
        this.state.end = this.state.pos;
        this.state.endLoc = this.state.curPosition();
        const prevType = this.state.type;
        this.state.type = type;
        this.state.value = val;
        if (!this.isLookahead) {
          this.updateContext(prevType);
        }
      }
      replaceToken(type) {
        this.state.type = type;
        this.updateContext();
      }
      readToken_numberSign() {
        if (this.state.pos === 0 && this.readToken_interpreter()) {
          return;
        }
        const nextPos = this.state.pos + 1;
        const next = this.codePointAtPos(nextPos);
        if (next >= 48 && next <= 57) {
          throw this.raise(Errors.UnexpectedDigitAfterHash, this.state.curPosition());
        }
        if (next === 123 || next === 91 && this.hasPlugin("recordAndTuple")) {
          this.expectPlugin("recordAndTuple");
          if (this.getPluginOption("recordAndTuple", "syntaxType") === "bar") {
            throw this.raise(next === 123 ? Errors.RecordExpressionHashIncorrectStartSyntaxType : Errors.TupleExpressionHashIncorrectStartSyntaxType, this.state.curPosition());
          }
          this.state.pos += 2;
          if (next === 123) {
            this.finishToken(7);
          } else {
            this.finishToken(1);
          }
        } else if (isIdentifierStart(next)) {
          ++this.state.pos;
          this.finishToken(138, this.readWord1(next));
        } else if (next === 92) {
          ++this.state.pos;
          this.finishToken(138, this.readWord1());
        } else {
          this.finishOp(27, 1);
        }
      }
      readToken_dot() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next >= 48 && next <= 57) {
          this.readNumber(true);
          return;
        }
        if (next === 46 && this.input.charCodeAt(this.state.pos + 2) === 46) {
          this.state.pos += 3;
          this.finishToken(21);
        } else {
          ++this.state.pos;
          this.finishToken(16);
        }
      }
      readToken_slash() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(31, 2);
        } else {
          this.finishOp(56, 1);
        }
      }
      readToken_interpreter() {
        if (this.state.pos !== 0 || this.length < 2) return false;
        let ch = this.input.charCodeAt(this.state.pos + 1);
        if (ch !== 33) return false;
        const start = this.state.pos;
        this.state.pos += 1;
        while (!isNewLine(ch) && ++this.state.pos < this.length) {
          ch = this.input.charCodeAt(this.state.pos);
        }
        const value = this.input.slice(start + 2, this.state.pos);
        this.finishToken(28, value);
        return true;
      }
      readToken_mult_modulo(code2) {
        let type = code2 === 42 ? 55 : 54;
        let width = 1;
        let next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 42) {
          width++;
          next = this.input.charCodeAt(this.state.pos + 2);
          type = 57;
        }
        if (next === 61 && !this.state.inType) {
          width++;
          type = code2 === 37 ? 33 : 30;
        }
        this.finishOp(type, width);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          if (this.input.charCodeAt(this.state.pos + 2) === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(code2 === 124 ? 41 : 42, 2);
          }
          return;
        }
        if (code2 === 124) {
          if (next === 62) {
            this.finishOp(39, 2);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 125) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.RecordExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(9);
            return;
          }
          if (this.hasPlugin("recordAndTuple") && next === 93) {
            if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
              throw this.raise(Errors.TupleExpressionBarIncorrectEndSyntaxType, this.state.curPosition());
            }
            this.state.pos += 2;
            this.finishToken(4);
            return;
          }
        }
        if (next === 61) {
          this.finishOp(30, 2);
          return;
        }
        this.finishOp(code2 === 124 ? 43 : 45, 1);
      }
      readToken_caret() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61 && !this.state.inType) {
          this.finishOp(32, 2);
        } else if (next === 94 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "^^"
        }])) {
          this.finishOp(37, 2);
          const lookaheadCh = this.input.codePointAt(this.state.pos);
          if (lookaheadCh === 94) {
            this.unexpected();
          }
        } else {
          this.finishOp(44, 1);
        }
      }
      readToken_atSign() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 64 && this.hasPlugin(["pipelineOperator", {
          proposal: "hack",
          topicToken: "@@"
        }])) {
          this.finishOp(38, 2);
        } else {
          this.finishOp(26, 1);
        }
      }
      readToken_plus_min(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === code2) {
          this.finishOp(34, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(30, 2);
        } else {
          this.finishOp(53, 1);
        }
      }
      readToken_lt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 60) {
          if (this.input.charCodeAt(pos + 2) === 61) {
            this.finishOp(30, 3);
            return;
          }
          this.finishOp(51, 2);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(47, 1);
      }
      readToken_gt() {
        const {
          pos
        } = this.state;
        const next = this.input.charCodeAt(pos + 1);
        if (next === 62) {
          const size = this.input.charCodeAt(pos + 2) === 62 ? 3 : 2;
          if (this.input.charCodeAt(pos + size) === 61) {
            this.finishOp(30, size + 1);
            return;
          }
          this.finishOp(52, size);
          return;
        }
        if (next === 61) {
          this.finishOp(49, 2);
          return;
        }
        this.finishOp(48, 1);
      }
      readToken_eq_excl(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (next === 61) {
          this.finishOp(46, this.input.charCodeAt(this.state.pos + 2) === 61 ? 3 : 2);
          return;
        }
        if (code2 === 61 && next === 62) {
          this.state.pos += 2;
          this.finishToken(19);
          return;
        }
        this.finishOp(code2 === 61 ? 29 : 35, 1);
      }
      readToken_question() {
        const next = this.input.charCodeAt(this.state.pos + 1);
        const next2 = this.input.charCodeAt(this.state.pos + 2);
        if (next === 63) {
          if (next2 === 61) {
            this.finishOp(30, 3);
          } else {
            this.finishOp(40, 2);
          }
        } else if (next === 46 && !(next2 >= 48 && next2 <= 57)) {
          this.state.pos += 2;
          this.finishToken(18);
        } else {
          ++this.state.pos;
          this.finishToken(17);
        }
      }
      getTokenFromCode(code2) {
        switch (code2) {
          case 46:
            this.readToken_dot();
            return;
          case 40:
            ++this.state.pos;
            this.finishToken(10);
            return;
          case 41:
            ++this.state.pos;
            this.finishToken(11);
            return;
          case 59:
            ++this.state.pos;
            this.finishToken(13);
            return;
          case 44:
            ++this.state.pos;
            this.finishToken(12);
            return;
          case 91:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.TupleExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(2);
            } else {
              ++this.state.pos;
              this.finishToken(0);
            }
            return;
          case 93:
            ++this.state.pos;
            this.finishToken(3);
            return;
          case 123:
            if (this.hasPlugin("recordAndTuple") && this.input.charCodeAt(this.state.pos + 1) === 124) {
              if (this.getPluginOption("recordAndTuple", "syntaxType") !== "bar") {
                throw this.raise(Errors.RecordExpressionBarIncorrectStartSyntaxType, this.state.curPosition());
              }
              this.state.pos += 2;
              this.finishToken(6);
            } else {
              ++this.state.pos;
              this.finishToken(5);
            }
            return;
          case 125:
            ++this.state.pos;
            this.finishToken(8);
            return;
          case 58:
            if (this.hasPlugin("functionBind") && this.input.charCodeAt(this.state.pos + 1) === 58) {
              this.finishOp(15, 2);
            } else {
              ++this.state.pos;
              this.finishToken(14);
            }
            return;
          case 63:
            this.readToken_question();
            return;
          case 96:
            this.readTemplateToken();
            return;
          case 48: {
            const next = this.input.charCodeAt(this.state.pos + 1);
            if (next === 120 || next === 88) {
              this.readRadixNumber(16);
              return;
            }
            if (next === 111 || next === 79) {
              this.readRadixNumber(8);
              return;
            }
            if (next === 98 || next === 66) {
              this.readRadixNumber(2);
              return;
            }
          }
          case 49:
          case 50:
          case 51:
          case 52:
          case 53:
          case 54:
          case 55:
          case 56:
          case 57:
            this.readNumber(false);
            return;
          case 34:
          case 39:
            this.readString(code2);
            return;
          case 47:
            this.readToken_slash();
            return;
          case 37:
          case 42:
            this.readToken_mult_modulo(code2);
            return;
          case 124:
          case 38:
            this.readToken_pipe_amp(code2);
            return;
          case 94:
            this.readToken_caret();
            return;
          case 43:
          case 45:
            this.readToken_plus_min(code2);
            return;
          case 60:
            this.readToken_lt();
            return;
          case 62:
            this.readToken_gt();
            return;
          case 61:
          case 33:
            this.readToken_eq_excl(code2);
            return;
          case 126:
            this.finishOp(36, 1);
            return;
          case 64:
            this.readToken_atSign();
            return;
          case 35:
            this.readToken_numberSign();
            return;
          case 92:
            this.readWord();
            return;
          default:
            if (isIdentifierStart(code2)) {
              this.readWord(code2);
              return;
            }
        }
        throw this.raise(Errors.InvalidOrUnexpectedToken, this.state.curPosition(), {
          unexpected: String.fromCodePoint(code2)
        });
      }
      finishOp(type, size) {
        const str = this.input.slice(this.state.pos, this.state.pos + size);
        this.state.pos += size;
        this.finishToken(type, str);
      }
      readRegexp() {
        const startLoc = this.state.startLoc;
        const start = this.state.start + 1;
        let escaped, inClass;
        let {
          pos
        } = this.state;
        for (; ; ++pos) {
          if (pos >= this.length) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          const ch = this.input.charCodeAt(pos);
          if (isNewLine(ch)) {
            throw this.raise(Errors.UnterminatedRegExp, createPositionWithColumnOffset(startLoc, 1));
          }
          if (escaped) {
            escaped = false;
          } else {
            if (ch === 91) {
              inClass = true;
            } else if (ch === 93 && inClass) {
              inClass = false;
            } else if (ch === 47 && !inClass) {
              break;
            }
            escaped = ch === 92;
          }
        }
        const content = this.input.slice(start, pos);
        ++pos;
        let mods = "";
        const nextPos = () => createPositionWithColumnOffset(startLoc, pos + 2 - start);
        while (pos < this.length) {
          const cp = this.codePointAtPos(pos);
          const char = String.fromCharCode(cp);
          if (VALID_REGEX_FLAGS.has(cp)) {
            if (cp === 118) {
              if (mods.includes("u")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            } else if (cp === 117) {
              if (mods.includes("v")) {
                this.raise(Errors.IncompatibleRegExpUVFlags, nextPos());
              }
            }
            if (mods.includes(char)) {
              this.raise(Errors.DuplicateRegExpFlags, nextPos());
            }
          } else if (isIdentifierChar(cp) || cp === 92) {
            this.raise(Errors.MalformedRegExpFlags, nextPos());
          } else {
            break;
          }
          ++pos;
          mods += char;
        }
        this.state.pos = pos;
        this.finishToken(137, {
          pattern: content,
          flags: mods
        });
      }
      readInt(radix, len, forceLen = false, allowNumSeparator = true) {
        const {
          n,
          pos
        } = readInt(this.input, this.state.pos, this.state.lineStart, this.state.curLine, radix, len, forceLen, allowNumSeparator, this.errorHandlers_readInt, false);
        this.state.pos = pos;
        return n;
      }
      readRadixNumber(radix) {
        const startLoc = this.state.curPosition();
        let isBigInt = false;
        this.state.pos += 2;
        const val = this.readInt(radix);
        if (val == null) {
          this.raise(Errors.InvalidDigit, createPositionWithColumnOffset(startLoc, 2), {
            radix
          });
        }
        const next = this.input.charCodeAt(this.state.pos);
        if (next === 110) {
          ++this.state.pos;
          isBigInt = true;
        } else if (next === 109) {
          throw this.raise(Errors.InvalidDecimal, startLoc);
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        if (isBigInt) {
          const str = this.input.slice(startLoc.index, this.state.pos).replace(/[_n]/g, "");
          this.finishToken(135, str);
          return;
        }
        this.finishToken(134, val);
      }
      readNumber(startsWithDot) {
        const start = this.state.pos;
        const startLoc = this.state.curPosition();
        let isFloat = false;
        let isBigInt = false;
        let isDecimal = false;
        let hasExponent = false;
        let isOctal = false;
        if (!startsWithDot && this.readInt(10) === null) {
          this.raise(Errors.InvalidNumber, this.state.curPosition());
        }
        const hasLeadingZero = this.state.pos - start >= 2 && this.input.charCodeAt(start) === 48;
        if (hasLeadingZero) {
          const integer = this.input.slice(start, this.state.pos);
          this.recordStrictModeErrors(Errors.StrictOctalLiteral, startLoc);
          if (!this.state.strict) {
            const underscorePos = integer.indexOf("_");
            if (underscorePos > 0) {
              this.raise(Errors.ZeroDigitNumericSeparator, createPositionWithColumnOffset(startLoc, underscorePos));
            }
          }
          isOctal = hasLeadingZero && !/[89]/.test(integer);
        }
        let next = this.input.charCodeAt(this.state.pos);
        if (next === 46 && !isOctal) {
          ++this.state.pos;
          this.readInt(10);
          isFloat = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if ((next === 69 || next === 101) && !isOctal) {
          next = this.input.charCodeAt(++this.state.pos);
          if (next === 43 || next === 45) {
            ++this.state.pos;
          }
          if (this.readInt(10) === null) {
            this.raise(Errors.InvalidOrMissingExponent, startLoc);
          }
          isFloat = true;
          hasExponent = true;
          next = this.input.charCodeAt(this.state.pos);
        }
        if (next === 110) {
          if (isFloat || hasLeadingZero) {
            this.raise(Errors.InvalidBigIntLiteral, startLoc);
          }
          ++this.state.pos;
          isBigInt = true;
        }
        if (next === 109) {
          this.expectPlugin("decimal", this.state.curPosition());
          if (hasExponent || hasLeadingZero) {
            this.raise(Errors.InvalidDecimal, startLoc);
          }
          ++this.state.pos;
          isDecimal = true;
        }
        if (isIdentifierStart(this.codePointAtPos(this.state.pos))) {
          throw this.raise(Errors.NumberIdentifier, this.state.curPosition());
        }
        const str = this.input.slice(start, this.state.pos).replace(/[_mn]/g, "");
        if (isBigInt) {
          this.finishToken(135, str);
          return;
        }
        if (isDecimal) {
          this.finishToken(136, str);
          return;
        }
        const val = isOctal ? parseInt(str, 8) : parseFloat(str);
        this.finishToken(134, val);
      }
      readCodePoint(throwOnInvalid) {
        const {
          code: code2,
          pos
        } = readCodePoint(this.input, this.state.pos, this.state.lineStart, this.state.curLine, throwOnInvalid, this.errorHandlers_readCodePoint);
        this.state.pos = pos;
        return code2;
      }
      readString(quote) {
        const {
          str,
          pos,
          curLine,
          lineStart
        } = readStringContents(quote === 34 ? "double" : "single", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_string);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        this.finishToken(133, str);
      }
      readTemplateContinuation() {
        if (!this.match(8)) {
          this.unexpected(null, 8);
        }
        this.state.pos--;
        this.readTemplateToken();
      }
      readTemplateToken() {
        const opening = this.input[this.state.pos];
        const {
          str,
          firstInvalidLoc,
          pos,
          curLine,
          lineStart
        } = readStringContents("template", this.input, this.state.pos + 1, this.state.lineStart, this.state.curLine, this.errorHandlers_readStringContents_template);
        this.state.pos = pos + 1;
        this.state.lineStart = lineStart;
        this.state.curLine = curLine;
        if (firstInvalidLoc) {
          this.state.firstInvalidTemplateEscapePos = new Position(firstInvalidLoc.curLine, firstInvalidLoc.pos - firstInvalidLoc.lineStart, firstInvalidLoc.pos);
        }
        if (this.input.codePointAt(pos) === 96) {
          this.finishToken(24, firstInvalidLoc ? null : opening + str + "`");
        } else {
          this.state.pos++;
          this.finishToken(25, firstInvalidLoc ? null : opening + str + "${");
        }
      }
      recordStrictModeErrors(toParseError, at) {
        const index = at.index;
        if (this.state.strict && !this.state.strictErrors.has(index)) {
          this.raise(toParseError, at);
        } else {
          this.state.strictErrors.set(index, [toParseError, at]);
        }
      }
      readWord1(firstCode) {
        this.state.containsEsc = false;
        let word = "";
        const start = this.state.pos;
        let chunkStart = this.state.pos;
        if (firstCode !== void 0) {
          this.state.pos += firstCode <= 65535 ? 1 : 2;
        }
        while (this.state.pos < this.length) {
          const ch = this.codePointAtPos(this.state.pos);
          if (isIdentifierChar(ch)) {
            this.state.pos += ch <= 65535 ? 1 : 2;
          } else if (ch === 92) {
            this.state.containsEsc = true;
            word += this.input.slice(chunkStart, this.state.pos);
            const escStart = this.state.curPosition();
            const identifierCheck = this.state.pos === start ? isIdentifierStart : isIdentifierChar;
            if (this.input.charCodeAt(++this.state.pos) !== 117) {
              this.raise(Errors.MissingUnicodeEscape, this.state.curPosition());
              chunkStart = this.state.pos - 1;
              continue;
            }
            ++this.state.pos;
            const esc = this.readCodePoint(true);
            if (esc !== null) {
              if (!identifierCheck(esc)) {
                this.raise(Errors.EscapedCharNotAnIdentifier, escStart);
              }
              word += String.fromCodePoint(esc);
            }
            chunkStart = this.state.pos;
          } else {
            break;
          }
        }
        return word + this.input.slice(chunkStart, this.state.pos);
      }
      readWord(firstCode) {
        const word = this.readWord1(firstCode);
        const type = keywords$1.get(word);
        if (type !== void 0) {
          this.finishToken(type, tokenLabelName(type));
        } else {
          this.finishToken(132, word);
        }
      }
      checkKeywordEscapes() {
        const {
          type
        } = this.state;
        if (tokenIsKeyword(type) && this.state.containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.startLoc, {
            reservedWord: tokenLabelName(type)
          });
        }
      }
      raise(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const error = toParseError(loc, details);
        if (!this.options.errorRecovery) throw error;
        if (!this.isLookahead) this.state.errors.push(error);
        return error;
      }
      raiseOverwrite(toParseError, at, details = {}) {
        const loc = at instanceof Position ? at : at.loc.start;
        const pos = loc.index;
        const errors = this.state.errors;
        for (let i = errors.length - 1; i >= 0; i--) {
          const error = errors[i];
          if (error.loc.index === pos) {
            return errors[i] = toParseError(loc, details);
          }
          if (error.loc.index < pos) break;
        }
        return this.raise(toParseError, at, details);
      }
      updateContext(prevType) {
      }
      unexpected(loc, type) {
        throw this.raise(Errors.UnexpectedToken, loc != null ? loc : this.state.startLoc, {
          expected: type ? tokenLabelName(type) : null
        });
      }
      expectPlugin(pluginName, loc) {
        if (this.hasPlugin(pluginName)) {
          return true;
        }
        throw this.raise(Errors.MissingPlugin, loc != null ? loc : this.state.startLoc, {
          missingPlugin: [pluginName]
        });
      }
      expectOnePlugin(pluginNames) {
        if (!pluginNames.some((name) => this.hasPlugin(name))) {
          throw this.raise(Errors.MissingOneOfPlugins, this.state.startLoc, {
            missingPlugin: pluginNames
          });
        }
      }
      errorBuilder(error) {
        return (pos, lineStart, curLine) => {
          this.raise(error, buildPosition(pos, lineStart, curLine));
        };
      }
    };
    var ClassScope = class {
      constructor() {
        this.privateNames = /* @__PURE__ */ new Set();
        this.loneAccessors = /* @__PURE__ */ new Map();
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
      }
    };
    var ClassScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [];
        this.undefinedPrivateNames = /* @__PURE__ */ new Map();
        this.parser = parser;
      }
      current() {
        return this.stack[this.stack.length - 1];
      }
      enter() {
        this.stack.push(new ClassScope());
      }
      exit() {
        const oldClassScope = this.stack.pop();
        const current = this.current();
        for (const [name, loc] of Array.from(oldClassScope.undefinedPrivateNames)) {
          if (current) {
            if (!current.undefinedPrivateNames.has(name)) {
              current.undefinedPrivateNames.set(name, loc);
            }
          } else {
            this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
              identifierName: name
            });
          }
        }
      }
      declarePrivateName(name, elementType, loc) {
        const {
          privateNames,
          loneAccessors,
          undefinedPrivateNames
        } = this.current();
        let redefined = privateNames.has(name);
        if (elementType & 3) {
          const accessor = redefined && loneAccessors.get(name);
          if (accessor) {
            const oldStatic = accessor & 4;
            const newStatic = elementType & 4;
            const oldKind = accessor & 3;
            const newKind = elementType & 3;
            redefined = oldKind === newKind || oldStatic !== newStatic;
            if (!redefined) loneAccessors.delete(name);
          } else if (!redefined) {
            loneAccessors.set(name, elementType);
          }
        }
        if (redefined) {
          this.parser.raise(Errors.PrivateNameRedeclaration, loc, {
            identifierName: name
          });
        }
        privateNames.add(name);
        undefinedPrivateNames.delete(name);
      }
      usePrivateName(name, loc) {
        let classScope;
        for (classScope of this.stack) {
          if (classScope.privateNames.has(name)) return;
        }
        if (classScope) {
          classScope.undefinedPrivateNames.set(name, loc);
        } else {
          this.parser.raise(Errors.InvalidPrivateFieldResolution, loc, {
            identifierName: name
          });
        }
      }
    };
    var ExpressionScope = class {
      constructor(type = 0) {
        this.type = type;
      }
      canBeArrowParameterDeclaration() {
        return this.type === 2 || this.type === 1;
      }
      isCertainlyParameterDeclaration() {
        return this.type === 3;
      }
    };
    var ArrowHeadParsingScope = class extends ExpressionScope {
      constructor(type) {
        super(type);
        this.declarationErrors = /* @__PURE__ */ new Map();
      }
      recordDeclarationError(ParsingErrorClass, at) {
        const index = at.index;
        this.declarationErrors.set(index, [ParsingErrorClass, at]);
      }
      clearDeclarationError(index) {
        this.declarationErrors.delete(index);
      }
      iterateErrors(iterator) {
        this.declarationErrors.forEach(iterator);
      }
    };
    var ExpressionScopeHandler = class {
      constructor(parser) {
        this.parser = void 0;
        this.stack = [new ExpressionScope()];
        this.parser = parser;
      }
      enter(scope) {
        this.stack.push(scope);
      }
      exit() {
        this.stack.pop();
      }
      recordParameterInitializerError(toParseError, node) {
        const origin = node.loc.start;
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (!scope.isCertainlyParameterDeclaration()) {
          if (scope.canBeArrowParameterDeclaration()) {
            scope.recordDeclarationError(toParseError, origin);
          } else {
            return;
          }
          scope = stack[--i];
        }
        this.parser.raise(toParseError, origin);
      }
      recordArrowParameterBindingError(error, node) {
        const {
          stack
        } = this;
        const scope = stack[stack.length - 1];
        const origin = node.loc.start;
        if (scope.isCertainlyParameterDeclaration()) {
          this.parser.raise(error, origin);
        } else if (scope.canBeArrowParameterDeclaration()) {
          scope.recordDeclarationError(error, origin);
        } else {
          return;
        }
      }
      recordAsyncArrowParametersError(at) {
        const {
          stack
        } = this;
        let i = stack.length - 1;
        let scope = stack[i];
        while (scope.canBeArrowParameterDeclaration()) {
          if (scope.type === 2) {
            scope.recordDeclarationError(Errors.AwaitBindingIdentifier, at);
          }
          scope = stack[--i];
        }
      }
      validateAsPattern() {
        const {
          stack
        } = this;
        const currentScope = stack[stack.length - 1];
        if (!currentScope.canBeArrowParameterDeclaration()) return;
        currentScope.iterateErrors(([toParseError, loc]) => {
          this.parser.raise(toParseError, loc);
          let i = stack.length - 2;
          let scope = stack[i];
          while (scope.canBeArrowParameterDeclaration()) {
            scope.clearDeclarationError(loc.index);
            scope = stack[--i];
          }
        });
      }
    };
    function newParameterDeclarationScope() {
      return new ExpressionScope(3);
    }
    function newArrowHeadScope() {
      return new ArrowHeadParsingScope(1);
    }
    function newAsyncArrowScope() {
      return new ArrowHeadParsingScope(2);
    }
    function newExpressionScope() {
      return new ExpressionScope();
    }
    var ProductionParameterHandler = class {
      constructor() {
        this.stacks = [];
      }
      enter(flags) {
        this.stacks.push(flags);
      }
      exit() {
        this.stacks.pop();
      }
      currentFlags() {
        return this.stacks[this.stacks.length - 1];
      }
      get hasAwait() {
        return (this.currentFlags() & 2) > 0;
      }
      get hasYield() {
        return (this.currentFlags() & 1) > 0;
      }
      get hasReturn() {
        return (this.currentFlags() & 4) > 0;
      }
      get hasIn() {
        return (this.currentFlags() & 8) > 0;
      }
    };
    function functionFlags(isAsync, isGenerator) {
      return (isAsync ? 2 : 0) | (isGenerator ? 1 : 0);
    }
    var UtilParser = class extends Tokenizer {
      addExtra(node, key, value, enumerable = true) {
        if (!node) return;
        const extra = node.extra = node.extra || {};
        if (enumerable) {
          extra[key] = value;
        } else {
          Object.defineProperty(extra, key, {
            enumerable,
            value
          });
        }
      }
      isContextual(token) {
        return this.state.type === token && !this.state.containsEsc;
      }
      isUnparsedContextual(nameStart, name) {
        const nameEnd = nameStart + name.length;
        if (this.input.slice(nameStart, nameEnd) === name) {
          const nextCh = this.input.charCodeAt(nameEnd);
          return !(isIdentifierChar(nextCh) || (nextCh & 64512) === 55296);
        }
        return false;
      }
      isLookaheadContextual(name) {
        const next = this.nextTokenStart();
        return this.isUnparsedContextual(next, name);
      }
      eatContextual(token) {
        if (this.isContextual(token)) {
          this.next();
          return true;
        }
        return false;
      }
      expectContextual(token, toParseError) {
        if (!this.eatContextual(token)) {
          if (toParseError != null) {
            throw this.raise(toParseError, this.state.startLoc);
          }
          this.unexpected(null, token);
        }
      }
      canInsertSemicolon() {
        return this.match(139) || this.match(8) || this.hasPrecedingLineBreak();
      }
      hasPrecedingLineBreak() {
        return lineBreak.test(this.input.slice(this.state.lastTokEndLoc.index, this.state.start));
      }
      hasFollowingLineBreak() {
        skipWhiteSpaceToLineBreak.lastIndex = this.state.end;
        return skipWhiteSpaceToLineBreak.test(this.input);
      }
      isLineTerminator() {
        return this.eat(13) || this.canInsertSemicolon();
      }
      semicolon(allowAsi = true) {
        if (allowAsi ? this.isLineTerminator() : this.eat(13)) return;
        this.raise(Errors.MissingSemicolon, this.state.lastTokEndLoc);
      }
      expect(type, loc) {
        if (!this.eat(type)) {
          this.unexpected(loc, type);
        }
      }
      tryParse(fn, oldState = this.state.clone()) {
        const abortSignal = {
          node: null
        };
        try {
          const node = fn((node2 = null) => {
            abortSignal.node = node2;
            throw abortSignal;
          });
          if (this.state.errors.length > oldState.errors.length) {
            const failState = this.state;
            this.state = oldState;
            this.state.tokensLength = failState.tokensLength;
            return {
              node,
              error: failState.errors[oldState.errors.length],
              thrown: false,
              aborted: false,
              failState
            };
          }
          return {
            node,
            error: null,
            thrown: false,
            aborted: false,
            failState: null
          };
        } catch (error) {
          const failState = this.state;
          this.state = oldState;
          if (error instanceof SyntaxError) {
            return {
              node: null,
              error,
              thrown: true,
              aborted: false,
              failState
            };
          }
          if (error === abortSignal) {
            return {
              node: abortSignal.node,
              error: null,
              thrown: false,
              aborted: true,
              failState
            };
          }
          throw error;
        }
      }
      checkExpressionErrors(refExpressionErrors, andThrow) {
        if (!refExpressionErrors) return false;
        const {
          shorthandAssignLoc,
          doubleProtoLoc,
          privateKeyLoc,
          optionalParametersLoc
        } = refExpressionErrors;
        const hasErrors = !!shorthandAssignLoc || !!doubleProtoLoc || !!optionalParametersLoc || !!privateKeyLoc;
        if (!andThrow) {
          return hasErrors;
        }
        if (shorthandAssignLoc != null) {
          this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
        }
        if (doubleProtoLoc != null) {
          this.raise(Errors.DuplicateProto, doubleProtoLoc);
        }
        if (privateKeyLoc != null) {
          this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
        }
        if (optionalParametersLoc != null) {
          this.unexpected(optionalParametersLoc);
        }
      }
      isLiteralPropertyName() {
        return tokenIsLiteralPropertyName(this.state.type);
      }
      isPrivateName(node) {
        return node.type === "PrivateName";
      }
      getPrivateNameSV(node) {
        return node.id.name;
      }
      hasPropertyAsPrivateName(node) {
        return (node.type === "MemberExpression" || node.type === "OptionalMemberExpression") && this.isPrivateName(node.property);
      }
      isObjectProperty(node) {
        return node.type === "ObjectProperty";
      }
      isObjectMethod(node) {
        return node.type === "ObjectMethod";
      }
      initializeScopes(inModule = this.options.sourceType === "module") {
        const oldLabels = this.state.labels;
        this.state.labels = [];
        const oldExportedIdentifiers = this.exportedIdentifiers;
        this.exportedIdentifiers = /* @__PURE__ */ new Set();
        const oldInModule = this.inModule;
        this.inModule = inModule;
        const oldScope = this.scope;
        const ScopeHandler2 = this.getScopeHandler();
        this.scope = new ScopeHandler2(this, inModule);
        const oldProdParam = this.prodParam;
        this.prodParam = new ProductionParameterHandler();
        const oldClassScope = this.classScope;
        this.classScope = new ClassScopeHandler(this);
        const oldExpressionScope = this.expressionScope;
        this.expressionScope = new ExpressionScopeHandler(this);
        return () => {
          this.state.labels = oldLabels;
          this.exportedIdentifiers = oldExportedIdentifiers;
          this.inModule = oldInModule;
          this.scope = oldScope;
          this.prodParam = oldProdParam;
          this.classScope = oldClassScope;
          this.expressionScope = oldExpressionScope;
        };
      }
      enterInitialScopes() {
        let paramFlags = 0;
        if (this.inModule) {
          paramFlags |= 2;
        }
        this.scope.enter(1);
        this.prodParam.enter(paramFlags);
      }
      checkDestructuringPrivate(refExpressionErrors) {
        const {
          privateKeyLoc
        } = refExpressionErrors;
        if (privateKeyLoc !== null) {
          this.expectPlugin("destructuringPrivate", privateKeyLoc);
        }
      }
    };
    var ExpressionErrors = class {
      constructor() {
        this.shorthandAssignLoc = null;
        this.doubleProtoLoc = null;
        this.privateKeyLoc = null;
        this.optionalParametersLoc = null;
      }
    };
    var Node = class {
      constructor(parser, pos, loc) {
        this.type = "";
        this.start = pos;
        this.end = 0;
        this.loc = new SourceLocation(loc);
        if (parser != null && parser.options.ranges) this.range = [pos, 0];
        if (parser != null && parser.filename) this.loc.filename = parser.filename;
      }
    };
    var NodePrototype = Node.prototype;
    {
      NodePrototype.__clone = function() {
        const newNode = new Node(void 0, this.start, this.loc.start);
        const keys = Object.keys(this);
        for (let i = 0, length = keys.length; i < length; i++) {
          const key = keys[i];
          if (key !== "leadingComments" && key !== "trailingComments" && key !== "innerComments") {
            newNode[key] = this[key];
          }
        }
        return newNode;
      };
    }
    function clonePlaceholder(node) {
      return cloneIdentifier(node);
    }
    function cloneIdentifier(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra,
        name
      } = node;
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      cloned.extra = extra;
      cloned.name = name;
      if (type === "Placeholder") {
        cloned.expectedNode = node.expectedNode;
      }
      return cloned;
    }
    function cloneStringLiteral(node) {
      const {
        type,
        start,
        end,
        loc,
        range,
        extra
      } = node;
      if (type === "Placeholder") {
        return clonePlaceholder(node);
      }
      const cloned = Object.create(NodePrototype);
      cloned.type = type;
      cloned.start = start;
      cloned.end = end;
      cloned.loc = loc;
      cloned.range = range;
      if (node.raw !== void 0) {
        cloned.raw = node.raw;
      } else {
        cloned.extra = extra;
      }
      cloned.value = node.value;
      return cloned;
    }
    var NodeUtils = class extends UtilParser {
      startNode() {
        const loc = this.state.startLoc;
        return new Node(this, loc.index, loc);
      }
      startNodeAt(loc) {
        return new Node(this, loc.index, loc);
      }
      startNodeAtNode(type) {
        return this.startNodeAt(type.loc.start);
      }
      finishNode(node, type) {
        return this.finishNodeAt(node, type, this.state.lastTokEndLoc);
      }
      finishNodeAt(node, type, endLoc) {
        node.type = type;
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges) node.range[1] = endLoc.index;
        if (this.options.attachComment) this.processComment(node);
        return node;
      }
      resetStartLocation(node, startLoc) {
        node.start = startLoc.index;
        node.loc.start = startLoc;
        if (this.options.ranges) node.range[0] = startLoc.index;
      }
      resetEndLocation(node, endLoc = this.state.lastTokEndLoc) {
        node.end = endLoc.index;
        node.loc.end = endLoc;
        if (this.options.ranges) node.range[1] = endLoc.index;
      }
      resetStartLocationFromNode(node, locationNode) {
        this.resetStartLocation(node, locationNode.loc.start);
      }
    };
    var reservedTypes = /* @__PURE__ */ new Set(["_", "any", "bool", "boolean", "empty", "extends", "false", "interface", "mixed", "null", "number", "static", "string", "true", "typeof", "void"]);
    var FlowErrors = ParseErrorEnum`flow`({
      AmbiguousConditionalArrow: "Ambiguous expression: wrap the arrow functions in parentheses to disambiguate.",
      AmbiguousDeclareModuleKind: "Found both `declare module.exports` and `declare export` in the same module. Modules can only have 1 since they are either an ES module or they are a CommonJS module.",
      AssignReservedType: ({
        reservedType
      }) => `Cannot overwrite reserved type ${reservedType}.`,
      DeclareClassElement: "The `declare` modifier can only appear on class fields.",
      DeclareClassFieldInitializer: "Initializers are not allowed in fields with the `declare` modifier.",
      DuplicateDeclareModuleExports: "Duplicate `declare module.exports` statement.",
      EnumBooleanMemberNotInitialized: ({
        memberName,
        enumName
      }) => `Boolean enum members need to be initialized. Use either \`${memberName} = true,\` or \`${memberName} = false,\` in enum \`${enumName}\`.`,
      EnumDuplicateMemberName: ({
        memberName,
        enumName
      }) => `Enum member names need to be unique, but the name \`${memberName}\` has already been used before in enum \`${enumName}\`.`,
      EnumInconsistentMemberValues: ({
        enumName
      }) => `Enum \`${enumName}\` has inconsistent member initializers. Either use no initializers, or consistently use literals (either booleans, numbers, or strings) for all member initializers.`,
      EnumInvalidExplicitType: ({
        invalidEnumType,
        enumName
      }) => `Enum type \`${invalidEnumType}\` is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidExplicitTypeUnknownSupplied: ({
        enumName
      }) => `Supplied enum type is not valid. Use one of \`boolean\`, \`number\`, \`string\`, or \`symbol\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerPrimaryType: ({
        enumName,
        memberName,
        explicitType
      }) => `Enum \`${enumName}\` has type \`${explicitType}\`, so the initializer of \`${memberName}\` needs to be a ${explicitType} literal.`,
      EnumInvalidMemberInitializerSymbolType: ({
        enumName,
        memberName
      }) => `Symbol enum members cannot be initialized. Use \`${memberName},\` in enum \`${enumName}\`.`,
      EnumInvalidMemberInitializerUnknownType: ({
        enumName,
        memberName
      }) => `The enum member initializer for \`${memberName}\` needs to be a literal (either a boolean, number, or string) in enum \`${enumName}\`.`,
      EnumInvalidMemberName: ({
        enumName,
        memberName,
        suggestion
      }) => `Enum member names cannot start with lowercase 'a' through 'z'. Instead of using \`${memberName}\`, consider using \`${suggestion}\`, in enum \`${enumName}\`.`,
      EnumNumberMemberNotInitialized: ({
        enumName,
        memberName
      }) => `Number enum members need to be initialized, e.g. \`${memberName} = 1\` in enum \`${enumName}\`.`,
      EnumStringMemberInconsistentlyInitialized: ({
        enumName
      }) => `String enum members need to consistently either all use initializers, or use no initializers, in enum \`${enumName}\`.`,
      GetterMayNotHaveThisParam: "A getter cannot have a `this` parameter.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` or `typeof` keyword.",
      ImportTypeShorthandOnlyInPureImport: "The `type` and `typeof` keywords on named imports can only be used on regular `import` statements. It cannot be used with `import type` or `import typeof` statements.",
      InexactInsideExact: "Explicit inexact syntax cannot appear inside an explicit exact object type.",
      InexactInsideNonObject: "Explicit inexact syntax cannot appear in class or interface definitions.",
      InexactVariance: "Explicit inexact syntax cannot have variance.",
      InvalidNonTypeImportInDeclareModule: "Imports within a `declare module` body must always be `import type` or `import typeof`.",
      MissingTypeParamDefault: "Type parameter declaration needs a default, since a preceding type parameter declaration has a default.",
      NestedDeclareModule: "`declare module` cannot be used inside another `declare module`.",
      NestedFlowComment: "Cannot have a flow comment inside another flow comment.",
      PatternIsOptional: Object.assign({
        message: "A binding pattern parameter cannot be optional in an implementation signature."
      }, {
        reasonCode: "OptionalBindingPattern"
      }),
      SetterMayNotHaveThisParam: "A setter cannot have a `this` parameter.",
      SpreadVariance: "Spread properties cannot have variance.",
      ThisParamAnnotationRequired: "A type annotation is required for the `this` parameter.",
      ThisParamBannedInConstructor: "Constructors cannot have a `this` parameter; constructors don't bind `this` like other functions.",
      ThisParamMayNotBeOptional: "The `this` parameter cannot be optional.",
      ThisParamMustBeFirst: "The `this` parameter must be the first function parameter.",
      ThisParamNoDefault: "The `this` parameter may not have a default value.",
      TypeBeforeInitializer: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeCastInPattern: "The type cast expression is expected to be wrapped with parenthesis.",
      UnexpectedExplicitInexactInObject: "Explicit inexact syntax must appear at the end of an inexact object.",
      UnexpectedReservedType: ({
        reservedType
      }) => `Unexpected reserved type ${reservedType}.`,
      UnexpectedReservedUnderscore: "`_` is only allowed as a type argument to call or new.",
      UnexpectedSpaceBetweenModuloChecks: "Spaces between `%` and `checks` are not allowed here.",
      UnexpectedSpreadType: "Spread operator cannot appear in class or interface definitions.",
      UnexpectedSubtractionOperand: 'Unexpected token, expected "number" or "bigint".',
      UnexpectedTokenAfterTypeParameter: "Expected an arrow function after this type parameter declaration.",
      UnexpectedTypeParameterBeforeAsyncArrowFunction: "Type parameters must come after the async keyword, e.g. instead of `<T> async () => {}`, use `async <T>() => {}`.",
      UnsupportedDeclareExportKind: ({
        unsupportedExportKind,
        suggestion
      }) => `\`declare export ${unsupportedExportKind}\` is not supported. Use \`${suggestion}\` instead.`,
      UnsupportedStatementInDeclareModule: "Only declares and type imports are allowed inside declare module.",
      UnterminatedFlowComment: "Unterminated flow-comment."
    });
    function isEsModuleType(bodyElement) {
      return bodyElement.type === "DeclareExportAllDeclaration" || bodyElement.type === "DeclareExportDeclaration" && (!bodyElement.declaration || bodyElement.declaration.type !== "TypeAlias" && bodyElement.declaration.type !== "InterfaceDeclaration");
    }
    function hasTypeImportKind(node) {
      return node.importKind === "type" || node.importKind === "typeof";
    }
    var exportSuggestions = {
      const: "declare export var",
      let: "declare export var",
      type: "export type",
      interface: "export interface"
    };
    function partition(list, test) {
      const list1 = [];
      const list2 = [];
      for (let i = 0; i < list.length; i++) {
        (test(list[i], i, list) ? list1 : list2).push(list[i]);
      }
      return [list1, list2];
    }
    var FLOW_PRAGMA_REGEX = /\*?\s*@((?:no)?flow)\b/;
    var flow = (superClass) => class FlowParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.flowPragma = void 0;
      }
      getScopeHandler() {
        return FlowScopeHandler;
      }
      shouldParseTypes() {
        return this.getPluginOption("flow", "all") || this.flowPragma === "flow";
      }
      shouldParseEnums() {
        return !!this.getPluginOption("flow", "enums");
      }
      finishToken(type, val) {
        if (type !== 133 && type !== 13 && type !== 28) {
          if (this.flowPragma === void 0) {
            this.flowPragma = null;
          }
        }
        super.finishToken(type, val);
      }
      addComment(comment) {
        if (this.flowPragma === void 0) {
          const matches = FLOW_PRAGMA_REGEX.exec(comment.value);
          if (!matches) ;
          else if (matches[1] === "flow") {
            this.flowPragma = "flow";
          } else if (matches[1] === "noflow") {
            this.flowPragma = "noflow";
          } else {
            throw new Error("Unexpected flow pragma");
          }
        }
        super.addComment(comment);
      }
      flowParseTypeInitialiser(tok) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(tok || 14);
        const type = this.flowParseType();
        this.state.inType = oldInType;
        return type;
      }
      flowParsePredicate() {
        const node = this.startNode();
        const moduloLoc = this.state.startLoc;
        this.next();
        this.expectContextual(110);
        if (this.state.lastTokStartLoc.index > moduloLoc.index + 1) {
          this.raise(FlowErrors.UnexpectedSpaceBetweenModuloChecks, moduloLoc);
        }
        if (this.eat(10)) {
          node.value = super.parseExpression();
          this.expect(11);
          return this.finishNode(node, "DeclaredPredicate");
        } else {
          return this.finishNode(node, "InferredPredicate");
        }
      }
      flowParseTypeAndPredicateInitialiser() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        this.expect(14);
        let type = null;
        let predicate = null;
        if (this.match(54)) {
          this.state.inType = oldInType;
          predicate = this.flowParsePredicate();
        } else {
          type = this.flowParseType();
          this.state.inType = oldInType;
          if (this.match(54)) {
            predicate = this.flowParsePredicate();
          }
        }
        return [type, predicate];
      }
      flowParseDeclareClass(node) {
        this.next();
        this.flowParseInterfaceish(node, true);
        return this.finishNode(node, "DeclareClass");
      }
      flowParseDeclareFunction(node) {
        this.next();
        const id = node.id = this.parseIdentifier();
        const typeNode = this.startNode();
        const typeContainer = this.startNode();
        if (this.match(47)) {
          typeNode.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          typeNode.typeParameters = null;
        }
        this.expect(10);
        const tmp = this.flowParseFunctionTypeParams();
        typeNode.params = tmp.params;
        typeNode.rest = tmp.rest;
        typeNode.this = tmp._this;
        this.expect(11);
        [typeNode.returnType, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
        typeContainer.typeAnnotation = this.finishNode(typeNode, "FunctionTypeAnnotation");
        id.typeAnnotation = this.finishNode(typeContainer, "TypeAnnotation");
        this.resetEndLocation(id);
        this.semicolon();
        this.scope.declareName(node.id.name, 2048, node.id.loc.start);
        return this.finishNode(node, "DeclareFunction");
      }
      flowParseDeclare(node, insideModule) {
        if (this.match(80)) {
          return this.flowParseDeclareClass(node);
        } else if (this.match(68)) {
          return this.flowParseDeclareFunction(node);
        } else if (this.match(74)) {
          return this.flowParseDeclareVariable(node);
        } else if (this.eatContextual(127)) {
          if (this.match(16)) {
            return this.flowParseDeclareModuleExports(node);
          } else {
            if (insideModule) {
              this.raise(FlowErrors.NestedDeclareModule, this.state.lastTokStartLoc);
            }
            return this.flowParseDeclareModule(node);
          }
        } else if (this.isContextual(130)) {
          return this.flowParseDeclareTypeAlias(node);
        } else if (this.isContextual(131)) {
          return this.flowParseDeclareOpaqueType(node);
        } else if (this.isContextual(129)) {
          return this.flowParseDeclareInterface(node);
        } else if (this.match(82)) {
          return this.flowParseDeclareExportDeclaration(node, insideModule);
        } else {
          this.unexpected();
        }
      }
      flowParseDeclareVariable(node) {
        this.next();
        node.id = this.flowParseTypeAnnotatableIdentifier(true);
        this.scope.declareName(node.id.name, 5, node.id.loc.start);
        this.semicolon();
        return this.finishNode(node, "DeclareVariable");
      }
      flowParseDeclareModule(node) {
        this.scope.enter(0);
        if (this.match(133)) {
          node.id = super.parseExprAtom();
        } else {
          node.id = this.parseIdentifier();
        }
        const bodyNode = node.body = this.startNode();
        const body = bodyNode.body = [];
        this.expect(5);
        while (!this.match(8)) {
          let bodyNode2 = this.startNode();
          if (this.match(83)) {
            this.next();
            if (!this.isContextual(130) && !this.match(87)) {
              this.raise(FlowErrors.InvalidNonTypeImportInDeclareModule, this.state.lastTokStartLoc);
            }
            super.parseImport(bodyNode2);
          } else {
            this.expectContextual(125, FlowErrors.UnsupportedStatementInDeclareModule);
            bodyNode2 = this.flowParseDeclare(bodyNode2, true);
          }
          body.push(bodyNode2);
        }
        this.scope.exit();
        this.expect(8);
        this.finishNode(bodyNode, "BlockStatement");
        let kind = null;
        let hasModuleExport = false;
        body.forEach((bodyElement) => {
          if (isEsModuleType(bodyElement)) {
            if (kind === "CommonJS") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "ES";
          } else if (bodyElement.type === "DeclareModuleExports") {
            if (hasModuleExport) {
              this.raise(FlowErrors.DuplicateDeclareModuleExports, bodyElement);
            }
            if (kind === "ES") {
              this.raise(FlowErrors.AmbiguousDeclareModuleKind, bodyElement);
            }
            kind = "CommonJS";
            hasModuleExport = true;
          }
        });
        node.kind = kind || "CommonJS";
        return this.finishNode(node, "DeclareModule");
      }
      flowParseDeclareExportDeclaration(node, insideModule) {
        this.expect(82);
        if (this.eat(65)) {
          if (this.match(68) || this.match(80)) {
            node.declaration = this.flowParseDeclare(this.startNode());
          } else {
            node.declaration = this.flowParseType();
            this.semicolon();
          }
          node.default = true;
          return this.finishNode(node, "DeclareExportDeclaration");
        } else {
          if (this.match(75) || this.isLet() || (this.isContextual(130) || this.isContextual(129)) && !insideModule) {
            const label = this.state.value;
            throw this.raise(FlowErrors.UnsupportedDeclareExportKind, this.state.startLoc, {
              unsupportedExportKind: label,
              suggestion: exportSuggestions[label]
            });
          }
          if (this.match(74) || this.match(68) || this.match(80) || this.isContextual(131)) {
            node.declaration = this.flowParseDeclare(this.startNode());
            node.default = false;
            return this.finishNode(node, "DeclareExportDeclaration");
          } else if (this.match(55) || this.match(5) || this.isContextual(129) || this.isContextual(130) || this.isContextual(131)) {
            node = this.parseExport(node, null);
            if (node.type === "ExportNamedDeclaration") {
              node.type = "ExportDeclaration";
              node.default = false;
              delete node.exportKind;
            }
            node.type = "Declare" + node.type;
            return node;
          }
        }
        this.unexpected();
      }
      flowParseDeclareModuleExports(node) {
        this.next();
        this.expectContextual(111);
        node.typeAnnotation = this.flowParseTypeAnnotation();
        this.semicolon();
        return this.finishNode(node, "DeclareModuleExports");
      }
      flowParseDeclareTypeAlias(node) {
        this.next();
        const finished = this.flowParseTypeAlias(node);
        finished.type = "DeclareTypeAlias";
        return finished;
      }
      flowParseDeclareOpaqueType(node) {
        this.next();
        const finished = this.flowParseOpaqueType(node, true);
        finished.type = "DeclareOpaqueType";
        return finished;
      }
      flowParseDeclareInterface(node) {
        this.next();
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "DeclareInterface");
      }
      flowParseInterfaceish(node, isClass) {
        node.id = this.flowParseRestrictedIdentifier(!isClass, true);
        this.scope.declareName(node.id.name, isClass ? 17 : 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (!isClass && this.eat(12));
        }
        if (isClass) {
          node.implements = [];
          node.mixins = [];
          if (this.eatContextual(117)) {
            do {
              node.mixins.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
          if (this.eatContextual(113)) {
            do {
              node.implements.push(this.flowParseInterfaceExtends());
            } while (this.eat(12));
          }
        }
        node.body = this.flowParseObjectType({
          allowStatic: isClass,
          allowExact: false,
          allowSpread: false,
          allowProto: isClass,
          allowInexact: false
        });
      }
      flowParseInterfaceExtends() {
        const node = this.startNode();
        node.id = this.flowParseQualifiedTypeIdentifier();
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        } else {
          node.typeParameters = null;
        }
        return this.finishNode(node, "InterfaceExtends");
      }
      flowParseInterface(node) {
        this.flowParseInterfaceish(node, false);
        return this.finishNode(node, "InterfaceDeclaration");
      }
      checkNotUnderscore(word) {
        if (word === "_") {
          this.raise(FlowErrors.UnexpectedReservedUnderscore, this.state.startLoc);
        }
      }
      checkReservedType(word, startLoc, declaration) {
        if (!reservedTypes.has(word)) return;
        this.raise(declaration ? FlowErrors.AssignReservedType : FlowErrors.UnexpectedReservedType, startLoc, {
          reservedType: word
        });
      }
      flowParseRestrictedIdentifier(liberal, declaration) {
        this.checkReservedType(this.state.value, this.state.startLoc, declaration);
        return this.parseIdentifier(liberal);
      }
      flowParseTypeAlias(node) {
        node.id = this.flowParseRestrictedIdentifier(false, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.right = this.flowParseTypeInitialiser(29);
        this.semicolon();
        return this.finishNode(node, "TypeAlias");
      }
      flowParseOpaqueType(node, declare) {
        this.expectContextual(130);
        node.id = this.flowParseRestrictedIdentifier(true, true);
        this.scope.declareName(node.id.name, 8201, node.id.loc.start);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        } else {
          node.typeParameters = null;
        }
        node.supertype = null;
        if (this.match(14)) {
          node.supertype = this.flowParseTypeInitialiser(14);
        }
        node.impltype = null;
        if (!declare) {
          node.impltype = this.flowParseTypeInitialiser(29);
        }
        this.semicolon();
        return this.finishNode(node, "OpaqueType");
      }
      flowParseTypeParameter(requireDefault = false) {
        const nodeStartLoc = this.state.startLoc;
        const node = this.startNode();
        const variance = this.flowParseVariance();
        const ident = this.flowParseTypeAnnotatableIdentifier();
        node.name = ident.name;
        node.variance = variance;
        node.bound = ident.typeAnnotation;
        if (this.match(29)) {
          this.eat(29);
          node.default = this.flowParseType();
        } else {
          if (requireDefault) {
            this.raise(FlowErrors.MissingTypeParamDefault, nodeStartLoc);
          }
        }
        return this.finishNode(node, "TypeParameter");
      }
      flowParseTypeParameterDeclaration() {
        const oldInType = this.state.inType;
        const node = this.startNode();
        node.params = [];
        this.state.inType = true;
        if (this.match(47) || this.match(142)) {
          this.next();
        } else {
          this.unexpected();
        }
        let defaultRequired = false;
        do {
          const typeParameter = this.flowParseTypeParameter(defaultRequired);
          node.params.push(typeParameter);
          if (typeParameter.default) {
            defaultRequired = true;
          }
          if (!this.match(48)) {
            this.expect(12);
          }
        } while (!this.match(48));
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterDeclaration");
      }
      flowParseTypeParameterInstantiation() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        this.state.noAnonFunctionType = false;
        while (!this.match(48)) {
          node.params.push(this.flowParseType());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.state.noAnonFunctionType = oldNoAnonFunctionType;
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseTypeParameterInstantiationCallOrNew() {
        const node = this.startNode();
        const oldInType = this.state.inType;
        node.params = [];
        this.state.inType = true;
        this.expect(47);
        while (!this.match(48)) {
          node.params.push(this.flowParseTypeOrImplicitInstantiation());
          if (!this.match(48)) {
            this.expect(12);
          }
        }
        this.expect(48);
        this.state.inType = oldInType;
        return this.finishNode(node, "TypeParameterInstantiation");
      }
      flowParseInterfaceType() {
        const node = this.startNode();
        this.expectContextual(129);
        node.extends = [];
        if (this.eat(81)) {
          do {
            node.extends.push(this.flowParseInterfaceExtends());
          } while (this.eat(12));
        }
        node.body = this.flowParseObjectType({
          allowStatic: false,
          allowExact: false,
          allowSpread: false,
          allowProto: false,
          allowInexact: false
        });
        return this.finishNode(node, "InterfaceTypeAnnotation");
      }
      flowParseObjectPropertyKey() {
        return this.match(134) || this.match(133) ? super.parseExprAtom() : this.parseIdentifier(true);
      }
      flowParseObjectTypeIndexer(node, isStatic, variance) {
        node.static = isStatic;
        if (this.lookahead().type === 14) {
          node.id = this.flowParseObjectPropertyKey();
          node.key = this.flowParseTypeInitialiser();
        } else {
          node.id = null;
          node.key = this.flowParseType();
        }
        this.expect(3);
        node.value = this.flowParseTypeInitialiser();
        node.variance = variance;
        return this.finishNode(node, "ObjectTypeIndexer");
      }
      flowParseObjectTypeInternalSlot(node, isStatic) {
        node.static = isStatic;
        node.id = this.flowParseObjectPropertyKey();
        this.expect(3);
        this.expect(3);
        if (this.match(47) || this.match(10)) {
          node.method = true;
          node.optional = false;
          node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
        } else {
          node.method = false;
          if (this.eat(17)) {
            node.optional = true;
          }
          node.value = this.flowParseTypeInitialiser();
        }
        return this.finishNode(node, "ObjectTypeInternalSlot");
      }
      flowParseObjectTypeMethodish(node) {
        node.params = [];
        node.rest = null;
        node.typeParameters = null;
        node.this = null;
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        this.expect(10);
        if (this.match(78)) {
          node.this = this.flowParseFunctionTypeParam(true);
          node.this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          node.params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          node.rest = this.flowParseFunctionTypeParam(false);
        }
        this.expect(11);
        node.returnType = this.flowParseTypeInitialiser();
        return this.finishNode(node, "FunctionTypeAnnotation");
      }
      flowParseObjectTypeCallProperty(node, isStatic) {
        const valueNode = this.startNode();
        node.static = isStatic;
        node.value = this.flowParseObjectTypeMethodish(valueNode);
        return this.finishNode(node, "ObjectTypeCallProperty");
      }
      flowParseObjectType({
        allowStatic,
        allowExact,
        allowSpread,
        allowProto,
        allowInexact
      }) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const nodeStart = this.startNode();
        nodeStart.callProperties = [];
        nodeStart.properties = [];
        nodeStart.indexers = [];
        nodeStart.internalSlots = [];
        let endDelim;
        let exact;
        let inexact = false;
        if (allowExact && this.match(6)) {
          this.expect(6);
          endDelim = 9;
          exact = true;
        } else {
          this.expect(5);
          endDelim = 8;
          exact = false;
        }
        nodeStart.exact = exact;
        while (!this.match(endDelim)) {
          let isStatic = false;
          let protoStartLoc = null;
          let inexactStartLoc = null;
          const node = this.startNode();
          if (allowProto && this.isContextual(118)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              protoStartLoc = this.state.startLoc;
              allowStatic = false;
            }
          }
          if (allowStatic && this.isContextual(106)) {
            const lookahead = this.lookahead();
            if (lookahead.type !== 14 && lookahead.type !== 17) {
              this.next();
              isStatic = true;
            }
          }
          const variance = this.flowParseVariance();
          if (this.eat(0)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (this.eat(0)) {
              if (variance) {
                this.unexpected(variance.loc.start);
              }
              nodeStart.internalSlots.push(this.flowParseObjectTypeInternalSlot(node, isStatic));
            } else {
              nodeStart.indexers.push(this.flowParseObjectTypeIndexer(node, isStatic, variance));
            }
          } else if (this.match(10) || this.match(47)) {
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            nodeStart.callProperties.push(this.flowParseObjectTypeCallProperty(node, isStatic));
          } else {
            let kind = "init";
            if (this.isContextual(99) || this.isContextual(104)) {
              const lookahead = this.lookahead();
              if (tokenIsLiteralPropertyName(lookahead.type)) {
                kind = this.state.value;
                this.next();
              }
            }
            const propOrInexact = this.flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact != null ? allowInexact : !exact);
            if (propOrInexact === null) {
              inexact = true;
              inexactStartLoc = this.state.lastTokStartLoc;
            } else {
              nodeStart.properties.push(propOrInexact);
            }
          }
          this.flowObjectTypeSemicolon();
          if (inexactStartLoc && !this.match(8) && !this.match(9)) {
            this.raise(FlowErrors.UnexpectedExplicitInexactInObject, inexactStartLoc);
          }
        }
        this.expect(endDelim);
        if (allowSpread) {
          nodeStart.inexact = inexact;
        }
        const out = this.finishNode(nodeStart, "ObjectTypeAnnotation");
        this.state.inType = oldInType;
        return out;
      }
      flowParseObjectTypeProperty(node, isStatic, protoStartLoc, variance, kind, allowSpread, allowInexact) {
        if (this.eat(21)) {
          const isInexactToken = this.match(12) || this.match(13) || this.match(8) || this.match(9);
          if (isInexactToken) {
            if (!allowSpread) {
              this.raise(FlowErrors.InexactInsideNonObject, this.state.lastTokStartLoc);
            } else if (!allowInexact) {
              this.raise(FlowErrors.InexactInsideExact, this.state.lastTokStartLoc);
            }
            if (variance) {
              this.raise(FlowErrors.InexactVariance, variance);
            }
            return null;
          }
          if (!allowSpread) {
            this.raise(FlowErrors.UnexpectedSpreadType, this.state.lastTokStartLoc);
          }
          if (protoStartLoc != null) {
            this.unexpected(protoStartLoc);
          }
          if (variance) {
            this.raise(FlowErrors.SpreadVariance, variance);
          }
          node.argument = this.flowParseType();
          return this.finishNode(node, "ObjectTypeSpreadProperty");
        } else {
          node.key = this.flowParseObjectPropertyKey();
          node.static = isStatic;
          node.proto = protoStartLoc != null;
          node.kind = kind;
          let optional = false;
          if (this.match(47) || this.match(10)) {
            node.method = true;
            if (protoStartLoc != null) {
              this.unexpected(protoStartLoc);
            }
            if (variance) {
              this.unexpected(variance.loc.start);
            }
            node.value = this.flowParseObjectTypeMethodish(this.startNodeAt(node.loc.start));
            if (kind === "get" || kind === "set") {
              this.flowCheckGetterSetterParams(node);
            }
            if (!allowSpread && node.key.name === "constructor" && node.value.this) {
              this.raise(FlowErrors.ThisParamBannedInConstructor, node.value.this);
            }
          } else {
            if (kind !== "init") this.unexpected();
            node.method = false;
            if (this.eat(17)) {
              optional = true;
            }
            node.value = this.flowParseTypeInitialiser();
            node.variance = variance;
          }
          node.optional = optional;
          return this.finishNode(node, "ObjectTypeProperty");
        }
      }
      flowCheckGetterSetterParams(property) {
        const paramCount = property.kind === "get" ? 0 : 1;
        const length = property.value.params.length + (property.value.rest ? 1 : 0);
        if (property.value.this) {
          this.raise(property.kind === "get" ? FlowErrors.GetterMayNotHaveThisParam : FlowErrors.SetterMayNotHaveThisParam, property.value.this);
        }
        if (length !== paramCount) {
          this.raise(property.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, property);
        }
        if (property.kind === "set" && property.value.rest) {
          this.raise(Errors.BadSetterRestParameter, property);
        }
      }
      flowObjectTypeSemicolon() {
        if (!this.eat(13) && !this.eat(12) && !this.match(8) && !this.match(9)) {
          this.unexpected();
        }
      }
      flowParseQualifiedTypeIdentifier(startLoc, id) {
        var _startLoc;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        let node = id || this.flowParseRestrictedIdentifier(true);
        while (this.eat(16)) {
          const node2 = this.startNodeAt(startLoc);
          node2.qualification = node;
          node2.id = this.flowParseRestrictedIdentifier(true);
          node = this.finishNode(node2, "QualifiedTypeIdentifier");
        }
        return node;
      }
      flowParseGenericType(startLoc, id) {
        const node = this.startNodeAt(startLoc);
        node.typeParameters = null;
        node.id = this.flowParseQualifiedTypeIdentifier(startLoc, id);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterInstantiation();
        }
        return this.finishNode(node, "GenericTypeAnnotation");
      }
      flowParseTypeofType() {
        const node = this.startNode();
        this.expect(87);
        node.argument = this.flowParsePrimaryType();
        return this.finishNode(node, "TypeofTypeAnnotation");
      }
      flowParseTupleType() {
        const node = this.startNode();
        node.types = [];
        this.expect(0);
        while (this.state.pos < this.length && !this.match(3)) {
          node.types.push(this.flowParseType());
          if (this.match(3)) break;
          this.expect(12);
        }
        this.expect(3);
        return this.finishNode(node, "TupleTypeAnnotation");
      }
      flowParseFunctionTypeParam(first) {
        let name = null;
        let optional = false;
        let typeAnnotation = null;
        const node = this.startNode();
        const lh = this.lookahead();
        const isThis = this.state.type === 78;
        if (lh.type === 14 || lh.type === 17) {
          if (isThis && !first) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node);
          }
          name = this.parseIdentifier(isThis);
          if (this.eat(17)) {
            optional = true;
            if (isThis) {
              this.raise(FlowErrors.ThisParamMayNotBeOptional, node);
            }
          }
          typeAnnotation = this.flowParseTypeInitialiser();
        } else {
          typeAnnotation = this.flowParseType();
        }
        node.name = name;
        node.optional = optional;
        node.typeAnnotation = typeAnnotation;
        return this.finishNode(node, "FunctionTypeParam");
      }
      reinterpretTypeAsFunctionTypeParam(type) {
        const node = this.startNodeAt(type.loc.start);
        node.name = null;
        node.optional = false;
        node.typeAnnotation = type;
        return this.finishNode(node, "FunctionTypeParam");
      }
      flowParseFunctionTypeParams(params = []) {
        let rest = null;
        let _this = null;
        if (this.match(78)) {
          _this = this.flowParseFunctionTypeParam(true);
          _this.name = null;
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        while (!this.match(11) && !this.match(21)) {
          params.push(this.flowParseFunctionTypeParam(false));
          if (!this.match(11)) {
            this.expect(12);
          }
        }
        if (this.eat(21)) {
          rest = this.flowParseFunctionTypeParam(false);
        }
        return {
          params,
          rest,
          _this
        };
      }
      flowIdentToTypeAnnotation(startLoc, node, id) {
        switch (id.name) {
          case "any":
            return this.finishNode(node, "AnyTypeAnnotation");
          case "bool":
          case "boolean":
            return this.finishNode(node, "BooleanTypeAnnotation");
          case "mixed":
            return this.finishNode(node, "MixedTypeAnnotation");
          case "empty":
            return this.finishNode(node, "EmptyTypeAnnotation");
          case "number":
            return this.finishNode(node, "NumberTypeAnnotation");
          case "string":
            return this.finishNode(node, "StringTypeAnnotation");
          case "symbol":
            return this.finishNode(node, "SymbolTypeAnnotation");
          default:
            this.checkNotUnderscore(id.name);
            return this.flowParseGenericType(startLoc, id);
        }
      }
      flowParsePrimaryType() {
        const startLoc = this.state.startLoc;
        const node = this.startNode();
        let tmp;
        let type;
        let isGroupedType = false;
        const oldNoAnonFunctionType = this.state.noAnonFunctionType;
        switch (this.state.type) {
          case 5:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: false,
              allowSpread: true,
              allowProto: false,
              allowInexact: true
            });
          case 6:
            return this.flowParseObjectType({
              allowStatic: false,
              allowExact: true,
              allowSpread: true,
              allowProto: false,
              allowInexact: false
            });
          case 0:
            this.state.noAnonFunctionType = false;
            type = this.flowParseTupleType();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            return type;
          case 47: {
            const node2 = this.startNode();
            node2.typeParameters = this.flowParseTypeParameterDeclaration();
            this.expect(10);
            tmp = this.flowParseFunctionTypeParams();
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 10: {
            const node2 = this.startNode();
            this.next();
            if (!this.match(11) && !this.match(21)) {
              if (tokenIsIdentifier(this.state.type) || this.match(78)) {
                const token = this.lookahead().type;
                isGroupedType = token !== 17 && token !== 14;
              } else {
                isGroupedType = true;
              }
            }
            if (isGroupedType) {
              this.state.noAnonFunctionType = false;
              type = this.flowParseType();
              this.state.noAnonFunctionType = oldNoAnonFunctionType;
              if (this.state.noAnonFunctionType || !(this.match(12) || this.match(11) && this.lookahead().type === 19)) {
                this.expect(11);
                return type;
              } else {
                this.eat(12);
              }
            }
            if (type) {
              tmp = this.flowParseFunctionTypeParams([this.reinterpretTypeAsFunctionTypeParam(type)]);
            } else {
              tmp = this.flowParseFunctionTypeParams();
            }
            node2.params = tmp.params;
            node2.rest = tmp.rest;
            node2.this = tmp._this;
            this.expect(11);
            this.expect(19);
            node2.returnType = this.flowParseType();
            node2.typeParameters = null;
            return this.finishNode(node2, "FunctionTypeAnnotation");
          }
          case 133:
            return this.parseLiteral(this.state.value, "StringLiteralTypeAnnotation");
          case 85:
          case 86:
            node.value = this.match(85);
            this.next();
            return this.finishNode(node, "BooleanLiteralTypeAnnotation");
          case 53:
            if (this.state.value === "-") {
              this.next();
              if (this.match(134)) {
                return this.parseLiteralAtNode(-this.state.value, "NumberLiteralTypeAnnotation", node);
              }
              if (this.match(135)) {
                return this.parseLiteralAtNode(-this.state.value, "BigIntLiteralTypeAnnotation", node);
              }
              throw this.raise(FlowErrors.UnexpectedSubtractionOperand, this.state.startLoc);
            }
            this.unexpected();
            return;
          case 134:
            return this.parseLiteral(this.state.value, "NumberLiteralTypeAnnotation");
          case 135:
            return this.parseLiteral(this.state.value, "BigIntLiteralTypeAnnotation");
          case 88:
            this.next();
            return this.finishNode(node, "VoidTypeAnnotation");
          case 84:
            this.next();
            return this.finishNode(node, "NullLiteralTypeAnnotation");
          case 78:
            this.next();
            return this.finishNode(node, "ThisTypeAnnotation");
          case 55:
            this.next();
            return this.finishNode(node, "ExistsTypeAnnotation");
          case 87:
            return this.flowParseTypeofType();
          default:
            if (tokenIsKeyword(this.state.type)) {
              const label = tokenLabelName(this.state.type);
              this.next();
              return super.createIdentifier(node, label);
            } else if (tokenIsIdentifier(this.state.type)) {
              if (this.isContextual(129)) {
                return this.flowParseInterfaceType();
              }
              return this.flowIdentToTypeAnnotation(startLoc, node, this.parseIdentifier());
            }
        }
        this.unexpected();
      }
      flowParsePostfixType() {
        const startLoc = this.state.startLoc;
        let type = this.flowParsePrimaryType();
        let seenOptionalIndexedAccess = false;
        while ((this.match(0) || this.match(18)) && !this.canInsertSemicolon()) {
          const node = this.startNodeAt(startLoc);
          const optional = this.eat(18);
          seenOptionalIndexedAccess = seenOptionalIndexedAccess || optional;
          this.expect(0);
          if (!optional && this.match(3)) {
            node.elementType = type;
            this.next();
            type = this.finishNode(node, "ArrayTypeAnnotation");
          } else {
            node.objectType = type;
            node.indexType = this.flowParseType();
            this.expect(3);
            if (seenOptionalIndexedAccess) {
              node.optional = optional;
              type = this.finishNode(node, "OptionalIndexedAccessType");
            } else {
              type = this.finishNode(node, "IndexedAccessType");
            }
          }
        }
        return type;
      }
      flowParsePrefixType() {
        const node = this.startNode();
        if (this.eat(17)) {
          node.typeAnnotation = this.flowParsePrefixType();
          return this.finishNode(node, "NullableTypeAnnotation");
        } else {
          return this.flowParsePostfixType();
        }
      }
      flowParseAnonFunctionWithoutParens() {
        const param = this.flowParsePrefixType();
        if (!this.state.noAnonFunctionType && this.eat(19)) {
          const node = this.startNodeAt(param.loc.start);
          node.params = [this.reinterpretTypeAsFunctionTypeParam(param)];
          node.rest = null;
          node.this = null;
          node.returnType = this.flowParseType();
          node.typeParameters = null;
          return this.finishNode(node, "FunctionTypeAnnotation");
        }
        return param;
      }
      flowParseIntersectionType() {
        const node = this.startNode();
        this.eat(45);
        const type = this.flowParseAnonFunctionWithoutParens();
        node.types = [type];
        while (this.eat(45)) {
          node.types.push(this.flowParseAnonFunctionWithoutParens());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "IntersectionTypeAnnotation");
      }
      flowParseUnionType() {
        const node = this.startNode();
        this.eat(43);
        const type = this.flowParseIntersectionType();
        node.types = [type];
        while (this.eat(43)) {
          node.types.push(this.flowParseIntersectionType());
        }
        return node.types.length === 1 ? type : this.finishNode(node, "UnionTypeAnnotation");
      }
      flowParseType() {
        const oldInType = this.state.inType;
        this.state.inType = true;
        const type = this.flowParseUnionType();
        this.state.inType = oldInType;
        return type;
      }
      flowParseTypeOrImplicitInstantiation() {
        if (this.state.type === 132 && this.state.value === "_") {
          const startLoc = this.state.startLoc;
          const node = this.parseIdentifier();
          return this.flowParseGenericType(startLoc, node);
        } else {
          return this.flowParseType();
        }
      }
      flowParseTypeAnnotation() {
        const node = this.startNode();
        node.typeAnnotation = this.flowParseTypeInitialiser();
        return this.finishNode(node, "TypeAnnotation");
      }
      flowParseTypeAnnotatableIdentifier(allowPrimitiveOverride) {
        const ident = allowPrimitiveOverride ? this.parseIdentifier() : this.flowParseRestrictedIdentifier();
        if (this.match(14)) {
          ident.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(ident);
        }
        return ident;
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      flowParseVariance() {
        let variance = null;
        if (this.match(53)) {
          variance = this.startNode();
          if (this.state.value === "+") {
            variance.kind = "plus";
          } else {
            variance.kind = "minus";
          }
          this.next();
          return this.finishNode(variance, "Variance");
        }
        return variance;
      }
      parseFunctionBody(node, allowExpressionBody, isMethod = false) {
        if (allowExpressionBody) {
          this.forwardNoArrowParamsConversionAt(node, () => super.parseFunctionBody(node, true, isMethod));
          return;
        }
        super.parseFunctionBody(node, false, isMethod);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          const typeNode = this.startNode();
          [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
          node.returnType = typeNode.typeAnnotation ? this.finishNode(typeNode, "TypeAnnotation") : null;
        }
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      parseStatementLike(flags) {
        if (this.state.strict && this.isContextual(129)) {
          const lookahead = this.lookahead();
          if (tokenIsKeywordOrIdentifier(lookahead.type)) {
            const node = this.startNode();
            this.next();
            return this.flowParseInterface(node);
          }
        } else if (this.shouldParseEnums() && this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        const stmt = super.parseStatementLike(flags);
        if (this.flowPragma === void 0 && !this.isValidDirective(stmt)) {
          this.flowPragma = null;
        }
        return stmt;
      }
      parseExpressionStatement(node, expr, decorators) {
        if (expr.type === "Identifier") {
          if (expr.name === "declare") {
            if (this.match(80) || tokenIsIdentifier(this.state.type) || this.match(68) || this.match(74) || this.match(82)) {
              return this.flowParseDeclare(node);
            }
          } else if (tokenIsIdentifier(this.state.type)) {
            if (expr.name === "interface") {
              return this.flowParseInterface(node);
            } else if (expr.name === "type") {
              return this.flowParseTypeAlias(node);
            } else if (expr.name === "opaque") {
              return this.flowParseOpaqueType(node, false);
            }
          }
        }
        return super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
          return !this.state.containsEsc;
        }
        return super.shouldParseExportDeclaration();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsFlowInterfaceOrTypeOrOpaque(type) || this.shouldParseEnums() && type === 126) {
          return this.state.containsEsc;
        }
        return super.isExportDefaultSpecifier();
      }
      parseExportDefaultExpression() {
        if (this.shouldParseEnums() && this.isContextual(126)) {
          const node = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(node);
        }
        return super.parseExportDefaultExpression();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.match(17)) return expr;
        if (this.state.maybeInArrowParameters) {
          const nextCh = this.lookaheadCharCode();
          if (nextCh === 44 || nextCh === 61 || nextCh === 58 || nextCh === 41) {
            this.setOptionalParametersError(refExpressionErrors);
            return expr;
          }
        }
        this.expect(17);
        const state = this.state.clone();
        const originalNoArrowAt = this.state.noArrowAt;
        const node = this.startNodeAt(startLoc);
        let {
          consequent,
          failed
        } = this.tryParseConditionalConsequent();
        let [valid, invalid] = this.getArrowLikeExpressions(consequent);
        if (failed || invalid.length > 0) {
          const noArrowAt = [...originalNoArrowAt];
          if (invalid.length > 0) {
            this.state = state;
            this.state.noArrowAt = noArrowAt;
            for (let i = 0; i < invalid.length; i++) {
              noArrowAt.push(invalid[i].start);
            }
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
            [valid, invalid] = this.getArrowLikeExpressions(consequent);
          }
          if (failed && valid.length > 1) {
            this.raise(FlowErrors.AmbiguousConditionalArrow, state.startLoc);
          }
          if (failed && valid.length === 1) {
            this.state = state;
            noArrowAt.push(valid[0].start);
            this.state.noArrowAt = noArrowAt;
            ({
              consequent,
              failed
            } = this.tryParseConditionalConsequent());
          }
        }
        this.getArrowLikeExpressions(consequent, true);
        this.state.noArrowAt = originalNoArrowAt;
        this.expect(14);
        node.test = expr;
        node.consequent = consequent;
        node.alternate = this.forwardNoArrowParamsConversionAt(node, () => this.parseMaybeAssign(void 0, void 0));
        return this.finishNode(node, "ConditionalExpression");
      }
      tryParseConditionalConsequent() {
        this.state.noArrowParamsConversionAt.push(this.state.start);
        const consequent = this.parseMaybeAssignAllowIn();
        const failed = !this.match(14);
        this.state.noArrowParamsConversionAt.pop();
        return {
          consequent,
          failed
        };
      }
      getArrowLikeExpressions(node, disallowInvalid) {
        const stack = [node];
        const arrows = [];
        while (stack.length !== 0) {
          const node2 = stack.pop();
          if (node2.type === "ArrowFunctionExpression" && node2.body.type !== "BlockStatement") {
            if (node2.typeParameters || !node2.returnType) {
              this.finishArrowValidation(node2);
            } else {
              arrows.push(node2);
            }
            stack.push(node2.body);
          } else if (node2.type === "ConditionalExpression") {
            stack.push(node2.consequent);
            stack.push(node2.alternate);
          }
        }
        if (disallowInvalid) {
          arrows.forEach((node2) => this.finishArrowValidation(node2));
          return [arrows, []];
        }
        return partition(arrows, (node2) => node2.params.every((param) => this.isAssignable(param, true)));
      }
      finishArrowValidation(node) {
        var _node$extra;
        this.toAssignableList(node.params, (_node$extra = node.extra) == null ? void 0 : _node$extra.trailingCommaLoc, false);
        this.scope.enter(2 | 4);
        super.checkParams(node, false, true);
        this.scope.exit();
      }
      forwardNoArrowParamsConversionAt(node, parse2) {
        let result;
        if (this.state.noArrowParamsConversionAt.includes(node.start)) {
          this.state.noArrowParamsConversionAt.push(this.state.start);
          result = parse2();
          this.state.noArrowParamsConversionAt.pop();
        } else {
          result = parse2();
        }
        return result;
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = newNode;
          typeCastNode.typeAnnotation = this.flowParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TypeCastExpression");
        }
        return newNode;
      }
      assertModuleNodeAllowed(node) {
        if (node.type === "ImportDeclaration" && (node.importKind === "type" || node.importKind === "typeof") || node.type === "ExportNamedDeclaration" && node.exportKind === "type" || node.type === "ExportAllDeclaration" && node.exportKind === "type") {
          return;
        }
        super.assertModuleNodeAllowed(node);
      }
      parseExportDeclaration(node) {
        if (this.isContextual(130)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          if (this.match(5)) {
            node.specifiers = this.parseExportSpecifiers(true);
            super.parseExportFrom(node);
            return null;
          } else {
            return this.flowParseTypeAlias(declarationNode);
          }
        } else if (this.isContextual(131)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseOpaqueType(declarationNode, false);
        } else if (this.isContextual(129)) {
          node.exportKind = "type";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseInterface(declarationNode);
        } else if (this.shouldParseEnums() && this.isContextual(126)) {
          node.exportKind = "value";
          const declarationNode = this.startNode();
          this.next();
          return this.flowParseEnumDeclaration(declarationNode);
        } else {
          return super.parseExportDeclaration(node);
        }
      }
      eatExportStar(node) {
        if (super.eatExportStar(node)) return true;
        if (this.isContextual(130) && this.lookahead().type === 55) {
          node.exportKind = "type";
          this.next();
          this.next();
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        const {
          startLoc
        } = this.state;
        const hasNamespace = super.maybeParseExportNamespaceSpecifier(node);
        if (hasNamespace && node.exportKind === "type") {
          this.unexpected(startLoc);
        }
        return hasNamespace;
      }
      parseClassId(node, isStatement, optionalId) {
        super.parseClassId(node, isStatement, optionalId);
        if (this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
      }
      parseClassMember(classBody, member, state) {
        const {
          startLoc
        } = this.state;
        if (this.isContextual(125)) {
          if (super.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          member.declare = true;
        }
        super.parseClassMember(classBody, member, state);
        if (member.declare) {
          if (member.type !== "ClassProperty" && member.type !== "ClassPrivateProperty" && member.type !== "PropertyDefinition") {
            this.raise(FlowErrors.DeclareClassElement, startLoc);
          } else if (member.value) {
            this.raise(FlowErrors.DeclareClassFieldInitializer, member.value);
          }
        }
      }
      isIterator(word) {
        return word === "iterator" || word === "asyncIterator";
      }
      readIterator() {
        const word = super.readWord1();
        const fullWord = "@@" + word;
        if (!this.isIterator(word) || !this.state.inType) {
          this.raise(Errors.InvalidIdentifier, this.state.curPosition(), {
            identifierName: fullWord
          });
        }
        this.finishToken(132, fullWord);
      }
      getTokenFromCode(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 123 && next === 124) {
          this.finishOp(6, 2);
        } else if (this.state.inType && (code2 === 62 || code2 === 60)) {
          this.finishOp(code2 === 62 ? 48 : 47, 1);
        } else if (this.state.inType && code2 === 63) {
          if (next === 46) {
            this.finishOp(18, 2);
          } else {
            this.finishOp(17, 1);
          }
        } else if (isIteratorStart(code2, next, this.input.charCodeAt(this.state.pos + 2))) {
          this.state.pos += 2;
          this.readIterator();
        } else {
          super.getTokenFromCode(code2);
        }
      }
      isAssignable(node, isBinding) {
        if (node.type === "TypeCastExpression") {
          return this.isAssignable(node.expression, isBinding);
        } else {
          return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        if (!isLHS && node.type === "AssignmentExpression" && node.left.type === "TypeCastExpression") {
          node.left = this.typeCastToParameter(node.left);
        }
        super.toAssignable(node, isLHS);
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        for (let i = 0; i < exprList.length; i++) {
          var _expr$extra;
          const expr = exprList[i];
          if (expr && expr.type === "TypeCastExpression" && !((_expr$extra = expr.extra) != null && _expr$extra.parenthesized) && (exprList.length > 1 || !isParenthesizedExpr)) {
            this.raise(FlowErrors.TypeCastInPattern, expr.typeAnnotation);
          }
        }
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (canBePattern && !this.state.maybeInArrowParameters) {
          this.toReferencedList(node.elements);
        }
        return node;
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "TypeCastExpression" || super.isValidLVal(type, isParenthesized, binding);
      }
      parseClassProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (this.match(14)) {
          node.typeAnnotation = this.flowParseTypeAnnotation();
        }
        return super.parseClassPrivateProperty(node);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(14) || super.isClassProperty();
      }
      isNonstaticConstructor(method) {
        return !this.match(14) && super.isNonstaticConstructor(method);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
        if (method.params && isConstructor) {
          const params = method.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        } else if (method.type === "MethodDefinition" && isConstructor && method.value.params) {
          const params = method.value.params;
          if (params.length > 0 && this.isThisParam(params[0])) {
            this.raise(FlowErrors.ThisParamBannedInConstructor, method);
          }
        }
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        if (method.variance) {
          this.unexpected(method.variance.loc.start);
        }
        delete method.variance;
        if (this.match(47)) {
          method.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && this.match(47)) {
          node.superTypeParameters = this.flowParseTypeParameterInstantiation();
        }
        if (this.isContextual(113)) {
          this.next();
          const implemented = node.implements = [];
          do {
            const node2 = this.startNode();
            node2.id = this.flowParseRestrictedIdentifier(true);
            if (this.match(47)) {
              node2.typeParameters = this.flowParseTypeParameterInstantiation();
            } else {
              node2.typeParameters = null;
            }
            implemented.push(this.finishNode(node2, "ClassImplements"));
          } while (this.eat(12));
        }
      }
      checkGetterSetterParams(method) {
        super.checkGetterSetterParams(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length > 0) {
          const param = params[0];
          if (this.isThisParam(param) && method.kind === "get") {
            this.raise(FlowErrors.GetterMayNotHaveThisParam, param);
          } else if (this.isThisParam(param)) {
            this.raise(FlowErrors.SetterMayNotHaveThisParam, param);
          }
        }
      }
      parsePropertyNamePrefixOperator(node) {
        node.variance = this.flowParseVariance();
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        if (prop.variance) {
          this.unexpected(prop.variance.loc.start);
        }
        delete prop.variance;
        let typeParameters;
        if (this.match(47) && !isAccessor) {
          typeParameters = this.flowParseTypeParameterDeclaration();
          if (!this.match(10)) this.unexpected();
        }
        const result = super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
        if (typeParameters) {
          (result.value || result).typeParameters = typeParameters;
        }
        return result;
      }
      parseAssignableListItemTypes(param) {
        if (this.eat(17)) {
          if (param.type !== "Identifier") {
            this.raise(FlowErrors.PatternIsOptional, param);
          }
          if (this.isThisParam(param)) {
            this.raise(FlowErrors.ThisParamMayNotBeOptional, param);
          }
          param.optional = true;
        }
        if (this.match(14)) {
          param.typeAnnotation = this.flowParseTypeAnnotation();
        } else if (this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamAnnotationRequired, param);
        }
        if (this.match(29) && this.isThisParam(param)) {
          this.raise(FlowErrors.ThisParamNoDefault, param);
        }
        this.resetEndLocation(param);
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(FlowErrors.TypeBeforeInitializer, node.typeAnnotation);
        }
        return node;
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(FlowErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = hasTypeImportKind(node) ? this.flowParseRestrictedIdentifier(true, true) : this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          if (!isExport) return true;
          const ch = this.lookaheadCharCode();
          return ch === 123 || ch === 42;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          if (!phase && this.match(65)) {
            return;
          }
          node.exportKind = phase === "type" ? phase : "value";
        } else {
          if (phase === "type" && this.match(55)) this.unexpected();
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        const firstIdent = specifier.imported;
        let specifierTypeKind = null;
        if (firstIdent.type === "Identifier") {
          if (firstIdent.name === "type") {
            specifierTypeKind = "type";
          } else if (firstIdent.name === "typeof") {
            specifierTypeKind = "typeof";
          }
        }
        let isBinding = false;
        if (this.isContextual(93) && !this.isLookaheadContextual("as")) {
          const as_ident = this.parseIdentifier(true);
          if (specifierTypeKind !== null && !tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = as_ident;
            specifier.importKind = specifierTypeKind;
            specifier.local = cloneIdentifier(as_ident);
          } else {
            specifier.imported = firstIdent;
            specifier.importKind = null;
            specifier.local = this.parseIdentifier();
          }
        } else {
          if (specifierTypeKind !== null && tokenIsKeywordOrIdentifier(this.state.type)) {
            specifier.imported = this.parseIdentifier(true);
            specifier.importKind = specifierTypeKind;
          } else {
            if (importedIsString) {
              throw this.raise(Errors.ImportBindingIsString, specifier, {
                importName: firstIdent.value
              });
            }
            specifier.imported = firstIdent;
            specifier.importKind = null;
          }
          if (this.eatContextual(93)) {
            specifier.local = this.parseIdentifier();
          } else {
            isBinding = true;
            specifier.local = cloneIdentifier(specifier.imported);
          }
        }
        const specifierIsTypeImport = hasTypeImportKind(specifier);
        if (isInTypeOnlyImport && specifierIsTypeImport) {
          this.raise(FlowErrors.ImportTypeShorthandOnlyInPureImport, specifier);
        }
        if (isInTypeOnlyImport || specifierIsTypeImport) {
          this.checkReservedType(specifier.local.name, specifier.local.loc.start, true);
        }
        if (isBinding && !isInTypeOnlyImport && !specifierIsTypeImport) {
          this.checkReservedWord(specifier.local.name, specifier.loc.start, true, true);
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 78:
            return this.parseIdentifier(true);
          default:
            return super.parseBindingAtom();
        }
      }
      parseFunctionParams(node, isConstructor) {
        const kind = node.kind;
        if (kind !== "get" && kind !== "set" && this.match(47)) {
          node.typeParameters = this.flowParseTypeParameterDeclaration();
        }
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (this.match(14)) {
          decl.id.typeAnnotation = this.flowParseTypeAnnotation();
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          const oldNoAnonFunctionType = this.state.noAnonFunctionType;
          this.state.noAnonFunctionType = true;
          node.returnType = this.flowParseTypeAnnotation();
          this.state.noAnonFunctionType = oldNoAnonFunctionType;
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx;
        let state = null;
        let jsx2;
        if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if ((_jsx = jsx2) != null && _jsx.error || this.match(47)) {
          var _jsx2, _jsx3;
          state = state || this.state.clone();
          let typeParameters;
          const arrow = this.tryParse((abort) => {
            var _arrowExpression$extr;
            typeParameters = this.flowParseTypeParameterDeclaration();
            const arrowExpression2 = this.forwardNoArrowParamsConversionAt(typeParameters, () => {
              const result = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
              this.resetStartLocationFromNode(result, typeParameters);
              return result;
            });
            if ((_arrowExpression$extr = arrowExpression2.extra) != null && _arrowExpression$extr.parenthesized) abort();
            const expr = this.maybeUnwrapTypeCastExpression(arrowExpression2);
            if (expr.type !== "ArrowFunctionExpression") abort();
            expr.typeParameters = typeParameters;
            this.resetStartLocationFromNode(expr, typeParameters);
            return arrowExpression2;
          }, state);
          let arrowExpression = null;
          if (arrow.node && this.maybeUnwrapTypeCastExpression(arrow.node).type === "ArrowFunctionExpression") {
            if (!arrow.error && !arrow.aborted) {
              if (arrow.node.async) {
                this.raise(FlowErrors.UnexpectedTypeParameterBeforeAsyncArrowFunction, typeParameters);
              }
              return arrow.node;
            }
            arrowExpression = arrow.node;
          }
          if ((_jsx2 = jsx2) != null && _jsx2.node) {
            this.state = jsx2.failState;
            return jsx2.node;
          }
          if (arrowExpression) {
            this.state = arrow.failState;
            return arrowExpression;
          }
          if ((_jsx3 = jsx2) != null && _jsx3.thrown) throw jsx2.error;
          if (arrow.thrown) throw arrow.error;
          throw this.raise(FlowErrors.UnexpectedTokenAfterTypeParameter, typeParameters);
        }
        return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse(() => {
            const oldNoAnonFunctionType = this.state.noAnonFunctionType;
            this.state.noAnonFunctionType = true;
            const typeNode = this.startNode();
            [typeNode.typeAnnotation, node.predicate] = this.flowParseTypeAndPredicateInitialiser();
            this.state.noAnonFunctionType = oldNoAnonFunctionType;
            if (this.canInsertSemicolon()) this.unexpected();
            if (!this.match(19)) this.unexpected();
            return typeNode;
          });
          if (result.thrown) return null;
          if (result.error) this.state = result.failState;
          node.returnType = result.node.typeAnnotation ? this.finishNode(result.node, "TypeAnnotation") : null;
        }
        return super.parseArrow(node);
      }
      shouldParseArrow(params) {
        return this.match(14) || super.shouldParseArrow(params);
      }
      setArrowFunctionParameters(node, params) {
        if (this.state.noArrowParamsConversionAt.includes(node.start)) {
          node.params = params;
        } else {
          super.setArrowFunctionParameters(node, params);
        }
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        if (isArrowFunction && this.state.noArrowParamsConversionAt.includes(node.start)) {
          return;
        }
        for (let i = 0; i < node.params.length; i++) {
          if (this.isThisParam(node.params[i]) && i > 0) {
            this.raise(FlowErrors.ThisParamMustBeFirst, node.params[i]);
          }
        }
        super.checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged);
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        return super.parseParenAndDistinguishExpression(canBeArrow && !this.state.noArrowAt.includes(this.state.start));
      }
      parseSubscripts(base, startLoc, noCalls) {
        if (base.type === "Identifier" && base.name === "async" && this.state.noArrowAt.includes(startLoc.index)) {
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.arguments = super.parseCallExpressionArguments(11, false);
          base = this.finishNode(node, "CallExpression");
        } else if (base.type === "Identifier" && base.name === "async" && this.match(47)) {
          const state = this.state.clone();
          const arrow = this.tryParse((abort) => this.parseAsyncArrowWithTypeParameters(startLoc) || abort(), state);
          if (!arrow.error && !arrow.aborted) return arrow.node;
          const result = this.tryParse(() => super.parseSubscripts(base, startLoc, noCalls), state);
          if (result.node && !result.error) return result.node;
          if (arrow.node) {
            this.state = arrow.failState;
            return arrow.node;
          }
          if (result.node) {
            this.state = result.failState;
            return result.node;
          }
          throw arrow.error || result.error;
        }
        return super.parseSubscripts(base, startLoc, noCalls);
      }
      parseSubscript(base, startLoc, noCalls, subscriptState) {
        if (this.match(18) && this.isLookaheadToken_lt()) {
          subscriptState.optionalChainMember = true;
          if (noCalls) {
            subscriptState.stop = true;
            return base;
          }
          this.next();
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          node.typeArguments = this.flowParseTypeParameterInstantiation();
          this.expect(10);
          node.arguments = this.parseCallExpressionArguments(11, false);
          node.optional = true;
          return this.finishCallExpression(node, true);
        } else if (!noCalls && this.shouldParseTypes() && this.match(47)) {
          const node = this.startNodeAt(startLoc);
          node.callee = base;
          const result = this.tryParse(() => {
            node.typeArguments = this.flowParseTypeParameterInstantiationCallOrNew();
            this.expect(10);
            node.arguments = super.parseCallExpressionArguments(11, false);
            if (subscriptState.optionalChainMember) {
              node.optional = false;
            }
            return this.finishCallExpression(node, subscriptState.optionalChainMember);
          });
          if (result.node) {
            if (result.error) this.state = result.failState;
            return result.node;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, subscriptState);
      }
      parseNewCallee(node) {
        super.parseNewCallee(node);
        let targs = null;
        if (this.shouldParseTypes() && this.match(47)) {
          targs = this.tryParse(() => this.flowParseTypeParameterInstantiationCallOrNew()).node;
        }
        node.typeArguments = targs;
      }
      parseAsyncArrowWithTypeParameters(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.parseFunctionParams(node, false);
        if (!this.parseArrow(node)) return;
        return super.parseArrowExpression(node, void 0, true);
      }
      readToken_mult_modulo(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 42 && next === 47 && this.state.hasFlowComment) {
          this.state.hasFlowComment = false;
          this.state.pos += 2;
          this.nextToken();
          return;
        }
        super.readToken_mult_modulo(code2);
      }
      readToken_pipe_amp(code2) {
        const next = this.input.charCodeAt(this.state.pos + 1);
        if (code2 === 124 && next === 125) {
          this.finishOp(9, 2);
          return;
        }
        super.readToken_pipe_amp(code2);
      }
      parseTopLevel(file, program) {
        const fileNode = super.parseTopLevel(file, program);
        if (this.state.hasFlowComment) {
          this.raise(FlowErrors.UnterminatedFlowComment, this.state.curPosition());
        }
        return fileNode;
      }
      skipBlockComment() {
        if (this.hasPlugin("flowComments") && this.skipFlowComment()) {
          if (this.state.hasFlowComment) {
            throw this.raise(FlowErrors.NestedFlowComment, this.state.startLoc);
          }
          this.hasFlowCommentCompletion();
          const commentSkip = this.skipFlowComment();
          if (commentSkip) {
            this.state.pos += commentSkip;
            this.state.hasFlowComment = true;
          }
          return;
        }
        return super.skipBlockComment(this.state.hasFlowComment ? "*-/" : "*/");
      }
      skipFlowComment() {
        const {
          pos
        } = this.state;
        let shiftToFirstNonWhiteSpace = 2;
        while ([32, 9].includes(this.input.charCodeAt(pos + shiftToFirstNonWhiteSpace))) {
          shiftToFirstNonWhiteSpace++;
        }
        const ch2 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos);
        const ch3 = this.input.charCodeAt(shiftToFirstNonWhiteSpace + pos + 1);
        if (ch2 === 58 && ch3 === 58) {
          return shiftToFirstNonWhiteSpace + 2;
        }
        if (this.input.slice(shiftToFirstNonWhiteSpace + pos, shiftToFirstNonWhiteSpace + pos + 12) === "flow-include") {
          return shiftToFirstNonWhiteSpace + 12;
        }
        if (ch2 === 58 && ch3 !== 58) {
          return shiftToFirstNonWhiteSpace;
        }
        return false;
      }
      hasFlowCommentCompletion() {
        const end = this.input.indexOf("*/", this.state.pos);
        if (end === -1) {
          throw this.raise(Errors.UnterminatedComment, this.state.curPosition());
        }
      }
      flowEnumErrorBooleanMemberNotInitialized(loc, {
        enumName,
        memberName
      }) {
        this.raise(FlowErrors.EnumBooleanMemberNotInitialized, loc, {
          memberName,
          enumName
        });
      }
      flowEnumErrorInvalidMemberInitializer(loc, enumContext) {
        return this.raise(!enumContext.explicitType ? FlowErrors.EnumInvalidMemberInitializerUnknownType : enumContext.explicitType === "symbol" ? FlowErrors.EnumInvalidMemberInitializerSymbolType : FlowErrors.EnumInvalidMemberInitializerPrimaryType, loc, enumContext);
      }
      flowEnumErrorNumberMemberNotInitialized(loc, details) {
        this.raise(FlowErrors.EnumNumberMemberNotInitialized, loc, details);
      }
      flowEnumErrorStringMemberInconsistentlyInitialized(node, details) {
        this.raise(FlowErrors.EnumStringMemberInconsistentlyInitialized, node, details);
      }
      flowEnumMemberInit() {
        const startLoc = this.state.startLoc;
        const endOfInit = () => this.match(12) || this.match(8);
        switch (this.state.type) {
          case 134: {
            const literal = this.parseNumericLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "number",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 133: {
            const literal = this.parseStringLiteral(this.state.value);
            if (endOfInit()) {
              return {
                type: "string",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          case 85:
          case 86: {
            const literal = this.parseBooleanLiteral(this.match(85));
            if (endOfInit()) {
              return {
                type: "boolean",
                loc: literal.loc.start,
                value: literal
              };
            }
            return {
              type: "invalid",
              loc: startLoc
            };
          }
          default:
            return {
              type: "invalid",
              loc: startLoc
            };
        }
      }
      flowEnumMemberRaw() {
        const loc = this.state.startLoc;
        const id = this.parseIdentifier(true);
        const init = this.eat(29) ? this.flowEnumMemberInit() : {
          type: "none",
          loc
        };
        return {
          id,
          init
        };
      }
      flowEnumCheckExplicitTypeMismatch(loc, context, expectedType) {
        const {
          explicitType
        } = context;
        if (explicitType === null) {
          return;
        }
        if (explicitType !== expectedType) {
          this.flowEnumErrorInvalidMemberInitializer(loc, context);
        }
      }
      flowEnumMembers({
        enumName,
        explicitType
      }) {
        const seenNames = /* @__PURE__ */ new Set();
        const members = {
          booleanMembers: [],
          numberMembers: [],
          stringMembers: [],
          defaultedMembers: []
        };
        let hasUnknownMembers = false;
        while (!this.match(8)) {
          if (this.eat(21)) {
            hasUnknownMembers = true;
            break;
          }
          const memberNode = this.startNode();
          const {
            id,
            init
          } = this.flowEnumMemberRaw();
          const memberName = id.name;
          if (memberName === "") {
            continue;
          }
          if (/^[a-z]/.test(memberName)) {
            this.raise(FlowErrors.EnumInvalidMemberName, id, {
              memberName,
              suggestion: memberName[0].toUpperCase() + memberName.slice(1),
              enumName
            });
          }
          if (seenNames.has(memberName)) {
            this.raise(FlowErrors.EnumDuplicateMemberName, id, {
              memberName,
              enumName
            });
          }
          seenNames.add(memberName);
          const context = {
            enumName,
            explicitType,
            memberName
          };
          memberNode.id = id;
          switch (init.type) {
            case "boolean": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "boolean");
              memberNode.init = init.value;
              members.booleanMembers.push(this.finishNode(memberNode, "EnumBooleanMember"));
              break;
            }
            case "number": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "number");
              memberNode.init = init.value;
              members.numberMembers.push(this.finishNode(memberNode, "EnumNumberMember"));
              break;
            }
            case "string": {
              this.flowEnumCheckExplicitTypeMismatch(init.loc, context, "string");
              memberNode.init = init.value;
              members.stringMembers.push(this.finishNode(memberNode, "EnumStringMember"));
              break;
            }
            case "invalid": {
              throw this.flowEnumErrorInvalidMemberInitializer(init.loc, context);
            }
            case "none": {
              switch (explicitType) {
                case "boolean":
                  this.flowEnumErrorBooleanMemberNotInitialized(init.loc, context);
                  break;
                case "number":
                  this.flowEnumErrorNumberMemberNotInitialized(init.loc, context);
                  break;
                default:
                  members.defaultedMembers.push(this.finishNode(memberNode, "EnumDefaultedMember"));
              }
            }
          }
          if (!this.match(8)) {
            this.expect(12);
          }
        }
        return {
          members,
          hasUnknownMembers
        };
      }
      flowEnumStringMembers(initializedMembers, defaultedMembers, {
        enumName
      }) {
        if (initializedMembers.length === 0) {
          return defaultedMembers;
        } else if (defaultedMembers.length === 0) {
          return initializedMembers;
        } else if (defaultedMembers.length > initializedMembers.length) {
          for (const member of initializedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return defaultedMembers;
        } else {
          for (const member of defaultedMembers) {
            this.flowEnumErrorStringMemberInconsistentlyInitialized(member, {
              enumName
            });
          }
          return initializedMembers;
        }
      }
      flowEnumParseExplicitType({
        enumName
      }) {
        if (!this.eatContextual(102)) return null;
        if (!tokenIsIdentifier(this.state.type)) {
          throw this.raise(FlowErrors.EnumInvalidExplicitTypeUnknownSupplied, this.state.startLoc, {
            enumName
          });
        }
        const {
          value
        } = this.state;
        this.next();
        if (value !== "boolean" && value !== "number" && value !== "string" && value !== "symbol") {
          this.raise(FlowErrors.EnumInvalidExplicitType, this.state.startLoc, {
            enumName,
            invalidEnumType: value
          });
        }
        return value;
      }
      flowEnumBody(node, id) {
        const enumName = id.name;
        const nameLoc = id.loc.start;
        const explicitType = this.flowEnumParseExplicitType({
          enumName
        });
        this.expect(5);
        const {
          members,
          hasUnknownMembers
        } = this.flowEnumMembers({
          enumName,
          explicitType
        });
        node.hasUnknownMembers = hasUnknownMembers;
        switch (explicitType) {
          case "boolean":
            node.explicitType = true;
            node.members = members.booleanMembers;
            this.expect(8);
            return this.finishNode(node, "EnumBooleanBody");
          case "number":
            node.explicitType = true;
            node.members = members.numberMembers;
            this.expect(8);
            return this.finishNode(node, "EnumNumberBody");
          case "string":
            node.explicitType = true;
            node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
              enumName
            });
            this.expect(8);
            return this.finishNode(node, "EnumStringBody");
          case "symbol":
            node.members = members.defaultedMembers;
            this.expect(8);
            return this.finishNode(node, "EnumSymbolBody");
          default: {
            const empty = () => {
              node.members = [];
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            };
            node.explicitType = false;
            const boolsLen = members.booleanMembers.length;
            const numsLen = members.numberMembers.length;
            const strsLen = members.stringMembers.length;
            const defaultedLen = members.defaultedMembers.length;
            if (!boolsLen && !numsLen && !strsLen && !defaultedLen) {
              return empty();
            } else if (!boolsLen && !numsLen) {
              node.members = this.flowEnumStringMembers(members.stringMembers, members.defaultedMembers, {
                enumName
              });
              this.expect(8);
              return this.finishNode(node, "EnumStringBody");
            } else if (!numsLen && !strsLen && boolsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorBooleanMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.booleanMembers;
              this.expect(8);
              return this.finishNode(node, "EnumBooleanBody");
            } else if (!boolsLen && !strsLen && numsLen >= defaultedLen) {
              for (const member of members.defaultedMembers) {
                this.flowEnumErrorNumberMemberNotInitialized(member.loc.start, {
                  enumName,
                  memberName: member.id.name
                });
              }
              node.members = members.numberMembers;
              this.expect(8);
              return this.finishNode(node, "EnumNumberBody");
            } else {
              this.raise(FlowErrors.EnumInconsistentMemberValues, nameLoc, {
                enumName
              });
              return empty();
            }
          }
        }
      }
      flowParseEnumDeclaration(node) {
        const id = this.parseIdentifier();
        node.id = id;
        node.body = this.flowEnumBody(this.startNode(), id);
        return this.finishNode(node, "EnumDeclaration");
      }
      isLookaheadToken_lt() {
        const next = this.nextTokenStart();
        if (this.input.charCodeAt(next) === 60) {
          const afterNext = this.input.charCodeAt(next + 1);
          return afterNext !== 60 && afterNext !== 61;
        }
        return false;
      }
      maybeUnwrapTypeCastExpression(node) {
        return node.type === "TypeCastExpression" ? node.expression : node;
      }
    };
    var entities = {
      __proto__: null,
      quot: '"',
      amp: "&",
      apos: "'",
      lt: "<",
      gt: ">",
      nbsp: "\xA0",
      iexcl: "\xA1",
      cent: "\xA2",
      pound: "\xA3",
      curren: "\xA4",
      yen: "\xA5",
      brvbar: "\xA6",
      sect: "\xA7",
      uml: "\xA8",
      copy: "\xA9",
      ordf: "\xAA",
      laquo: "\xAB",
      not: "\xAC",
      shy: "\xAD",
      reg: "\xAE",
      macr: "\xAF",
      deg: "\xB0",
      plusmn: "\xB1",
      sup2: "\xB2",
      sup3: "\xB3",
      acute: "\xB4",
      micro: "\xB5",
      para: "\xB6",
      middot: "\xB7",
      cedil: "\xB8",
      sup1: "\xB9",
      ordm: "\xBA",
      raquo: "\xBB",
      frac14: "\xBC",
      frac12: "\xBD",
      frac34: "\xBE",
      iquest: "\xBF",
      Agrave: "\xC0",
      Aacute: "\xC1",
      Acirc: "\xC2",
      Atilde: "\xC3",
      Auml: "\xC4",
      Aring: "\xC5",
      AElig: "\xC6",
      Ccedil: "\xC7",
      Egrave: "\xC8",
      Eacute: "\xC9",
      Ecirc: "\xCA",
      Euml: "\xCB",
      Igrave: "\xCC",
      Iacute: "\xCD",
      Icirc: "\xCE",
      Iuml: "\xCF",
      ETH: "\xD0",
      Ntilde: "\xD1",
      Ograve: "\xD2",
      Oacute: "\xD3",
      Ocirc: "\xD4",
      Otilde: "\xD5",
      Ouml: "\xD6",
      times: "\xD7",
      Oslash: "\xD8",
      Ugrave: "\xD9",
      Uacute: "\xDA",
      Ucirc: "\xDB",
      Uuml: "\xDC",
      Yacute: "\xDD",
      THORN: "\xDE",
      szlig: "\xDF",
      agrave: "\xE0",
      aacute: "\xE1",
      acirc: "\xE2",
      atilde: "\xE3",
      auml: "\xE4",
      aring: "\xE5",
      aelig: "\xE6",
      ccedil: "\xE7",
      egrave: "\xE8",
      eacute: "\xE9",
      ecirc: "\xEA",
      euml: "\xEB",
      igrave: "\xEC",
      iacute: "\xED",
      icirc: "\xEE",
      iuml: "\xEF",
      eth: "\xF0",
      ntilde: "\xF1",
      ograve: "\xF2",
      oacute: "\xF3",
      ocirc: "\xF4",
      otilde: "\xF5",
      ouml: "\xF6",
      divide: "\xF7",
      oslash: "\xF8",
      ugrave: "\xF9",
      uacute: "\xFA",
      ucirc: "\xFB",
      uuml: "\xFC",
      yacute: "\xFD",
      thorn: "\xFE",
      yuml: "\xFF",
      OElig: "\u0152",
      oelig: "\u0153",
      Scaron: "\u0160",
      scaron: "\u0161",
      Yuml: "\u0178",
      fnof: "\u0192",
      circ: "\u02C6",
      tilde: "\u02DC",
      Alpha: "\u0391",
      Beta: "\u0392",
      Gamma: "\u0393",
      Delta: "\u0394",
      Epsilon: "\u0395",
      Zeta: "\u0396",
      Eta: "\u0397",
      Theta: "\u0398",
      Iota: "\u0399",
      Kappa: "\u039A",
      Lambda: "\u039B",
      Mu: "\u039C",
      Nu: "\u039D",
      Xi: "\u039E",
      Omicron: "\u039F",
      Pi: "\u03A0",
      Rho: "\u03A1",
      Sigma: "\u03A3",
      Tau: "\u03A4",
      Upsilon: "\u03A5",
      Phi: "\u03A6",
      Chi: "\u03A7",
      Psi: "\u03A8",
      Omega: "\u03A9",
      alpha: "\u03B1",
      beta: "\u03B2",
      gamma: "\u03B3",
      delta: "\u03B4",
      epsilon: "\u03B5",
      zeta: "\u03B6",
      eta: "\u03B7",
      theta: "\u03B8",
      iota: "\u03B9",
      kappa: "\u03BA",
      lambda: "\u03BB",
      mu: "\u03BC",
      nu: "\u03BD",
      xi: "\u03BE",
      omicron: "\u03BF",
      pi: "\u03C0",
      rho: "\u03C1",
      sigmaf: "\u03C2",
      sigma: "\u03C3",
      tau: "\u03C4",
      upsilon: "\u03C5",
      phi: "\u03C6",
      chi: "\u03C7",
      psi: "\u03C8",
      omega: "\u03C9",
      thetasym: "\u03D1",
      upsih: "\u03D2",
      piv: "\u03D6",
      ensp: "\u2002",
      emsp: "\u2003",
      thinsp: "\u2009",
      zwnj: "\u200C",
      zwj: "\u200D",
      lrm: "\u200E",
      rlm: "\u200F",
      ndash: "\u2013",
      mdash: "\u2014",
      lsquo: "\u2018",
      rsquo: "\u2019",
      sbquo: "\u201A",
      ldquo: "\u201C",
      rdquo: "\u201D",
      bdquo: "\u201E",
      dagger: "\u2020",
      Dagger: "\u2021",
      bull: "\u2022",
      hellip: "\u2026",
      permil: "\u2030",
      prime: "\u2032",
      Prime: "\u2033",
      lsaquo: "\u2039",
      rsaquo: "\u203A",
      oline: "\u203E",
      frasl: "\u2044",
      euro: "\u20AC",
      image: "\u2111",
      weierp: "\u2118",
      real: "\u211C",
      trade: "\u2122",
      alefsym: "\u2135",
      larr: "\u2190",
      uarr: "\u2191",
      rarr: "\u2192",
      darr: "\u2193",
      harr: "\u2194",
      crarr: "\u21B5",
      lArr: "\u21D0",
      uArr: "\u21D1",
      rArr: "\u21D2",
      dArr: "\u21D3",
      hArr: "\u21D4",
      forall: "\u2200",
      part: "\u2202",
      exist: "\u2203",
      empty: "\u2205",
      nabla: "\u2207",
      isin: "\u2208",
      notin: "\u2209",
      ni: "\u220B",
      prod: "\u220F",
      sum: "\u2211",
      minus: "\u2212",
      lowast: "\u2217",
      radic: "\u221A",
      prop: "\u221D",
      infin: "\u221E",
      ang: "\u2220",
      and: "\u2227",
      or: "\u2228",
      cap: "\u2229",
      cup: "\u222A",
      int: "\u222B",
      there4: "\u2234",
      sim: "\u223C",
      cong: "\u2245",
      asymp: "\u2248",
      ne: "\u2260",
      equiv: "\u2261",
      le: "\u2264",
      ge: "\u2265",
      sub: "\u2282",
      sup: "\u2283",
      nsub: "\u2284",
      sube: "\u2286",
      supe: "\u2287",
      oplus: "\u2295",
      otimes: "\u2297",
      perp: "\u22A5",
      sdot: "\u22C5",
      lceil: "\u2308",
      rceil: "\u2309",
      lfloor: "\u230A",
      rfloor: "\u230B",
      lang: "\u2329",
      rang: "\u232A",
      loz: "\u25CA",
      spades: "\u2660",
      clubs: "\u2663",
      hearts: "\u2665",
      diams: "\u2666"
    };
    var JsxErrors = ParseErrorEnum`jsx`({
      AttributeIsEmpty: "JSX attributes must only be assigned a non-empty expression.",
      MissingClosingTagElement: ({
        openingTagName
      }) => `Expected corresponding JSX closing tag for <${openingTagName}>.`,
      MissingClosingTagFragment: "Expected corresponding JSX closing tag for <>.",
      UnexpectedSequenceExpression: "Sequence expressions cannot be directly nested inside JSX. Did you mean to wrap it in parentheses (...)?",
      UnexpectedToken: ({
        unexpected,
        HTMLEntity
      }) => `Unexpected token \`${unexpected}\`. Did you mean \`${HTMLEntity}\` or \`{'${unexpected}'}\`?`,
      UnsupportedJsxValue: "JSX value should be either an expression or a quoted JSX text.",
      UnterminatedJsxContent: "Unterminated JSX contents.",
      UnwrappedAdjacentJSXElements: "Adjacent JSX elements must be wrapped in an enclosing tag. Did you want a JSX fragment <>...</>?"
    });
    function isFragment(object) {
      return object ? object.type === "JSXOpeningFragment" || object.type === "JSXClosingFragment" : false;
    }
    function getQualifiedJSXName(object) {
      if (object.type === "JSXIdentifier") {
        return object.name;
      }
      if (object.type === "JSXNamespacedName") {
        return object.namespace.name + ":" + object.name.name;
      }
      if (object.type === "JSXMemberExpression") {
        return getQualifiedJSXName(object.object) + "." + getQualifiedJSXName(object.property);
      }
      throw new Error("Node had unexpected type: " + object.type);
    }
    var jsx = (superClass) => class JSXParserMixin extends superClass {
      jsxReadToken() {
        let out = "";
        let chunkStart = this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(JsxErrors.UnterminatedJsxContent, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          switch (ch) {
            case 60:
            case 123:
              if (this.state.pos === this.state.start) {
                if (ch === 60 && this.state.canStartJSXElement) {
                  ++this.state.pos;
                  this.finishToken(142);
                } else {
                  super.getTokenFromCode(ch);
                }
                return;
              }
              out += this.input.slice(chunkStart, this.state.pos);
              this.finishToken(141, out);
              return;
            case 38:
              out += this.input.slice(chunkStart, this.state.pos);
              out += this.jsxReadEntity();
              chunkStart = this.state.pos;
              break;
            case 62:
            case 125:
            default:
              if (isNewLine(ch)) {
                out += this.input.slice(chunkStart, this.state.pos);
                out += this.jsxReadNewLine(true);
                chunkStart = this.state.pos;
              } else {
                ++this.state.pos;
              }
          }
        }
      }
      jsxReadNewLine(normalizeCRLF) {
        const ch = this.input.charCodeAt(this.state.pos);
        let out;
        ++this.state.pos;
        if (ch === 13 && this.input.charCodeAt(this.state.pos) === 10) {
          ++this.state.pos;
          out = normalizeCRLF ? "\n" : "\r\n";
        } else {
          out = String.fromCharCode(ch);
        }
        ++this.state.curLine;
        this.state.lineStart = this.state.pos;
        return out;
      }
      jsxReadString(quote) {
        let out = "";
        let chunkStart = ++this.state.pos;
        for (; ; ) {
          if (this.state.pos >= this.length) {
            throw this.raise(Errors.UnterminatedString, this.state.startLoc);
          }
          const ch = this.input.charCodeAt(this.state.pos);
          if (ch === quote) break;
          if (ch === 38) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadEntity();
            chunkStart = this.state.pos;
          } else if (isNewLine(ch)) {
            out += this.input.slice(chunkStart, this.state.pos);
            out += this.jsxReadNewLine(false);
            chunkStart = this.state.pos;
          } else {
            ++this.state.pos;
          }
        }
        out += this.input.slice(chunkStart, this.state.pos++);
        this.finishToken(133, out);
      }
      jsxReadEntity() {
        const startPos = ++this.state.pos;
        if (this.codePointAtPos(this.state.pos) === 35) {
          ++this.state.pos;
          let radix = 10;
          if (this.codePointAtPos(this.state.pos) === 120) {
            radix = 16;
            ++this.state.pos;
          }
          const codePoint = this.readInt(radix, void 0, false, "bail");
          if (codePoint !== null && this.codePointAtPos(this.state.pos) === 59) {
            ++this.state.pos;
            return String.fromCodePoint(codePoint);
          }
        } else {
          let count = 0;
          let semi = false;
          while (count++ < 10 && this.state.pos < this.length && !(semi = this.codePointAtPos(this.state.pos) === 59)) {
            ++this.state.pos;
          }
          if (semi) {
            const desc = this.input.slice(startPos, this.state.pos);
            const entity = entities[desc];
            ++this.state.pos;
            if (entity) {
              return entity;
            }
          }
        }
        this.state.pos = startPos;
        return "&";
      }
      jsxReadWord() {
        let ch;
        const start = this.state.pos;
        do {
          ch = this.input.charCodeAt(++this.state.pos);
        } while (isIdentifierChar(ch) || ch === 45);
        this.finishToken(140, this.input.slice(start, this.state.pos));
      }
      jsxParseIdentifier() {
        const node = this.startNode();
        if (this.match(140)) {
          node.name = this.state.value;
        } else if (tokenIsKeyword(this.state.type)) {
          node.name = tokenLabelName(this.state.type);
        } else {
          this.unexpected();
        }
        this.next();
        return this.finishNode(node, "JSXIdentifier");
      }
      jsxParseNamespacedName() {
        const startLoc = this.state.startLoc;
        const name = this.jsxParseIdentifier();
        if (!this.eat(14)) return name;
        const node = this.startNodeAt(startLoc);
        node.namespace = name;
        node.name = this.jsxParseIdentifier();
        return this.finishNode(node, "JSXNamespacedName");
      }
      jsxParseElementName() {
        const startLoc = this.state.startLoc;
        let node = this.jsxParseNamespacedName();
        if (node.type === "JSXNamespacedName") {
          return node;
        }
        while (this.eat(16)) {
          const newNode = this.startNodeAt(startLoc);
          newNode.object = node;
          newNode.property = this.jsxParseIdentifier();
          node = this.finishNode(newNode, "JSXMemberExpression");
        }
        return node;
      }
      jsxParseAttributeValue() {
        let node;
        switch (this.state.type) {
          case 5:
            node = this.startNode();
            this.setContext(types.brace);
            this.next();
            node = this.jsxParseExpressionContainer(node, types.j_oTag);
            if (node.expression.type === "JSXEmptyExpression") {
              this.raise(JsxErrors.AttributeIsEmpty, node);
            }
            return node;
          case 142:
          case 133:
            return this.parseExprAtom();
          default:
            throw this.raise(JsxErrors.UnsupportedJsxValue, this.state.startLoc);
        }
      }
      jsxParseEmptyExpression() {
        const node = this.startNodeAt(this.state.lastTokEndLoc);
        return this.finishNodeAt(node, "JSXEmptyExpression", this.state.startLoc);
      }
      jsxParseSpreadChild(node) {
        this.next();
        node.expression = this.parseExpression();
        this.setContext(types.j_expr);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXSpreadChild");
      }
      jsxParseExpressionContainer(node, previousContext) {
        if (this.match(8)) {
          node.expression = this.jsxParseEmptyExpression();
        } else {
          const expression = this.parseExpression();
          node.expression = expression;
        }
        this.setContext(previousContext);
        this.state.canStartJSXElement = true;
        this.expect(8);
        return this.finishNode(node, "JSXExpressionContainer");
      }
      jsxParseAttribute() {
        const node = this.startNode();
        if (this.match(5)) {
          this.setContext(types.brace);
          this.next();
          this.expect(21);
          node.argument = this.parseMaybeAssignAllowIn();
          this.setContext(types.j_oTag);
          this.state.canStartJSXElement = true;
          this.expect(8);
          return this.finishNode(node, "JSXSpreadAttribute");
        }
        node.name = this.jsxParseNamespacedName();
        node.value = this.eat(29) ? this.jsxParseAttributeValue() : null;
        return this.finishNode(node, "JSXAttribute");
      }
      jsxParseOpeningElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(143)) {
          return this.finishNode(node, "JSXOpeningFragment");
        }
        node.name = this.jsxParseElementName();
        return this.jsxParseOpeningElementAfterName(node);
      }
      jsxParseOpeningElementAfterName(node) {
        const attributes = [];
        while (!this.match(56) && !this.match(143)) {
          attributes.push(this.jsxParseAttribute());
        }
        node.attributes = attributes;
        node.selfClosing = this.eat(56);
        this.expect(143);
        return this.finishNode(node, "JSXOpeningElement");
      }
      jsxParseClosingElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        if (this.eat(143)) {
          return this.finishNode(node, "JSXClosingFragment");
        }
        node.name = this.jsxParseElementName();
        this.expect(143);
        return this.finishNode(node, "JSXClosingElement");
      }
      jsxParseElementAt(startLoc) {
        const node = this.startNodeAt(startLoc);
        const children = [];
        const openingElement = this.jsxParseOpeningElementAt(startLoc);
        let closingElement = null;
        if (!openingElement.selfClosing) {
          contents: for (; ; ) {
            switch (this.state.type) {
              case 142:
                startLoc = this.state.startLoc;
                this.next();
                if (this.eat(56)) {
                  closingElement = this.jsxParseClosingElementAt(startLoc);
                  break contents;
                }
                children.push(this.jsxParseElementAt(startLoc));
                break;
              case 141:
                children.push(this.parseLiteral(this.state.value, "JSXText"));
                break;
              case 5: {
                const node2 = this.startNode();
                this.setContext(types.brace);
                this.next();
                if (this.match(21)) {
                  children.push(this.jsxParseSpreadChild(node2));
                } else {
                  children.push(this.jsxParseExpressionContainer(node2, types.j_expr));
                }
                break;
              }
              default:
                this.unexpected();
            }
          }
          if (isFragment(openingElement) && !isFragment(closingElement) && closingElement !== null) {
            this.raise(JsxErrors.MissingClosingTagFragment, closingElement);
          } else if (!isFragment(openingElement) && isFragment(closingElement)) {
            this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
              openingTagName: getQualifiedJSXName(openingElement.name)
            });
          } else if (!isFragment(openingElement) && !isFragment(closingElement)) {
            if (getQualifiedJSXName(closingElement.name) !== getQualifiedJSXName(openingElement.name)) {
              this.raise(JsxErrors.MissingClosingTagElement, closingElement, {
                openingTagName: getQualifiedJSXName(openingElement.name)
              });
            }
          }
        }
        if (isFragment(openingElement)) {
          node.openingFragment = openingElement;
          node.closingFragment = closingElement;
        } else {
          node.openingElement = openingElement;
          node.closingElement = closingElement;
        }
        node.children = children;
        if (this.match(47)) {
          throw this.raise(JsxErrors.UnwrappedAdjacentJSXElements, this.state.startLoc);
        }
        return isFragment(openingElement) ? this.finishNode(node, "JSXFragment") : this.finishNode(node, "JSXElement");
      }
      jsxParseElement() {
        const startLoc = this.state.startLoc;
        this.next();
        return this.jsxParseElementAt(startLoc);
      }
      setContext(newContext) {
        const {
          context
        } = this.state;
        context[context.length - 1] = newContext;
      }
      parseExprAtom(refExpressionErrors) {
        if (this.match(142)) {
          return this.jsxParseElement();
        } else if (this.match(47) && this.input.charCodeAt(this.state.pos) !== 33) {
          this.replaceToken(142);
          return this.jsxParseElement();
        } else {
          return super.parseExprAtom(refExpressionErrors);
        }
      }
      skipSpace() {
        const curContext = this.curContext();
        if (!curContext.preserveSpace) super.skipSpace();
      }
      getTokenFromCode(code2) {
        const context = this.curContext();
        if (context === types.j_expr) {
          this.jsxReadToken();
          return;
        }
        if (context === types.j_oTag || context === types.j_cTag) {
          if (isIdentifierStart(code2)) {
            this.jsxReadWord();
            return;
          }
          if (code2 === 62) {
            ++this.state.pos;
            this.finishToken(143);
            return;
          }
          if ((code2 === 34 || code2 === 39) && context === types.j_oTag) {
            this.jsxReadString(code2);
            return;
          }
        }
        if (code2 === 60 && this.state.canStartJSXElement && this.input.charCodeAt(this.state.pos + 1) !== 33) {
          ++this.state.pos;
          this.finishToken(142);
          return;
        }
        super.getTokenFromCode(code2);
      }
      updateContext(prevType) {
        const {
          context,
          type
        } = this.state;
        if (type === 56 && prevType === 142) {
          context.splice(-2, 2, types.j_cTag);
          this.state.canStartJSXElement = false;
        } else if (type === 142) {
          context.push(types.j_oTag);
        } else if (type === 143) {
          const out = context[context.length - 1];
          if (out === types.j_oTag && prevType === 56 || out === types.j_cTag) {
            context.pop();
            this.state.canStartJSXElement = context[context.length - 1] === types.j_expr;
          } else {
            this.setContext(types.j_expr);
            this.state.canStartJSXElement = true;
          }
        } else {
          this.state.canStartJSXElement = tokenComesBeforeExpression(type);
        }
      }
    };
    var TypeScriptScope = class extends Scope {
      constructor(...args) {
        super(...args);
        this.tsNames = /* @__PURE__ */ new Map();
      }
    };
    var TypeScriptScopeHandler = class extends ScopeHandler {
      constructor(...args) {
        super(...args);
        this.importsStack = [];
      }
      createScope(flags) {
        this.importsStack.push(/* @__PURE__ */ new Set());
        return new TypeScriptScope(flags);
      }
      enter(flags) {
        if (flags === 256) {
          this.importsStack.push(/* @__PURE__ */ new Set());
        }
        super.enter(flags);
      }
      exit() {
        const flags = super.exit();
        if (flags === 256) {
          this.importsStack.pop();
        }
        return flags;
      }
      hasImport(name, allowShadow) {
        const len = this.importsStack.length;
        if (this.importsStack[len - 1].has(name)) {
          return true;
        }
        if (!allowShadow && len > 1) {
          for (let i = 0; i < len - 1; i++) {
            if (this.importsStack[i].has(name)) return true;
          }
        }
        return false;
      }
      declareName(name, bindingType, loc) {
        if (bindingType & 4096) {
          if (this.hasImport(name, true)) {
            this.parser.raise(Errors.VarRedeclaration, loc, {
              identifierName: name
            });
          }
          this.importsStack[this.importsStack.length - 1].add(name);
          return;
        }
        const scope = this.currentScope();
        let type = scope.tsNames.get(name) || 0;
        if (bindingType & 1024) {
          this.maybeExportDefined(scope, name);
          scope.tsNames.set(name, type | 16);
          return;
        }
        super.declareName(name, bindingType, loc);
        if (bindingType & 2) {
          if (!(bindingType & 1)) {
            this.checkRedeclarationInScope(scope, name, bindingType, loc);
            this.maybeExportDefined(scope, name);
          }
          type = type | 1;
        }
        if (bindingType & 256) {
          type = type | 2;
        }
        if (bindingType & 512) {
          type = type | 4;
        }
        if (bindingType & 128) {
          type = type | 8;
        }
        if (type) scope.tsNames.set(name, type);
      }
      isRedeclaredInScope(scope, name, bindingType) {
        const type = scope.tsNames.get(name);
        if ((type & 2) > 0) {
          if (bindingType & 256) {
            const isConst = !!(bindingType & 512);
            const wasConst = (type & 4) > 0;
            return isConst !== wasConst;
          }
          return true;
        }
        if (bindingType & 128 && (type & 8) > 0) {
          if (scope.names.get(name) & 2) {
            return !!(bindingType & 1);
          } else {
            return false;
          }
        }
        if (bindingType & 2 && (type & 1) > 0) {
          return true;
        }
        return super.isRedeclaredInScope(scope, name, bindingType);
      }
      checkLocalExport(id) {
        const {
          name
        } = id;
        if (this.hasImport(name)) return;
        const len = this.scopeStack.length;
        for (let i = len - 1; i >= 0; i--) {
          const scope = this.scopeStack[i];
          const type = scope.tsNames.get(name);
          if ((type & 1) > 0 || (type & 16) > 0) {
            return;
          }
        }
        super.checkLocalExport(id);
      }
    };
    var getOwn$1 = (object, key) => hasOwnProperty.call(object, key) && object[key];
    var unwrapParenthesizedExpression = (node) => {
      return node.type === "ParenthesizedExpression" ? unwrapParenthesizedExpression(node.expression) : node;
    };
    var LValParser = class extends NodeUtils {
      toAssignable(node, isLHS = false) {
        var _node$extra, _node$extra3;
        let parenthesized = void 0;
        if (node.type === "ParenthesizedExpression" || (_node$extra = node.extra) != null && _node$extra.parenthesized) {
          parenthesized = unwrapParenthesizedExpression(node);
          if (isLHS) {
            if (parenthesized.type === "Identifier") {
              this.expressionScope.recordArrowParameterBindingError(Errors.InvalidParenthesizedAssignment, node);
            } else if (parenthesized.type !== "MemberExpression" && !this.isOptionalMemberExpression(parenthesized)) {
              this.raise(Errors.InvalidParenthesizedAssignment, node);
            }
          } else {
            this.raise(Errors.InvalidParenthesizedAssignment, node);
          }
        }
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            break;
          case "ObjectExpression":
            node.type = "ObjectPattern";
            for (let i = 0, length = node.properties.length, last = length - 1; i < length; i++) {
              var _node$extra2;
              const prop = node.properties[i];
              const isLast = i === last;
              this.toAssignableObjectExpressionProp(prop, isLast, isLHS);
              if (isLast && prop.type === "RestElement" && (_node$extra2 = node.extra) != null && _node$extra2.trailingCommaLoc) {
                this.raise(Errors.RestTrailingComma, node.extra.trailingCommaLoc);
              }
            }
            break;
          case "ObjectProperty": {
            const {
              key,
              value
            } = node;
            if (this.isPrivateName(key)) {
              this.classScope.usePrivateName(this.getPrivateNameSV(key), key.loc.start);
            }
            this.toAssignable(value, isLHS);
            break;
          }
          case "SpreadElement": {
            throw new Error("Internal @babel/parser error (this is a bug, please report it). SpreadElement should be converted by .toAssignable's caller.");
          }
          case "ArrayExpression":
            node.type = "ArrayPattern";
            this.toAssignableList(node.elements, (_node$extra3 = node.extra) == null ? void 0 : _node$extra3.trailingCommaLoc, isLHS);
            break;
          case "AssignmentExpression":
            if (node.operator !== "=") {
              this.raise(Errors.MissingEqInAssignment, node.left.loc.end);
            }
            node.type = "AssignmentPattern";
            delete node.operator;
            this.toAssignable(node.left, isLHS);
            break;
          case "ParenthesizedExpression":
            this.toAssignable(parenthesized, isLHS);
            break;
        }
      }
      toAssignableObjectExpressionProp(prop, isLast, isLHS) {
        if (prop.type === "ObjectMethod") {
          this.raise(prop.kind === "get" || prop.kind === "set" ? Errors.PatternHasAccessor : Errors.PatternHasMethod, prop.key);
        } else if (prop.type === "SpreadElement") {
          prop.type = "RestElement";
          const arg = prop.argument;
          this.checkToRestConversion(arg, false);
          this.toAssignable(arg, isLHS);
          if (!isLast) {
            this.raise(Errors.RestTrailingComma, prop);
          }
        } else {
          this.toAssignable(prop, isLHS);
        }
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        const end = exprList.length - 1;
        for (let i = 0; i <= end; i++) {
          const elt = exprList[i];
          if (!elt) continue;
          if (elt.type === "SpreadElement") {
            elt.type = "RestElement";
            const arg = elt.argument;
            this.checkToRestConversion(arg, true);
            this.toAssignable(arg, isLHS);
          } else {
            this.toAssignable(elt, isLHS);
          }
          if (elt.type === "RestElement") {
            if (i < end) {
              this.raise(Errors.RestTrailingComma, elt);
            } else if (trailingCommaLoc) {
              this.raise(Errors.RestTrailingComma, trailingCommaLoc);
            }
          }
        }
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "Identifier":
          case "ObjectPattern":
          case "ArrayPattern":
          case "AssignmentPattern":
          case "RestElement":
            return true;
          case "ObjectExpression": {
            const last = node.properties.length - 1;
            return node.properties.every((prop, i) => {
              return prop.type !== "ObjectMethod" && (i === last || prop.type !== "SpreadElement") && this.isAssignable(prop);
            });
          }
          case "ObjectProperty":
            return this.isAssignable(node.value);
          case "SpreadElement":
            return this.isAssignable(node.argument);
          case "ArrayExpression":
            return node.elements.every((element) => element === null || this.isAssignable(element));
          case "AssignmentExpression":
            return node.operator === "=";
          case "ParenthesizedExpression":
            return this.isAssignable(node.expression);
          case "MemberExpression":
          case "OptionalMemberExpression":
            return !isBinding;
          default:
            return false;
        }
      }
      toReferencedList(exprList, isParenthesizedExpr) {
        return exprList;
      }
      toReferencedListDeep(exprList, isParenthesizedExpr) {
        this.toReferencedList(exprList, isParenthesizedExpr);
        for (const expr of exprList) {
          if ((expr == null ? void 0 : expr.type) === "ArrayExpression") {
            this.toReferencedListDeep(expr.elements);
          }
        }
      }
      parseSpread(refExpressionErrors) {
        const node = this.startNode();
        this.next();
        node.argument = this.parseMaybeAssignAllowIn(refExpressionErrors, void 0);
        return this.finishNode(node, "SpreadElement");
      }
      parseRestBinding() {
        const node = this.startNode();
        this.next();
        node.argument = this.parseBindingAtom();
        return this.finishNode(node, "RestElement");
      }
      parseBindingAtom() {
        switch (this.state.type) {
          case 0: {
            const node = this.startNode();
            this.next();
            node.elements = this.parseBindingList(3, 93, 1);
            return this.finishNode(node, "ArrayPattern");
          }
          case 5:
            return this.parseObjectLike(8, true);
        }
        return this.parseIdentifier();
      }
      parseBindingList(close, closeCharCode, flags) {
        const allowEmpty = flags & 1;
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
          }
          if (allowEmpty && this.match(12)) {
            elts.push(null);
          } else if (this.eat(close)) {
            break;
          } else if (this.match(21)) {
            elts.push(this.parseAssignableListItemTypes(this.parseRestBinding(), flags));
            if (!this.checkCommaAfterRest(closeCharCode)) {
              this.expect(close);
              break;
            }
          } else {
            const decorators = [];
            if (this.match(26) && this.hasPlugin("decorators")) {
              this.raise(Errors.UnsupportedParameterDecorator, this.state.startLoc);
            }
            while (this.match(26)) {
              decorators.push(this.parseDecorator());
            }
            elts.push(this.parseAssignableListItem(flags, decorators));
          }
        }
        return elts;
      }
      parseBindingRestProperty(prop) {
        this.next();
        prop.argument = this.parseIdentifier();
        this.checkCommaAfterRest(125);
        return this.finishNode(prop, "RestElement");
      }
      parseBindingProperty() {
        const {
          type,
          startLoc
        } = this.state;
        if (type === 21) {
          return this.parseBindingRestProperty(this.startNode());
        }
        const prop = this.startNode();
        if (type === 138) {
          this.expectPlugin("destructuringPrivate", startLoc);
          this.classScope.usePrivateName(this.state.value, startLoc);
          prop.key = this.parsePrivateName();
        } else {
          this.parsePropertyName(prop);
        }
        prop.method = false;
        return this.parseObjPropValue(prop, startLoc, false, false, true, false);
      }
      parseAssignableListItem(flags, decorators) {
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left, flags);
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      parseAssignableListItemTypes(param, flags) {
        return param;
      }
      parseMaybeDefault(startLoc, left) {
        var _startLoc, _left;
        (_startLoc = startLoc) != null ? _startLoc : startLoc = this.state.startLoc;
        left = (_left = left) != null ? _left : this.parseBindingAtom();
        if (!this.eat(29)) return left;
        const node = this.startNodeAt(startLoc);
        node.left = left;
        node.right = this.parseMaybeAssignAllowIn();
        return this.finishNode(node, "AssignmentPattern");
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return getOwn$1({
          AssignmentPattern: "left",
          RestElement: "argument",
          ObjectProperty: "value",
          ParenthesizedExpression: "expression",
          ArrayPattern: "elements",
          ObjectPattern: "properties"
        }, type);
      }
      isOptionalMemberExpression(expression) {
        return expression.type === "OptionalMemberExpression";
      }
      checkLVal(expression, {
        in: ancestor,
        binding = 64,
        checkClashes = false,
        strictModeChanged = false,
        hasParenthesizedAncestor = false
      }) {
        var _expression$extra;
        const type = expression.type;
        if (this.isObjectMethod(expression)) return;
        const isOptionalMemberExpression = this.isOptionalMemberExpression(expression);
        if (isOptionalMemberExpression || type === "MemberExpression") {
          if (isOptionalMemberExpression) {
            this.expectPlugin("optionalChainingAssign", expression.loc.start);
            if (ancestor.type !== "AssignmentExpression") {
              this.raise(Errors.InvalidLhsOptionalChaining, expression, {
                ancestor
              });
            }
          }
          if (binding !== 64) {
            this.raise(Errors.InvalidPropertyBindingPattern, expression);
          }
          return;
        }
        if (type === "Identifier") {
          this.checkIdentifier(expression, binding, strictModeChanged);
          const {
            name
          } = expression;
          if (checkClashes) {
            if (checkClashes.has(name)) {
              this.raise(Errors.ParamDupe, expression);
            } else {
              checkClashes.add(name);
            }
          }
          return;
        }
        const validity = this.isValidLVal(type, !(hasParenthesizedAncestor || (_expression$extra = expression.extra) != null && _expression$extra.parenthesized) && ancestor.type === "AssignmentExpression", binding);
        if (validity === true) return;
        if (validity === false) {
          const ParseErrorClass = binding === 64 ? Errors.InvalidLhs : Errors.InvalidLhsBinding;
          this.raise(ParseErrorClass, expression, {
            ancestor
          });
          return;
        }
        const [key, isParenthesizedExpression] = Array.isArray(validity) ? validity : [validity, type === "ParenthesizedExpression"];
        const nextAncestor = type === "ArrayPattern" || type === "ObjectPattern" ? {
          type
        } : ancestor;
        for (const child of [].concat(expression[key])) {
          if (child) {
            this.checkLVal(child, {
              in: nextAncestor,
              binding,
              checkClashes,
              strictModeChanged,
              hasParenthesizedAncestor: isParenthesizedExpression
            });
          }
        }
      }
      checkIdentifier(at, bindingType, strictModeChanged = false) {
        if (this.state.strict && (strictModeChanged ? isStrictBindReservedWord(at.name, this.inModule) : isStrictBindOnlyReservedWord(at.name))) {
          if (bindingType === 64) {
            this.raise(Errors.StrictEvalArguments, at, {
              referenceName: at.name
            });
          } else {
            this.raise(Errors.StrictEvalArgumentsBinding, at, {
              bindingName: at.name
            });
          }
        }
        if (bindingType & 8192 && at.name === "let") {
          this.raise(Errors.LetInLexicalBinding, at);
        }
        if (!(bindingType & 64)) {
          this.declareNameFromIdentifier(at, bindingType);
        }
      }
      declareNameFromIdentifier(identifier, binding) {
        this.scope.declareName(identifier.name, binding, identifier.loc.start);
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.checkToRestConversion(node.expression, allowPattern);
            break;
          case "Identifier":
          case "MemberExpression":
            break;
          case "ArrayExpression":
          case "ObjectExpression":
            if (allowPattern) break;
          default:
            this.raise(Errors.InvalidRestAssignmentPattern, node);
        }
      }
      checkCommaAfterRest(close) {
        if (!this.match(12)) {
          return false;
        }
        this.raise(this.lookaheadCharCode() === close ? Errors.RestTrailingComma : Errors.ElementAfterRest, this.state.startLoc);
        return true;
      }
    };
    var getOwn = (object, key) => hasOwnProperty.call(object, key) && object[key];
    function nonNull(x) {
      if (x == null) {
        throw new Error(`Unexpected ${x} value.`);
      }
      return x;
    }
    function assert(x) {
      if (!x) {
        throw new Error("Assert fail");
      }
    }
    var TSErrors = ParseErrorEnum`typescript`({
      AbstractMethodHasImplementation: ({
        methodName
      }) => `Method '${methodName}' cannot have an implementation because it is marked abstract.`,
      AbstractPropertyHasInitializer: ({
        propertyName
      }) => `Property '${propertyName}' cannot have an initializer because it is marked abstract.`,
      AccesorCannotDeclareThisParameter: "'get' and 'set' accessors cannot declare 'this' parameters.",
      AccesorCannotHaveTypeParameters: "An accessor cannot have type parameters.",
      AccessorCannotBeOptional: "An 'accessor' property cannot be declared optional.",
      ClassMethodHasDeclare: "Class methods cannot have the 'declare' modifier.",
      ClassMethodHasReadonly: "Class methods cannot have the 'readonly' modifier.",
      ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference: "A 'const' initializer in an ambient context must be a string or numeric literal or literal enum reference.",
      ConstructorHasTypeParameters: "Type parameters cannot appear on a constructor declaration.",
      DeclareAccessor: ({
        kind
      }) => `'declare' is not allowed in ${kind}ters.`,
      DeclareClassFieldHasInitializer: "Initializers are not allowed in ambient contexts.",
      DeclareFunctionHasImplementation: "An implementation cannot be declared in ambient contexts.",
      DuplicateAccessibilityModifier: ({
        modifier
      }) => `Accessibility modifier already seen.`,
      DuplicateModifier: ({
        modifier
      }) => `Duplicate modifier: '${modifier}'.`,
      EmptyHeritageClauseType: ({
        token
      }) => `'${token}' list cannot be empty.`,
      EmptyTypeArguments: "Type argument list cannot be empty.",
      EmptyTypeParameters: "Type parameter list cannot be empty.",
      ExpectedAmbientAfterExportDeclare: "'export declare' must be followed by an ambient declaration.",
      ImportAliasHasImportType: "An import alias can not use 'import type'.",
      ImportReflectionHasImportType: "An `import module` declaration can not use `type` modifier",
      IncompatibleModifiers: ({
        modifiers
      }) => `'${modifiers[0]}' modifier cannot be used with '${modifiers[1]}' modifier.`,
      IndexSignatureHasAbstract: "Index signatures cannot have the 'abstract' modifier.",
      IndexSignatureHasAccessibility: ({
        modifier
      }) => `Index signatures cannot have an accessibility modifier ('${modifier}').`,
      IndexSignatureHasDeclare: "Index signatures cannot have the 'declare' modifier.",
      IndexSignatureHasOverride: "'override' modifier cannot appear on an index signature.",
      IndexSignatureHasStatic: "Index signatures cannot have the 'static' modifier.",
      InitializerNotAllowedInAmbientContext: "Initializers are not allowed in ambient contexts.",
      InvalidModifierOnTypeMember: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type member.`,
      InvalidModifierOnTypeParameter: ({
        modifier
      }) => `'${modifier}' modifier cannot appear on a type parameter.`,
      InvalidModifierOnTypeParameterPositions: ({
        modifier
      }) => `'${modifier}' modifier can only appear on a type parameter of a class, interface or type alias.`,
      InvalidModifiersOrder: ({
        orderedModifiers
      }) => `'${orderedModifiers[0]}' modifier must precede '${orderedModifiers[1]}' modifier.`,
      InvalidPropertyAccessAfterInstantiationExpression: "Invalid property access after an instantiation expression. You can either wrap the instantiation expression in parentheses, or delete the type arguments.",
      InvalidTupleMemberLabel: "Tuple members must be labeled with a simple identifier.",
      MissingInterfaceName: "'interface' declarations must be followed by an identifier.",
      NonAbstractClassHasAbstractMethod: "Abstract methods can only appear within an abstract class.",
      NonClassMethodPropertyHasAbstractModifer: "'abstract' modifier can only appear on a class, method, or property declaration.",
      OptionalTypeBeforeRequired: "A required element cannot follow an optional element.",
      OverrideNotInSubClass: "This member cannot have an 'override' modifier because its containing class does not extend another class.",
      PatternIsOptional: "A binding pattern parameter cannot be optional in an implementation signature.",
      PrivateElementHasAbstract: "Private elements cannot have the 'abstract' modifier.",
      PrivateElementHasAccessibility: ({
        modifier
      }) => `Private elements cannot have an accessibility modifier ('${modifier}').`,
      ReadonlyForMethodSignature: "'readonly' modifier can only appear on a property declaration or index signature.",
      ReservedArrowTypeParam: "This syntax is reserved in files with the .mts or .cts extension. Add a trailing comma, as in `<T,>() => ...`.",
      ReservedTypeAssertion: "This syntax is reserved in files with the .mts or .cts extension. Use an `as` expression instead.",
      SetAccesorCannotHaveOptionalParameter: "A 'set' accessor cannot have an optional parameter.",
      SetAccesorCannotHaveRestParameter: "A 'set' accessor cannot have rest parameter.",
      SetAccesorCannotHaveReturnType: "A 'set' accessor cannot have a return type annotation.",
      SingleTypeParameterWithoutTrailingComma: ({
        typeParameterName
      }) => `Single type parameter ${typeParameterName} should have a trailing comma. Example usage: <${typeParameterName},>.`,
      StaticBlockCannotHaveModifier: "Static class blocks cannot have any modifier.",
      TupleOptionalAfterType: "A labeled tuple optional element must be declared using a question mark after the name and before the colon (`name?: type`), rather than after the type (`name: type?`).",
      TypeAnnotationAfterAssign: "Type annotations must come before default assignments, e.g. instead of `age = 25: number` use `age: number = 25`.",
      TypeImportCannotSpecifyDefaultAndNamed: "A type-only import can specify a default import or named bindings, but not both.",
      TypeModifierIsUsedInTypeExports: "The 'type' modifier cannot be used on a named export when 'export type' is used on its export statement.",
      TypeModifierIsUsedInTypeImports: "The 'type' modifier cannot be used on a named import when 'import type' is used on its import statement.",
      UnexpectedParameterModifier: "A parameter property is only allowed in a constructor implementation.",
      UnexpectedReadonly: "'readonly' type modifier is only permitted on array and tuple literal types.",
      UnexpectedTypeAnnotation: "Did not expect a type annotation here.",
      UnexpectedTypeCastInParameter: "Unexpected type cast in parameter position.",
      UnsupportedImportTypeArgument: "Argument in a type import must be a string literal.",
      UnsupportedParameterPropertyKind: "A parameter property may not be declared using a binding pattern.",
      UnsupportedSignatureParameterKind: ({
        type
      }) => `Name in a signature must be an Identifier, ObjectPattern or ArrayPattern, instead got ${type}.`
    });
    function keywordTypeFromName(value) {
      switch (value) {
        case "any":
          return "TSAnyKeyword";
        case "boolean":
          return "TSBooleanKeyword";
        case "bigint":
          return "TSBigIntKeyword";
        case "never":
          return "TSNeverKeyword";
        case "number":
          return "TSNumberKeyword";
        case "object":
          return "TSObjectKeyword";
        case "string":
          return "TSStringKeyword";
        case "symbol":
          return "TSSymbolKeyword";
        case "undefined":
          return "TSUndefinedKeyword";
        case "unknown":
          return "TSUnknownKeyword";
        default:
          return void 0;
      }
    }
    function tsIsAccessModifier(modifier) {
      return modifier === "private" || modifier === "public" || modifier === "protected";
    }
    function tsIsVarianceAnnotations(modifier) {
      return modifier === "in" || modifier === "out";
    }
    var typescript = (superClass) => class TypeScriptParserMixin extends superClass {
      constructor(...args) {
        super(...args);
        this.tsParseInOutModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out"],
          disallowedModifiers: ["const", "public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
        this.tsParseConstModifier = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["const"],
          disallowedModifiers: ["in", "out"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        });
        this.tsParseInOutConstModifiers = this.tsParseModifiers.bind(this, {
          allowedModifiers: ["in", "out", "const"],
          disallowedModifiers: ["public", "private", "protected", "readonly", "declare", "abstract", "override"],
          errorTemplate: TSErrors.InvalidModifierOnTypeParameter
        });
      }
      getScopeHandler() {
        return TypeScriptScopeHandler;
      }
      tsIsIdentifier() {
        return tokenIsIdentifier(this.state.type);
      }
      tsTokenCanFollowModifier() {
        return (this.match(0) || this.match(5) || this.match(55) || this.match(21) || this.match(138) || this.isLiteralPropertyName()) && !this.hasPrecedingLineBreak();
      }
      tsNextTokenCanFollowModifier() {
        this.next();
        return this.tsTokenCanFollowModifier();
      }
      tsParseModifier(allowedModifiers, stopOnStartOfClassStaticBlock) {
        if (!tokenIsIdentifier(this.state.type) && this.state.type !== 58 && this.state.type !== 75) {
          return void 0;
        }
        const modifier = this.state.value;
        if (allowedModifiers.includes(modifier)) {
          if (stopOnStartOfClassStaticBlock && this.tsIsStartOfStaticBlocks()) {
            return void 0;
          }
          if (this.tsTryParse(this.tsNextTokenCanFollowModifier.bind(this))) {
            return modifier;
          }
        }
        return void 0;
      }
      tsParseModifiers({
        allowedModifiers,
        disallowedModifiers,
        stopOnStartOfClassStaticBlock,
        errorTemplate = TSErrors.InvalidModifierOnTypeMember
      }, modified) {
        const enforceOrder = (loc, modifier, before, after) => {
          if (modifier === before && modified[after]) {
            this.raise(TSErrors.InvalidModifiersOrder, loc, {
              orderedModifiers: [before, after]
            });
          }
        };
        const incompatible = (loc, modifier, mod1, mod2) => {
          if (modified[mod1] && modifier === mod2 || modified[mod2] && modifier === mod1) {
            this.raise(TSErrors.IncompatibleModifiers, loc, {
              modifiers: [mod1, mod2]
            });
          }
        };
        for (; ; ) {
          const {
            startLoc
          } = this.state;
          const modifier = this.tsParseModifier(allowedModifiers.concat(disallowedModifiers != null ? disallowedModifiers : []), stopOnStartOfClassStaticBlock);
          if (!modifier) break;
          if (tsIsAccessModifier(modifier)) {
            if (modified.accessibility) {
              this.raise(TSErrors.DuplicateAccessibilityModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, modifier, "override");
              enforceOrder(startLoc, modifier, modifier, "static");
              enforceOrder(startLoc, modifier, modifier, "readonly");
              modified.accessibility = modifier;
            }
          } else if (tsIsVarianceAnnotations(modifier)) {
            if (modified[modifier]) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            }
            modified[modifier] = true;
            enforceOrder(startLoc, modifier, "in", "out");
          } else {
            if (hasOwnProperty.call(modified, modifier)) {
              this.raise(TSErrors.DuplicateModifier, startLoc, {
                modifier
              });
            } else {
              enforceOrder(startLoc, modifier, "static", "readonly");
              enforceOrder(startLoc, modifier, "static", "override");
              enforceOrder(startLoc, modifier, "override", "readonly");
              enforceOrder(startLoc, modifier, "abstract", "override");
              incompatible(startLoc, modifier, "declare", "override");
              incompatible(startLoc, modifier, "static", "abstract");
            }
            modified[modifier] = true;
          }
          if (disallowedModifiers != null && disallowedModifiers.includes(modifier)) {
            this.raise(errorTemplate, startLoc, {
              modifier
            });
          }
        }
      }
      tsIsListTerminator(kind) {
        switch (kind) {
          case "EnumMembers":
          case "TypeMembers":
            return this.match(8);
          case "HeritageClauseElement":
            return this.match(5);
          case "TupleElementTypes":
            return this.match(3);
          case "TypeParametersOrArguments":
            return this.match(48);
        }
      }
      tsParseList(kind, parseElement) {
        const result = [];
        while (!this.tsIsListTerminator(kind)) {
          result.push(parseElement());
        }
        return result;
      }
      tsParseDelimitedList(kind, parseElement, refTrailingCommaPos) {
        return nonNull(this.tsParseDelimitedListWorker(kind, parseElement, true, refTrailingCommaPos));
      }
      tsParseDelimitedListWorker(kind, parseElement, expectSuccess, refTrailingCommaPos) {
        const result = [];
        let trailingCommaPos = -1;
        for (; ; ) {
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          trailingCommaPos = -1;
          const element = parseElement();
          if (element == null) {
            return void 0;
          }
          result.push(element);
          if (this.eat(12)) {
            trailingCommaPos = this.state.lastTokStartLoc.index;
            continue;
          }
          if (this.tsIsListTerminator(kind)) {
            break;
          }
          if (expectSuccess) {
            this.expect(12);
          }
          return void 0;
        }
        if (refTrailingCommaPos) {
          refTrailingCommaPos.value = trailingCommaPos;
        }
        return result;
      }
      tsParseBracketedList(kind, parseElement, bracket, skipFirstToken, refTrailingCommaPos) {
        if (!skipFirstToken) {
          if (bracket) {
            this.expect(0);
          } else {
            this.expect(47);
          }
        }
        const result = this.tsParseDelimitedList(kind, parseElement, refTrailingCommaPos);
        if (bracket) {
          this.expect(3);
        } else {
          this.expect(48);
        }
        return result;
      }
      tsParseImportType() {
        const node = this.startNode();
        this.expect(83);
        this.expect(10);
        if (!this.match(133)) {
          this.raise(TSErrors.UnsupportedImportTypeArgument, this.state.startLoc);
        }
        node.argument = super.parseExprAtom();
        if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          node.options = null;
        }
        if (this.eat(12)) {
          this.expectImportAttributesPlugin();
          if (!this.match(11)) {
            node.options = super.parseMaybeAssignAllowIn();
            this.eat(12);
          }
        }
        this.expect(11);
        if (this.eat(16)) {
          node.qualifier = this.tsParseEntityName();
        }
        if (this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSImportType");
      }
      tsParseEntityName(allowReservedWords = true) {
        let entity = this.parseIdentifier(allowReservedWords);
        while (this.eat(16)) {
          const node = this.startNodeAtNode(entity);
          node.left = entity;
          node.right = this.parseIdentifier(allowReservedWords);
          entity = this.finishNode(node, "TSQualifiedName");
        }
        return entity;
      }
      tsParseTypeReference() {
        const node = this.startNode();
        node.typeName = this.tsParseEntityName();
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeReference");
      }
      tsParseThisTypePredicate(lhs) {
        this.next();
        const node = this.startNodeAtNode(lhs);
        node.parameterName = lhs;
        node.typeAnnotation = this.tsParseTypeAnnotation(false);
        node.asserts = false;
        return this.finishNode(node, "TSTypePredicate");
      }
      tsParseThisTypeNode() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "TSThisType");
      }
      tsParseTypeQuery() {
        const node = this.startNode();
        this.expect(87);
        if (this.match(83)) {
          node.exprName = this.tsParseImportType();
        } else {
          node.exprName = this.tsParseEntityName();
        }
        if (!this.hasPrecedingLineBreak() && this.match(47)) {
          node.typeParameters = this.tsParseTypeArguments();
        }
        return this.finishNode(node, "TSTypeQuery");
      }
      tsParseTypeParameter(parseModifiers) {
        const node = this.startNode();
        parseModifiers(node);
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsEatThenParseType(81);
        node.default = this.tsEatThenParseType(29);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsTryParseTypeParameters(parseModifiers) {
        if (this.match(47)) {
          return this.tsParseTypeParameters(parseModifiers);
        }
      }
      tsParseTypeParameters(parseModifiers) {
        const node = this.startNode();
        if (this.match(47) || this.match(142)) {
          this.next();
        } else {
          this.unexpected();
        }
        const refTrailingCommaPos = {
          value: -1
        };
        node.params = this.tsParseBracketedList("TypeParametersOrArguments", this.tsParseTypeParameter.bind(this, parseModifiers), false, true, refTrailingCommaPos);
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeParameters, node);
        }
        if (refTrailingCommaPos.value !== -1) {
          this.addExtra(node, "trailingComma", refTrailingCommaPos.value);
        }
        return this.finishNode(node, "TSTypeParameterDeclaration");
      }
      tsFillSignature(returnToken, signature) {
        const returnTokenRequired = returnToken === 19;
        const paramsKey = "parameters";
        const returnTypeKey = "typeAnnotation";
        signature.typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        this.expect(10);
        signature[paramsKey] = this.tsParseBindingListForSignature();
        if (returnTokenRequired) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        } else if (this.match(returnToken)) {
          signature[returnTypeKey] = this.tsParseTypeOrTypePredicateAnnotation(returnToken);
        }
      }
      tsParseBindingListForSignature() {
        const list = super.parseBindingList(11, 41, 2);
        for (const pattern of list) {
          const {
            type
          } = pattern;
          if (type === "AssignmentPattern" || type === "TSParameterProperty") {
            this.raise(TSErrors.UnsupportedSignatureParameterKind, pattern, {
              type
            });
          }
        }
        return list;
      }
      tsParseTypeMemberSemicolon() {
        if (!this.eat(12) && !this.isLineTerminator()) {
          this.expect(13);
        }
      }
      tsParseSignatureMember(kind, node) {
        this.tsFillSignature(14, node);
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, kind);
      }
      tsIsUnambiguouslyIndexSignature() {
        this.next();
        if (tokenIsIdentifier(this.state.type)) {
          this.next();
          return this.match(14);
        }
        return false;
      }
      tsTryParseIndexSignature(node) {
        if (!(this.match(0) && this.tsLookAhead(this.tsIsUnambiguouslyIndexSignature.bind(this)))) {
          return;
        }
        this.expect(0);
        const id = this.parseIdentifier();
        id.typeAnnotation = this.tsParseTypeAnnotation();
        this.resetEndLocation(id);
        this.expect(3);
        node.parameters = [id];
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
        this.tsParseTypeMemberSemicolon();
        return this.finishNode(node, "TSIndexSignature");
      }
      tsParsePropertyOrMethodSignature(node, readonly) {
        if (this.eat(17)) node.optional = true;
        const nodeAny = node;
        if (this.match(10) || this.match(47)) {
          if (readonly) {
            this.raise(TSErrors.ReadonlyForMethodSignature, node);
          }
          const method = nodeAny;
          if (method.kind && this.match(47)) {
            this.raise(TSErrors.AccesorCannotHaveTypeParameters, this.state.curPosition());
          }
          this.tsFillSignature(14, method);
          this.tsParseTypeMemberSemicolon();
          const paramsKey = "parameters";
          const returnTypeKey = "typeAnnotation";
          if (method.kind === "get") {
            if (method[paramsKey].length > 0) {
              this.raise(Errors.BadGetterArity, this.state.curPosition());
              if (this.isThisParam(method[paramsKey][0])) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());
              }
            }
          } else if (method.kind === "set") {
            if (method[paramsKey].length !== 1) {
              this.raise(Errors.BadSetterArity, this.state.curPosition());
            } else {
              const firstParameter = method[paramsKey][0];
              if (this.isThisParam(firstParameter)) {
                this.raise(TSErrors.AccesorCannotDeclareThisParameter, this.state.curPosition());
              }
              if (firstParameter.type === "Identifier" && firstParameter.optional) {
                this.raise(TSErrors.SetAccesorCannotHaveOptionalParameter, this.state.curPosition());
              }
              if (firstParameter.type === "RestElement") {
                this.raise(TSErrors.SetAccesorCannotHaveRestParameter, this.state.curPosition());
              }
            }
            if (method[returnTypeKey]) {
              this.raise(TSErrors.SetAccesorCannotHaveReturnType, method[returnTypeKey]);
            }
          } else {
            method.kind = "method";
          }
          return this.finishNode(method, "TSMethodSignature");
        } else {
          const property = nodeAny;
          if (readonly) property.readonly = true;
          const type = this.tsTryParseTypeAnnotation();
          if (type) property.typeAnnotation = type;
          this.tsParseTypeMemberSemicolon();
          return this.finishNode(property, "TSPropertySignature");
        }
      }
      tsParseTypeMember() {
        const node = this.startNode();
        if (this.match(10) || this.match(47)) {
          return this.tsParseSignatureMember("TSCallSignatureDeclaration", node);
        }
        if (this.match(77)) {
          const id = this.startNode();
          this.next();
          if (this.match(10) || this.match(47)) {
            return this.tsParseSignatureMember("TSConstructSignatureDeclaration", node);
          } else {
            node.key = this.createIdentifier(id, "new");
            return this.tsParsePropertyOrMethodSignature(node, false);
          }
        }
        this.tsParseModifiers({
          allowedModifiers: ["readonly"],
          disallowedModifiers: ["declare", "abstract", "private", "protected", "public", "static", "override"]
        }, node);
        const idx = this.tsTryParseIndexSignature(node);
        if (idx) {
          return idx;
        }
        super.parsePropertyName(node);
        if (!node.computed && node.key.type === "Identifier" && (node.key.name === "get" || node.key.name === "set") && this.tsTokenCanFollowModifier()) {
          node.kind = node.key.name;
          super.parsePropertyName(node);
        }
        return this.tsParsePropertyOrMethodSignature(node, !!node.readonly);
      }
      tsParseTypeLiteral() {
        const node = this.startNode();
        node.members = this.tsParseObjectTypeMembers();
        return this.finishNode(node, "TSTypeLiteral");
      }
      tsParseObjectTypeMembers() {
        this.expect(5);
        const members = this.tsParseList("TypeMembers", this.tsParseTypeMember.bind(this));
        this.expect(8);
        return members;
      }
      tsIsStartOfMappedType() {
        this.next();
        if (this.eat(53)) {
          return this.isContextual(122);
        }
        if (this.isContextual(122)) {
          this.next();
        }
        if (!this.match(0)) {
          return false;
        }
        this.next();
        if (!this.tsIsIdentifier()) {
          return false;
        }
        this.next();
        return this.match(58);
      }
      tsParseMappedTypeParameter() {
        const node = this.startNode();
        node.name = this.tsParseTypeParameterName();
        node.constraint = this.tsExpectThenParseType(58);
        return this.finishNode(node, "TSTypeParameter");
      }
      tsParseMappedType() {
        const node = this.startNode();
        this.expect(5);
        if (this.match(53)) {
          node.readonly = this.state.value;
          this.next();
          this.expectContextual(122);
        } else if (this.eatContextual(122)) {
          node.readonly = true;
        }
        this.expect(0);
        node.typeParameter = this.tsParseMappedTypeParameter();
        node.nameType = this.eatContextual(93) ? this.tsParseType() : null;
        this.expect(3);
        if (this.match(53)) {
          node.optional = this.state.value;
          this.next();
          this.expect(17);
        } else if (this.eat(17)) {
          node.optional = true;
        }
        node.typeAnnotation = this.tsTryParseType();
        this.semicolon();
        this.expect(8);
        return this.finishNode(node, "TSMappedType");
      }
      tsParseTupleType() {
        const node = this.startNode();
        node.elementTypes = this.tsParseBracketedList("TupleElementTypes", this.tsParseTupleElementType.bind(this), true, false);
        let seenOptionalElement = false;
        node.elementTypes.forEach((elementNode) => {
          const {
            type
          } = elementNode;
          if (seenOptionalElement && type !== "TSRestType" && type !== "TSOptionalType" && !(type === "TSNamedTupleMember" && elementNode.optional)) {
            this.raise(TSErrors.OptionalTypeBeforeRequired, elementNode);
          }
          seenOptionalElement || (seenOptionalElement = type === "TSNamedTupleMember" && elementNode.optional || type === "TSOptionalType");
        });
        return this.finishNode(node, "TSTupleType");
      }
      tsParseTupleElementType() {
        const {
          startLoc
        } = this.state;
        const rest = this.eat(21);
        let labeled;
        let label;
        let optional;
        let type;
        const isWord = tokenIsKeywordOrIdentifier(this.state.type);
        const chAfterWord = isWord ? this.lookaheadCharCode() : null;
        if (chAfterWord === 58) {
          labeled = true;
          optional = false;
          label = this.parseIdentifier(true);
          this.expect(14);
          type = this.tsParseType();
        } else if (chAfterWord === 63) {
          optional = true;
          const startLoc2 = this.state.startLoc;
          const wordName = this.state.value;
          const typeOrLabel = this.tsParseNonArrayType();
          if (this.lookaheadCharCode() === 58) {
            labeled = true;
            label = this.createIdentifier(this.startNodeAt(startLoc2), wordName);
            this.expect(17);
            this.expect(14);
            type = this.tsParseType();
          } else {
            labeled = false;
            type = typeOrLabel;
            this.expect(17);
          }
        } else {
          type = this.tsParseType();
          optional = this.eat(17);
          labeled = this.eat(14);
        }
        if (labeled) {
          let labeledNode;
          if (label) {
            labeledNode = this.startNodeAtNode(label);
            labeledNode.optional = optional;
            labeledNode.label = label;
            labeledNode.elementType = type;
            if (this.eat(17)) {
              labeledNode.optional = true;
              this.raise(TSErrors.TupleOptionalAfterType, this.state.lastTokStartLoc);
            }
          } else {
            labeledNode = this.startNodeAtNode(type);
            labeledNode.optional = optional;
            this.raise(TSErrors.InvalidTupleMemberLabel, type);
            labeledNode.label = type;
            labeledNode.elementType = this.tsParseType();
          }
          type = this.finishNode(labeledNode, "TSNamedTupleMember");
        } else if (optional) {
          const optionalTypeNode = this.startNodeAtNode(type);
          optionalTypeNode.typeAnnotation = type;
          type = this.finishNode(optionalTypeNode, "TSOptionalType");
        }
        if (rest) {
          const restNode = this.startNodeAt(startLoc);
          restNode.typeAnnotation = type;
          type = this.finishNode(restNode, "TSRestType");
        }
        return type;
      }
      tsParseParenthesizedType() {
        const node = this.startNode();
        this.expect(10);
        node.typeAnnotation = this.tsParseType();
        this.expect(11);
        return this.finishNode(node, "TSParenthesizedType");
      }
      tsParseFunctionOrConstructorType(type, abstract) {
        const node = this.startNode();
        if (type === "TSConstructorType") {
          node.abstract = !!abstract;
          if (abstract) this.next();
          this.next();
        }
        this.tsInAllowConditionalTypesContext(() => this.tsFillSignature(19, node));
        return this.finishNode(node, type);
      }
      tsParseLiteralTypeNode() {
        const node = this.startNode();
        switch (this.state.type) {
          case 134:
          case 135:
          case 133:
          case 85:
          case 86:
            node.literal = super.parseExprAtom();
            break;
          default:
            this.unexpected();
        }
        return this.finishNode(node, "TSLiteralType");
      }
      tsParseTemplateLiteralType() {
        const node = this.startNode();
        node.literal = super.parseTemplate(false);
        return this.finishNode(node, "TSLiteralType");
      }
      parseTemplateSubstitution() {
        if (this.state.inType) return this.tsParseType();
        return super.parseTemplateSubstitution();
      }
      tsParseThisTypeOrThisTypePredicate() {
        const thisKeyword = this.tsParseThisTypeNode();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          return this.tsParseThisTypePredicate(thisKeyword);
        } else {
          return thisKeyword;
        }
      }
      tsParseNonArrayType() {
        switch (this.state.type) {
          case 133:
          case 134:
          case 135:
          case 85:
          case 86:
            return this.tsParseLiteralTypeNode();
          case 53:
            if (this.state.value === "-") {
              const node = this.startNode();
              const nextToken = this.lookahead();
              if (nextToken.type !== 134 && nextToken.type !== 135) {
                this.unexpected();
              }
              node.literal = this.parseMaybeUnary();
              return this.finishNode(node, "TSLiteralType");
            }
            break;
          case 78:
            return this.tsParseThisTypeOrThisTypePredicate();
          case 87:
            return this.tsParseTypeQuery();
          case 83:
            return this.tsParseImportType();
          case 5:
            return this.tsLookAhead(this.tsIsStartOfMappedType.bind(this)) ? this.tsParseMappedType() : this.tsParseTypeLiteral();
          case 0:
            return this.tsParseTupleType();
          case 10:
            return this.tsParseParenthesizedType();
          case 25:
          case 24:
            return this.tsParseTemplateLiteralType();
          default: {
            const {
              type
            } = this.state;
            if (tokenIsIdentifier(type) || type === 88 || type === 84) {
              const nodeType = type === 88 ? "TSVoidKeyword" : type === 84 ? "TSNullKeyword" : keywordTypeFromName(this.state.value);
              if (nodeType !== void 0 && this.lookaheadCharCode() !== 46) {
                const node = this.startNode();
                this.next();
                return this.finishNode(node, nodeType);
              }
              return this.tsParseTypeReference();
            }
          }
        }
        this.unexpected();
      }
      tsParseArrayTypeOrHigher() {
        let type = this.tsParseNonArrayType();
        while (!this.hasPrecedingLineBreak() && this.eat(0)) {
          if (this.match(3)) {
            const node = this.startNodeAtNode(type);
            node.elementType = type;
            this.expect(3);
            type = this.finishNode(node, "TSArrayType");
          } else {
            const node = this.startNodeAtNode(type);
            node.objectType = type;
            node.indexType = this.tsParseType();
            this.expect(3);
            type = this.finishNode(node, "TSIndexedAccessType");
          }
        }
        return type;
      }
      tsParseTypeOperator() {
        const node = this.startNode();
        const operator = this.state.value;
        this.next();
        node.operator = operator;
        node.typeAnnotation = this.tsParseTypeOperatorOrHigher();
        if (operator === "readonly") {
          this.tsCheckTypeAnnotationForReadOnly(node);
        }
        return this.finishNode(node, "TSTypeOperator");
      }
      tsCheckTypeAnnotationForReadOnly(node) {
        switch (node.typeAnnotation.type) {
          case "TSTupleType":
          case "TSArrayType":
            return;
          default:
            this.raise(TSErrors.UnexpectedReadonly, node);
        }
      }
      tsParseInferType() {
        const node = this.startNode();
        this.expectContextual(115);
        const typeParameter = this.startNode();
        typeParameter.name = this.tsParseTypeParameterName();
        typeParameter.constraint = this.tsTryParse(() => this.tsParseConstraintForInferType());
        node.typeParameter = this.finishNode(typeParameter, "TSTypeParameter");
        return this.finishNode(node, "TSInferType");
      }
      tsParseConstraintForInferType() {
        if (this.eat(81)) {
          const constraint = this.tsInDisallowConditionalTypesContext(() => this.tsParseType());
          if (this.state.inDisallowConditionalTypesContext || !this.match(17)) {
            return constraint;
          }
        }
      }
      tsParseTypeOperatorOrHigher() {
        const isTypeOperator = tokenIsTSTypeOperator(this.state.type) && !this.state.containsEsc;
        return isTypeOperator ? this.tsParseTypeOperator() : this.isContextual(115) ? this.tsParseInferType() : this.tsInAllowConditionalTypesContext(() => this.tsParseArrayTypeOrHigher());
      }
      tsParseUnionOrIntersectionType(kind, parseConstituentType, operator) {
        const node = this.startNode();
        const hasLeadingOperator = this.eat(operator);
        const types2 = [];
        do {
          types2.push(parseConstituentType());
        } while (this.eat(operator));
        if (types2.length === 1 && !hasLeadingOperator) {
          return types2[0];
        }
        node.types = types2;
        return this.finishNode(node, kind);
      }
      tsParseIntersectionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSIntersectionType", this.tsParseTypeOperatorOrHigher.bind(this), 45);
      }
      tsParseUnionTypeOrHigher() {
        return this.tsParseUnionOrIntersectionType("TSUnionType", this.tsParseIntersectionTypeOrHigher.bind(this), 43);
      }
      tsIsStartOfFunctionType() {
        if (this.match(47)) {
          return true;
        }
        return this.match(10) && this.tsLookAhead(this.tsIsUnambiguouslyStartOfFunctionType.bind(this));
      }
      tsSkipParameterStart() {
        if (tokenIsIdentifier(this.state.type) || this.match(78)) {
          this.next();
          return true;
        }
        if (this.match(5)) {
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            this.parseObjectLike(8, true);
            return errors.length === previousErrorCount;
          } catch (_unused) {
            return false;
          }
        }
        if (this.match(0)) {
          this.next();
          const {
            errors
          } = this.state;
          const previousErrorCount = errors.length;
          try {
            super.parseBindingList(3, 93, 1);
            return errors.length === previousErrorCount;
          } catch (_unused2) {
            return false;
          }
        }
        return false;
      }
      tsIsUnambiguouslyStartOfFunctionType() {
        this.next();
        if (this.match(11) || this.match(21)) {
          return true;
        }
        if (this.tsSkipParameterStart()) {
          if (this.match(14) || this.match(12) || this.match(17) || this.match(29)) {
            return true;
          }
          if (this.match(11)) {
            this.next();
            if (this.match(19)) {
              return true;
            }
          }
        }
        return false;
      }
      tsParseTypeOrTypePredicateAnnotation(returnToken) {
        return this.tsInType(() => {
          const t = this.startNode();
          this.expect(returnToken);
          const node = this.startNode();
          const asserts = !!this.tsTryParse(this.tsParseTypePredicateAsserts.bind(this));
          if (asserts && this.match(78)) {
            let thisTypePredicate = this.tsParseThisTypeOrThisTypePredicate();
            if (thisTypePredicate.type === "TSThisType") {
              node.parameterName = thisTypePredicate;
              node.asserts = true;
              node.typeAnnotation = null;
              thisTypePredicate = this.finishNode(node, "TSTypePredicate");
            } else {
              this.resetStartLocationFromNode(thisTypePredicate, node);
              thisTypePredicate.asserts = true;
            }
            t.typeAnnotation = thisTypePredicate;
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const typePredicateVariable = this.tsIsIdentifier() && this.tsTryParse(this.tsParseTypePredicatePrefix.bind(this));
          if (!typePredicateVariable) {
            if (!asserts) {
              return this.tsParseTypeAnnotation(false, t);
            }
            node.parameterName = this.parseIdentifier();
            node.asserts = asserts;
            node.typeAnnotation = null;
            t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
            return this.finishNode(t, "TSTypeAnnotation");
          }
          const type = this.tsParseTypeAnnotation(false);
          node.parameterName = typePredicateVariable;
          node.typeAnnotation = type;
          node.asserts = asserts;
          t.typeAnnotation = this.finishNode(node, "TSTypePredicate");
          return this.finishNode(t, "TSTypeAnnotation");
        });
      }
      tsTryParseTypeOrTypePredicateAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeOrTypePredicateAnnotation(14);
        }
      }
      tsTryParseTypeAnnotation() {
        if (this.match(14)) {
          return this.tsParseTypeAnnotation();
        }
      }
      tsTryParseType() {
        return this.tsEatThenParseType(14);
      }
      tsParseTypePredicatePrefix() {
        const id = this.parseIdentifier();
        if (this.isContextual(116) && !this.hasPrecedingLineBreak()) {
          this.next();
          return id;
        }
      }
      tsParseTypePredicateAsserts() {
        if (this.state.type !== 109) {
          return false;
        }
        const containsEsc = this.state.containsEsc;
        this.next();
        if (!tokenIsIdentifier(this.state.type) && !this.match(78)) {
          return false;
        }
        if (containsEsc) {
          this.raise(Errors.InvalidEscapedReservedWord, this.state.lastTokStartLoc, {
            reservedWord: "asserts"
          });
        }
        return true;
      }
      tsParseTypeAnnotation(eatColon = true, t = this.startNode()) {
        this.tsInType(() => {
          if (eatColon) this.expect(14);
          t.typeAnnotation = this.tsParseType();
        });
        return this.finishNode(t, "TSTypeAnnotation");
      }
      tsParseType() {
        assert(this.state.inType);
        const type = this.tsParseNonConditionalType();
        if (this.state.inDisallowConditionalTypesContext || this.hasPrecedingLineBreak() || !this.eat(81)) {
          return type;
        }
        const node = this.startNodeAtNode(type);
        node.checkType = type;
        node.extendsType = this.tsInDisallowConditionalTypesContext(() => this.tsParseNonConditionalType());
        this.expect(17);
        node.trueType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        this.expect(14);
        node.falseType = this.tsInAllowConditionalTypesContext(() => this.tsParseType());
        return this.finishNode(node, "TSConditionalType");
      }
      isAbstractConstructorSignature() {
        return this.isContextual(124) && this.lookahead().type === 77;
      }
      tsParseNonConditionalType() {
        if (this.tsIsStartOfFunctionType()) {
          return this.tsParseFunctionOrConstructorType("TSFunctionType");
        }
        if (this.match(77)) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType");
        } else if (this.isAbstractConstructorSignature()) {
          return this.tsParseFunctionOrConstructorType("TSConstructorType", true);
        }
        return this.tsParseUnionTypeOrHigher();
      }
      tsParseTypeAssertion() {
        if (this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedTypeAssertion, this.state.startLoc);
        }
        const node = this.startNode();
        node.typeAnnotation = this.tsInType(() => {
          this.next();
          return this.match(75) ? this.tsParseTypeReference() : this.tsParseType();
        });
        this.expect(48);
        node.expression = this.parseMaybeUnary();
        return this.finishNode(node, "TSTypeAssertion");
      }
      tsParseHeritageClause(token) {
        const originalStartLoc = this.state.startLoc;
        const delimitedList = this.tsParseDelimitedList("HeritageClauseElement", () => {
          const node = this.startNode();
          node.expression = this.tsParseEntityName();
          if (this.match(47)) {
            node.typeParameters = this.tsParseTypeArguments();
          }
          return this.finishNode(node, "TSExpressionWithTypeArguments");
        });
        if (!delimitedList.length) {
          this.raise(TSErrors.EmptyHeritageClauseType, originalStartLoc, {
            token
          });
        }
        return delimitedList;
      }
      tsParseInterfaceDeclaration(node, properties = {}) {
        if (this.hasFollowingLineBreak()) return null;
        this.expectContextual(129);
        if (properties.declare) node.declare = true;
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          this.checkIdentifier(node.id, 130);
        } else {
          node.id = null;
          this.raise(TSErrors.MissingInterfaceName, this.state.startLoc);
        }
        node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (this.eat(81)) {
          node.extends = this.tsParseHeritageClause("extends");
        }
        const body = this.startNode();
        body.body = this.tsInType(this.tsParseObjectTypeMembers.bind(this));
        node.body = this.finishNode(body, "TSInterfaceBody");
        return this.finishNode(node, "TSInterfaceDeclaration");
      }
      tsParseTypeAliasDeclaration(node) {
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, 2);
        node.typeAnnotation = this.tsInType(() => {
          node.typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutModifiers);
          this.expect(29);
          if (this.isContextual(114) && this.lookahead().type !== 16) {
            const node2 = this.startNode();
            this.next();
            return this.finishNode(node2, "TSIntrinsicKeyword");
          }
          return this.tsParseType();
        });
        this.semicolon();
        return this.finishNode(node, "TSTypeAliasDeclaration");
      }
      tsInNoContext(cb) {
        const oldContext = this.state.context;
        this.state.context = [oldContext[0]];
        try {
          return cb();
        } finally {
          this.state.context = oldContext;
        }
      }
      tsInType(cb) {
        const oldInType = this.state.inType;
        this.state.inType = true;
        try {
          return cb();
        } finally {
          this.state.inType = oldInType;
        }
      }
      tsInDisallowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = true;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsInAllowConditionalTypesContext(cb) {
        const oldInDisallowConditionalTypesContext = this.state.inDisallowConditionalTypesContext;
        this.state.inDisallowConditionalTypesContext = false;
        try {
          return cb();
        } finally {
          this.state.inDisallowConditionalTypesContext = oldInDisallowConditionalTypesContext;
        }
      }
      tsEatThenParseType(token) {
        if (this.match(token)) {
          return this.tsNextThenParseType();
        }
      }
      tsExpectThenParseType(token) {
        return this.tsInType(() => {
          this.expect(token);
          return this.tsParseType();
        });
      }
      tsNextThenParseType() {
        return this.tsInType(() => {
          this.next();
          return this.tsParseType();
        });
      }
      tsParseEnumMember() {
        const node = this.startNode();
        node.id = this.match(133) ? super.parseStringLiteral(this.state.value) : this.parseIdentifier(true);
        if (this.eat(29)) {
          node.initializer = super.parseMaybeAssignAllowIn();
        }
        return this.finishNode(node, "TSEnumMember");
      }
      tsParseEnumDeclaration(node, properties = {}) {
        if (properties.const) node.const = true;
        if (properties.declare) node.declare = true;
        this.expectContextual(126);
        node.id = this.parseIdentifier();
        this.checkIdentifier(node.id, node.const ? 8971 : 8459);
        this.expect(5);
        node.members = this.tsParseDelimitedList("EnumMembers", this.tsParseEnumMember.bind(this));
        this.expect(8);
        return this.finishNode(node, "TSEnumDeclaration");
      }
      tsParseModuleBlock() {
        const node = this.startNode();
        this.scope.enter(0);
        this.expect(5);
        super.parseBlockOrModuleBlockBody(node.body = [], void 0, true, 8);
        this.scope.exit();
        return this.finishNode(node, "TSModuleBlock");
      }
      tsParseModuleOrNamespaceDeclaration(node, nested = false) {
        node.id = this.parseIdentifier();
        if (!nested) {
          this.checkIdentifier(node.id, 1024);
        }
        if (this.eat(16)) {
          const inner = this.startNode();
          this.tsParseModuleOrNamespaceDeclaration(inner, true);
          node.body = inner;
        } else {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseAmbientExternalModuleDeclaration(node) {
        if (this.isContextual(112)) {
          node.global = true;
          node.id = this.parseIdentifier();
        } else if (this.match(133)) {
          node.id = super.parseStringLiteral(this.state.value);
        } else {
          this.unexpected();
        }
        if (this.match(5)) {
          this.scope.enter(256);
          this.prodParam.enter(0);
          node.body = this.tsParseModuleBlock();
          this.prodParam.exit();
          this.scope.exit();
        } else {
          this.semicolon();
        }
        return this.finishNode(node, "TSModuleDeclaration");
      }
      tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier, isExport) {
        node.isExport = isExport || false;
        node.id = maybeDefaultIdentifier || this.parseIdentifier();
        this.checkIdentifier(node.id, 4096);
        this.expect(29);
        const moduleReference = this.tsParseModuleReference();
        if (node.importKind === "type" && moduleReference.type !== "TSExternalModuleReference") {
          this.raise(TSErrors.ImportAliasHasImportType, moduleReference);
        }
        node.moduleReference = moduleReference;
        this.semicolon();
        return this.finishNode(node, "TSImportEqualsDeclaration");
      }
      tsIsExternalModuleReference() {
        return this.isContextual(119) && this.lookaheadCharCode() === 40;
      }
      tsParseModuleReference() {
        return this.tsIsExternalModuleReference() ? this.tsParseExternalModuleReference() : this.tsParseEntityName(false);
      }
      tsParseExternalModuleReference() {
        const node = this.startNode();
        this.expectContextual(119);
        this.expect(10);
        if (!this.match(133)) {
          this.unexpected();
        }
        node.expression = super.parseExprAtom();
        this.expect(11);
        this.sawUnambiguousESM = true;
        return this.finishNode(node, "TSExternalModuleReference");
      }
      tsLookAhead(f) {
        const state = this.state.clone();
        const res = f();
        this.state = state;
        return res;
      }
      tsTryParseAndCatch(f) {
        const result = this.tryParse((abort) => f() || abort());
        if (result.aborted || !result.node) return;
        if (result.error) this.state = result.failState;
        return result.node;
      }
      tsTryParse(f) {
        const state = this.state.clone();
        const result = f();
        if (result !== void 0 && result !== false) {
          return result;
        }
        this.state = state;
      }
      tsTryParseDeclare(nany) {
        if (this.isLineTerminator()) {
          return;
        }
        let startType = this.state.type;
        let kind;
        if (this.isContextual(100)) {
          startType = 74;
          kind = "let";
        }
        return this.tsInAmbientContext(() => {
          switch (startType) {
            case 68:
              nany.declare = true;
              return super.parseFunctionStatement(nany, false, false);
            case 80:
              nany.declare = true;
              return this.parseClass(nany, true, false);
            case 126:
              return this.tsParseEnumDeclaration(nany, {
                declare: true
              });
            case 112:
              return this.tsParseAmbientExternalModuleDeclaration(nany);
            case 75:
            case 74:
              if (!this.match(75) || !this.isLookaheadContextual("enum")) {
                nany.declare = true;
                return this.parseVarStatement(nany, kind || this.state.value, true);
              }
              this.expect(75);
              return this.tsParseEnumDeclaration(nany, {
                const: true,
                declare: true
              });
            case 129: {
              const result = this.tsParseInterfaceDeclaration(nany, {
                declare: true
              });
              if (result) return result;
            }
            default:
              if (tokenIsIdentifier(startType)) {
                return this.tsParseDeclaration(nany, this.state.value, true, null);
              }
          }
        });
      }
      tsTryParseExportDeclaration() {
        return this.tsParseDeclaration(this.startNode(), this.state.value, true, null);
      }
      tsParseExpressionStatement(node, expr, decorators) {
        switch (expr.name) {
          case "declare": {
            const declaration = this.tsTryParseDeclare(node);
            if (declaration) {
              declaration.declare = true;
            }
            return declaration;
          }
          case "global":
            if (this.match(5)) {
              this.scope.enter(256);
              this.prodParam.enter(0);
              const mod = node;
              mod.global = true;
              mod.id = expr;
              mod.body = this.tsParseModuleBlock();
              this.scope.exit();
              this.prodParam.exit();
              return this.finishNode(mod, "TSModuleDeclaration");
            }
            break;
          default:
            return this.tsParseDeclaration(node, expr.name, false, decorators);
        }
      }
      tsParseDeclaration(node, value, next, decorators) {
        switch (value) {
          case "abstract":
            if (this.tsCheckLineTerminator(next) && (this.match(80) || tokenIsIdentifier(this.state.type))) {
              return this.tsParseAbstractDeclaration(node, decorators);
            }
            break;
          case "module":
            if (this.tsCheckLineTerminator(next)) {
              if (this.match(133)) {
                return this.tsParseAmbientExternalModuleDeclaration(node);
              } else if (tokenIsIdentifier(this.state.type)) {
                return this.tsParseModuleOrNamespaceDeclaration(node);
              }
            }
            break;
          case "namespace":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseModuleOrNamespaceDeclaration(node);
            }
            break;
          case "type":
            if (this.tsCheckLineTerminator(next) && tokenIsIdentifier(this.state.type)) {
              return this.tsParseTypeAliasDeclaration(node);
            }
            break;
        }
      }
      tsCheckLineTerminator(next) {
        if (next) {
          if (this.hasFollowingLineBreak()) return false;
          this.next();
          return true;
        }
        return !this.isLineTerminator();
      }
      tsTryParseGenericAsyncArrowFunction(startLoc) {
        if (!this.match(47)) return;
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = true;
        const res = this.tsTryParseAndCatch(() => {
          const node = this.startNodeAt(startLoc);
          node.typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          super.parseFunctionParams(node);
          node.returnType = this.tsTryParseTypeOrTypePredicateAnnotation();
          this.expect(19);
          return node;
        });
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        if (!res) return;
        return super.parseArrowExpression(res, null, true);
      }
      tsParseTypeArgumentsInExpression() {
        if (this.reScan_lt() !== 47) return;
        return this.tsParseTypeArguments();
      }
      tsParseTypeArguments() {
        const node = this.startNode();
        node.params = this.tsInType(() => this.tsInNoContext(() => {
          this.expect(47);
          return this.tsParseDelimitedList("TypeParametersOrArguments", this.tsParseType.bind(this));
        }));
        if (node.params.length === 0) {
          this.raise(TSErrors.EmptyTypeArguments, node);
        } else if (!this.state.inType && this.curContext() === types.brace) {
          this.reScan_lt_gt();
        }
        this.expect(48);
        return this.finishNode(node, "TSTypeParameterInstantiation");
      }
      tsIsDeclarationStart() {
        return tokenIsTSDeclarationStart(this.state.type);
      }
      isExportDefaultSpecifier() {
        if (this.tsIsDeclarationStart()) return false;
        return super.isExportDefaultSpecifier();
      }
      parseAssignableListItem(flags, decorators) {
        const startLoc = this.state.startLoc;
        const modified = {};
        this.tsParseModifiers({
          allowedModifiers: ["public", "private", "protected", "override", "readonly"]
        }, modified);
        const accessibility = modified.accessibility;
        const override = modified.override;
        const readonly = modified.readonly;
        if (!(flags & 4) && (accessibility || readonly || override)) {
          this.raise(TSErrors.UnexpectedParameterModifier, startLoc);
        }
        const left = this.parseMaybeDefault();
        this.parseAssignableListItemTypes(left, flags);
        const elt = this.parseMaybeDefault(left.loc.start, left);
        if (accessibility || readonly || override) {
          const pp = this.startNodeAt(startLoc);
          if (decorators.length) {
            pp.decorators = decorators;
          }
          if (accessibility) pp.accessibility = accessibility;
          if (readonly) pp.readonly = readonly;
          if (override) pp.override = override;
          if (elt.type !== "Identifier" && elt.type !== "AssignmentPattern") {
            this.raise(TSErrors.UnsupportedParameterPropertyKind, pp);
          }
          pp.parameter = elt;
          return this.finishNode(pp, "TSParameterProperty");
        }
        if (decorators.length) {
          left.decorators = decorators;
        }
        return elt;
      }
      isSimpleParameter(node) {
        return node.type === "TSParameterProperty" && super.isSimpleParameter(node.parameter) || super.isSimpleParameter(node);
      }
      tsDisallowOptionalPattern(node) {
        for (const param of node.params) {
          if (param.type !== "Identifier" && param.optional && !this.state.isAmbientContext) {
            this.raise(TSErrors.PatternIsOptional, param);
          }
        }
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        super.setArrowFunctionParameters(node, params, trailingCommaLoc);
        this.tsDisallowOptionalPattern(node);
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
        }
        const bodilessType = type === "FunctionDeclaration" ? "TSDeclareFunction" : type === "ClassMethod" || type === "ClassPrivateMethod" ? "TSDeclareMethod" : void 0;
        if (bodilessType && !this.match(5) && this.isLineTerminator()) {
          return this.finishNode(node, bodilessType);
        }
        if (bodilessType === "TSDeclareFunction" && this.state.isAmbientContext) {
          this.raise(TSErrors.DeclareFunctionHasImplementation, node);
          if (node.declare) {
            return super.parseFunctionBodyAndFinish(node, bodilessType, isMethod);
          }
        }
        this.tsDisallowOptionalPattern(node);
        return super.parseFunctionBodyAndFinish(node, type, isMethod);
      }
      registerFunctionStatementId(node) {
        if (!node.body && node.id) {
          this.checkIdentifier(node.id, 1024);
        } else {
          super.registerFunctionStatementId(node);
        }
      }
      tsCheckForInvalidTypeCasts(items) {
        items.forEach((node) => {
          if ((node == null ? void 0 : node.type) === "TSTypeCastExpression") {
            this.raise(TSErrors.UnexpectedTypeAnnotation, node.typeAnnotation);
          }
        });
      }
      toReferencedList(exprList, isInParens) {
        this.tsCheckForInvalidTypeCasts(exprList);
        return exprList;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        const node = super.parseArrayLike(close, canBePattern, isTuple, refExpressionErrors);
        if (node.type === "ArrayExpression") {
          this.tsCheckForInvalidTypeCasts(node.elements);
        }
        return node;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        if (!this.hasPrecedingLineBreak() && this.match(35)) {
          this.state.canStartJSXElement = false;
          this.next();
          const nonNullExpression = this.startNodeAt(startLoc);
          nonNullExpression.expression = base;
          return this.finishNode(nonNullExpression, "TSNonNullExpression");
        }
        let isOptionalCall = false;
        if (this.match(18) && this.lookaheadCharCode() === 60) {
          if (noCalls) {
            state.stop = true;
            return base;
          }
          state.optionalChainMember = isOptionalCall = true;
          this.next();
        }
        if (this.match(47) || this.match(51)) {
          let missingParenErrorLoc;
          const result = this.tsTryParseAndCatch(() => {
            if (!noCalls && this.atPossibleAsyncArrow(base)) {
              const asyncArrowFn = this.tsTryParseGenericAsyncArrowFunction(startLoc);
              if (asyncArrowFn) {
                return asyncArrowFn;
              }
            }
            const typeArguments = this.tsParseTypeArgumentsInExpression();
            if (!typeArguments) return;
            if (isOptionalCall && !this.match(10)) {
              missingParenErrorLoc = this.state.curPosition();
              return;
            }
            if (tokenIsTemplate(this.state.type)) {
              const result2 = super.parseTaggedTemplateExpression(base, startLoc, state);
              result2.typeParameters = typeArguments;
              return result2;
            }
            if (!noCalls && this.eat(10)) {
              const node2 = this.startNodeAt(startLoc);
              node2.callee = base;
              node2.arguments = this.parseCallExpressionArguments(11, false);
              this.tsCheckForInvalidTypeCasts(node2.arguments);
              node2.typeParameters = typeArguments;
              if (state.optionalChainMember) {
                node2.optional = isOptionalCall;
              }
              return this.finishCallExpression(node2, state.optionalChainMember);
            }
            const tokenType = this.state.type;
            if (tokenType === 48 || tokenType === 52 || tokenType !== 10 && tokenCanStartExpression(tokenType) && !this.hasPrecedingLineBreak()) {
              return;
            }
            const node = this.startNodeAt(startLoc);
            node.expression = base;
            node.typeParameters = typeArguments;
            return this.finishNode(node, "TSInstantiationExpression");
          });
          if (missingParenErrorLoc) {
            this.unexpected(missingParenErrorLoc, 10);
          }
          if (result) {
            if (result.type === "TSInstantiationExpression" && (this.match(16) || this.match(18) && this.lookaheadCharCode() !== 40)) {
              this.raise(TSErrors.InvalidPropertyAccessAfterInstantiationExpression, this.state.startLoc);
            }
            return result;
          }
        }
        return super.parseSubscript(base, startLoc, noCalls, state);
      }
      parseNewCallee(node) {
        var _callee$extra;
        super.parseNewCallee(node);
        const {
          callee
        } = node;
        if (callee.type === "TSInstantiationExpression" && !((_callee$extra = callee.extra) != null && _callee$extra.parenthesized)) {
          node.typeParameters = callee.typeParameters;
          node.callee = callee.expression;
        }
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        let isSatisfies;
        if (tokenOperatorPrecedence(58) > minPrec && !this.hasPrecedingLineBreak() && (this.isContextual(93) || (isSatisfies = this.isContextual(120)))) {
          const node = this.startNodeAt(leftStartLoc);
          node.expression = left;
          node.typeAnnotation = this.tsInType(() => {
            this.next();
            if (this.match(75)) {
              if (isSatisfies) {
                this.raise(Errors.UnexpectedKeyword, this.state.startLoc, {
                  keyword: "const"
                });
              }
              return this.tsParseTypeReference();
            }
            return this.tsParseType();
          });
          this.finishNode(node, isSatisfies ? "TSSatisfiesExpression" : "TSAsExpression");
          this.reScan_lt_gt();
          return this.parseExprOp(node, leftStartLoc, minPrec);
        }
        return super.parseExprOp(left, leftStartLoc, minPrec);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (!this.state.isAmbientContext) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      checkImportReflection(node) {
        super.checkImportReflection(node);
        if (node.module && node.importKind !== "value") {
          this.raise(TSErrors.ImportReflectionHasImportType, node.specifiers[0].loc.start);
        }
      }
      checkDuplicateExports() {
      }
      isPotentialImportPhase(isExport) {
        if (super.isPotentialImportPhase(isExport)) return true;
        if (this.isContextual(130)) {
          const ch = this.lookaheadCharCode();
          return isExport ? ch === 123 || ch === 42 : ch !== 61;
        }
        return !isExport && this.isContextual(87);
      }
      applyImportPhase(node, isExport, phase, loc) {
        super.applyImportPhase(node, isExport, phase, loc);
        if (isExport) {
          node.exportKind = phase === "type" ? "type" : "value";
        } else {
          node.importKind = phase === "type" || phase === "typeof" ? phase : "value";
        }
      }
      parseImport(node) {
        if (this.match(133)) {
          node.importKind = "value";
          return super.parseImport(node);
        }
        let importNode;
        if (tokenIsIdentifier(this.state.type) && this.lookaheadCharCode() === 61) {
          node.importKind = "value";
          return this.tsParseImportEqualsDeclaration(node);
        } else if (this.isContextual(130)) {
          const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, false);
          if (this.lookaheadCharCode() === 61) {
            return this.tsParseImportEqualsDeclaration(node, maybeDefaultIdentifier);
          } else {
            importNode = super.parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier);
          }
        } else {
          importNode = super.parseImport(node);
        }
        if (importNode.importKind === "type" && importNode.specifiers.length > 1 && importNode.specifiers[0].type === "ImportDefaultSpecifier") {
          this.raise(TSErrors.TypeImportCannotSpecifyDefaultAndNamed, importNode);
        }
        return importNode;
      }
      parseExport(node, decorators) {
        if (this.match(83)) {
          this.next();
          const nodeImportEquals = node;
          let maybeDefaultIdentifier = null;
          if (this.isContextual(130) && this.isPotentialImportPhase(false)) {
            maybeDefaultIdentifier = this.parseMaybeImportPhase(nodeImportEquals, false);
          } else {
            nodeImportEquals.importKind = "value";
          }
          return this.tsParseImportEqualsDeclaration(nodeImportEquals, maybeDefaultIdentifier, true);
        } else if (this.eat(29)) {
          const assign = node;
          assign.expression = super.parseExpression();
          this.semicolon();
          this.sawUnambiguousESM = true;
          return this.finishNode(assign, "TSExportAssignment");
        } else if (this.eatContextual(93)) {
          const decl = node;
          this.expectContextual(128);
          decl.id = this.parseIdentifier();
          this.semicolon();
          return this.finishNode(decl, "TSNamespaceExportDeclaration");
        } else {
          return super.parseExport(node, decorators);
        }
      }
      isAbstractClass() {
        return this.isContextual(124) && this.lookahead().type === 80;
      }
      parseExportDefaultExpression() {
        if (this.isAbstractClass()) {
          const cls = this.startNode();
          this.next();
          cls.abstract = true;
          return this.parseClass(cls, true, true);
        }
        if (this.match(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseExportDefaultExpression();
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        const {
          isAmbientContext
        } = this.state;
        const declaration = super.parseVarStatement(node, kind, allowMissingInitializer || isAmbientContext);
        if (!isAmbientContext) return declaration;
        for (const {
          id,
          init
        } of declaration.declarations) {
          if (!init) continue;
          if (kind !== "const" || !!id.typeAnnotation) {
            this.raise(TSErrors.InitializerNotAllowedInAmbientContext, init);
          } else if (!isValidAmbientConstInitializer(init, this.hasPlugin("estree"))) {
            this.raise(TSErrors.ConstInitiailizerMustBeStringOrNumericLiteralOrLiteralEnumReference, init);
          }
        }
        return declaration;
      }
      parseStatementContent(flags, decorators) {
        if (this.match(75) && this.isLookaheadContextual("enum")) {
          const node = this.startNode();
          this.expect(75);
          return this.tsParseEnumDeclaration(node, {
            const: true
          });
        }
        if (this.isContextual(126)) {
          return this.tsParseEnumDeclaration(this.startNode());
        }
        if (this.isContextual(129)) {
          const result = this.tsParseInterfaceDeclaration(this.startNode());
          if (result) return result;
        }
        return super.parseStatementContent(flags, decorators);
      }
      parseAccessModifier() {
        return this.tsParseModifier(["public", "protected", "private"]);
      }
      tsHasSomeModifiers(member, modifiers) {
        return modifiers.some((modifier) => {
          if (tsIsAccessModifier(modifier)) {
            return member.accessibility === modifier;
          }
          return !!member[modifier];
        });
      }
      tsIsStartOfStaticBlocks() {
        return this.isContextual(106) && this.lookaheadCharCode() === 123;
      }
      parseClassMember(classBody, member, state) {
        const modifiers = ["declare", "private", "public", "protected", "override", "abstract", "readonly", "static"];
        this.tsParseModifiers({
          allowedModifiers: modifiers,
          disallowedModifiers: ["in", "out"],
          stopOnStartOfClassStaticBlock: true,
          errorTemplate: TSErrors.InvalidModifierOnTypeParameterPositions
        }, member);
        const callParseClassMemberWithIsStatic = () => {
          if (this.tsIsStartOfStaticBlocks()) {
            this.next();
            this.next();
            if (this.tsHasSomeModifiers(member, modifiers)) {
              this.raise(TSErrors.StaticBlockCannotHaveModifier, this.state.curPosition());
            }
            super.parseClassStaticBlock(classBody, member);
          } else {
            this.parseClassMemberWithIsStatic(classBody, member, state, !!member.static);
          }
        };
        if (member.declare) {
          this.tsInAmbientContext(callParseClassMemberWithIsStatic);
        } else {
          callParseClassMemberWithIsStatic();
        }
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const idx = this.tsTryParseIndexSignature(member);
        if (idx) {
          classBody.body.push(idx);
          if (member.abstract) {
            this.raise(TSErrors.IndexSignatureHasAbstract, member);
          }
          if (member.accessibility) {
            this.raise(TSErrors.IndexSignatureHasAccessibility, member, {
              modifier: member.accessibility
            });
          }
          if (member.declare) {
            this.raise(TSErrors.IndexSignatureHasDeclare, member);
          }
          if (member.override) {
            this.raise(TSErrors.IndexSignatureHasOverride, member);
          }
          return;
        }
        if (!this.state.inAbstractClass && member.abstract) {
          this.raise(TSErrors.NonAbstractClassHasAbstractMethod, member);
        }
        if (member.override) {
          if (!state.hadSuperClass) {
            this.raise(TSErrors.OverrideNotInSubClass, member);
          }
        }
        super.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parsePostMemberNameModifiers(methodOrProp) {
        const optional = this.eat(17);
        if (optional) methodOrProp.optional = true;
        if (methodOrProp.readonly && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasReadonly, methodOrProp);
        }
        if (methodOrProp.declare && this.match(10)) {
          this.raise(TSErrors.ClassMethodHasDeclare, methodOrProp);
        }
      }
      parseExpressionStatement(node, expr, decorators) {
        const decl = expr.type === "Identifier" ? this.tsParseExpressionStatement(node, expr, decorators) : void 0;
        return decl || super.parseExpressionStatement(node, expr, decorators);
      }
      shouldParseExportDeclaration() {
        if (this.tsIsDeclarationStart()) return true;
        return super.shouldParseExportDeclaration();
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (!this.state.maybeInArrowParameters || !this.match(17)) {
          return super.parseConditional(expr, startLoc, refExpressionErrors);
        }
        const result = this.tryParse(() => super.parseConditional(expr, startLoc));
        if (!result.node) {
          if (result.error) {
            super.setOptionalParametersError(refExpressionErrors, result.error);
          }
          return expr;
        }
        if (result.error) this.state = result.failState;
        return result.node;
      }
      parseParenItem(node, startLoc) {
        const newNode = super.parseParenItem(node, startLoc);
        if (this.eat(17)) {
          newNode.optional = true;
          this.resetEndLocation(node);
        }
        if (this.match(14)) {
          const typeCastNode = this.startNodeAt(startLoc);
          typeCastNode.expression = node;
          typeCastNode.typeAnnotation = this.tsParseTypeAnnotation();
          return this.finishNode(typeCastNode, "TSTypeCastExpression");
        }
        return node;
      }
      parseExportDeclaration(node) {
        if (!this.state.isAmbientContext && this.isContextual(125)) {
          return this.tsInAmbientContext(() => this.parseExportDeclaration(node));
        }
        const startLoc = this.state.startLoc;
        const isDeclare = this.eatContextual(125);
        if (isDeclare && (this.isContextual(125) || !this.shouldParseExportDeclaration())) {
          throw this.raise(TSErrors.ExpectedAmbientAfterExportDeclare, this.state.startLoc);
        }
        const isIdentifier = tokenIsIdentifier(this.state.type);
        const declaration = isIdentifier && this.tsTryParseExportDeclaration() || super.parseExportDeclaration(node);
        if (!declaration) return null;
        if (declaration.type === "TSInterfaceDeclaration" || declaration.type === "TSTypeAliasDeclaration" || isDeclare) {
          node.exportKind = "type";
        }
        if (isDeclare) {
          this.resetStartLocation(declaration, startLoc);
          declaration.declare = true;
        }
        return declaration;
      }
      parseClassId(node, isStatement, optionalId, bindingType) {
        if ((!isStatement || optionalId) && this.isContextual(113)) {
          return;
        }
        super.parseClassId(node, isStatement, optionalId, node.declare ? 1024 : 8331);
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseInOutConstModifiers);
        if (typeParameters) node.typeParameters = typeParameters;
      }
      parseClassPropertyAnnotation(node) {
        if (!node.optional) {
          if (this.eat(35)) {
            node.definite = true;
          } else if (this.eat(17)) {
            node.optional = true;
          }
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) node.typeAnnotation = type;
      }
      parseClassProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (this.state.isAmbientContext && !(node.readonly && !node.typeAnnotation) && this.match(29)) {
          this.raise(TSErrors.DeclareClassFieldHasInitializer, this.state.startLoc);
        }
        if (node.abstract && this.match(29)) {
          const {
            key
          } = node;
          this.raise(TSErrors.AbstractPropertyHasInitializer, this.state.startLoc, {
            propertyName: key.type === "Identifier" && !node.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
          });
        }
        return super.parseClassProperty(node);
      }
      parseClassPrivateProperty(node) {
        if (node.abstract) {
          this.raise(TSErrors.PrivateElementHasAbstract, node);
        }
        if (node.accessibility) {
          this.raise(TSErrors.PrivateElementHasAccessibility, node, {
            modifier: node.accessibility
          });
        }
        this.parseClassPropertyAnnotation(node);
        return super.parseClassPrivateProperty(node);
      }
      parseClassAccessorProperty(node) {
        this.parseClassPropertyAnnotation(node);
        if (node.optional) {
          this.raise(TSErrors.AccessorCannotBeOptional, node);
        }
        return super.parseClassAccessorProperty(node);
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters && isConstructor) {
          this.raise(TSErrors.ConstructorHasTypeParameters, typeParameters);
        }
        const {
          declare = false,
          kind
        } = method;
        if (declare && (kind === "get" || kind === "set")) {
          this.raise(TSErrors.DeclareAccessor, method, {
            kind
          });
        }
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper);
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) method.typeParameters = typeParameters;
        super.pushClassPrivateMethod(classBody, method, isGenerator, isAsync);
      }
      declareClassPrivateMethodInScope(node, kind) {
        if (node.type === "TSDeclareMethod") return;
        if (node.type === "MethodDefinition" && !hasOwnProperty.call(node.value, "body")) {
          return;
        }
        super.declareClassPrivateMethodInScope(node, kind);
      }
      parseClassSuper(node) {
        super.parseClassSuper(node);
        if (node.superClass && (this.match(47) || this.match(51))) {
          node.superTypeParameters = this.tsParseTypeArgumentsInExpression();
        }
        if (this.eatContextual(113)) {
          node.implements = this.tsParseHeritageClause("implements");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) prop.typeParameters = typeParameters;
        return super.parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors);
      }
      parseFunctionParams(node, isConstructor) {
        const typeParameters = this.tsTryParseTypeParameters(this.tsParseConstModifier);
        if (typeParameters) node.typeParameters = typeParameters;
        super.parseFunctionParams(node, isConstructor);
      }
      parseVarId(decl, kind) {
        super.parseVarId(decl, kind);
        if (decl.id.type === "Identifier" && !this.hasPrecedingLineBreak() && this.eat(35)) {
          decl.definite = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          decl.id.typeAnnotation = type;
          this.resetEndLocation(decl.id);
        }
      }
      parseAsyncArrowFromCallExpression(node, call) {
        if (this.match(14)) {
          node.returnType = this.tsParseTypeAnnotation();
        }
        return super.parseAsyncArrowFromCallExpression(node, call);
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        var _jsx, _jsx2, _typeCast, _jsx3, _typeCast2;
        let state;
        let jsx2;
        let typeCast;
        if (this.hasPlugin("jsx") && (this.match(142) || this.match(47))) {
          state = this.state.clone();
          jsx2 = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!jsx2.error) return jsx2.node;
          const {
            context
          } = this.state;
          const currentContext = context[context.length - 1];
          if (currentContext === types.j_oTag || currentContext === types.j_expr) {
            context.pop();
          }
        }
        if (!((_jsx = jsx2) != null && _jsx.error) && !this.match(47)) {
          return super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
        }
        if (!state || state === this.state) state = this.state.clone();
        let typeParameters;
        const arrow = this.tryParse((abort) => {
          var _expr$extra, _typeParameters;
          typeParameters = this.tsParseTypeParameters(this.tsParseConstModifier);
          const expr = super.parseMaybeAssign(refExpressionErrors, afterLeftParse);
          if (expr.type !== "ArrowFunctionExpression" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
            abort();
          }
          if (((_typeParameters = typeParameters) == null ? void 0 : _typeParameters.params.length) !== 0) {
            this.resetStartLocationFromNode(expr, typeParameters);
          }
          expr.typeParameters = typeParameters;
          return expr;
        }, state);
        if (!arrow.error && !arrow.aborted) {
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if (!jsx2) {
          assert(!this.hasPlugin("jsx"));
          typeCast = this.tryParse(() => super.parseMaybeAssign(refExpressionErrors, afterLeftParse), state);
          if (!typeCast.error) return typeCast.node;
        }
        if ((_jsx2 = jsx2) != null && _jsx2.node) {
          this.state = jsx2.failState;
          return jsx2.node;
        }
        if (arrow.node) {
          this.state = arrow.failState;
          if (typeParameters) this.reportReservedArrowTypeParam(typeParameters);
          return arrow.node;
        }
        if ((_typeCast = typeCast) != null && _typeCast.node) {
          this.state = typeCast.failState;
          return typeCast.node;
        }
        throw ((_jsx3 = jsx2) == null ? void 0 : _jsx3.error) || arrow.error || ((_typeCast2 = typeCast) == null ? void 0 : _typeCast2.error);
      }
      reportReservedArrowTypeParam(node) {
        var _node$extra;
        if (node.params.length === 1 && !node.params[0].constraint && !((_node$extra = node.extra) != null && _node$extra.trailingComma) && this.getPluginOption("typescript", "disallowAmbiguousJSXLike")) {
          this.raise(TSErrors.ReservedArrowTypeParam, node);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        if (!this.hasPlugin("jsx") && this.match(47)) {
          return this.tsParseTypeAssertion();
        }
        return super.parseMaybeUnary(refExpressionErrors, sawUnary);
      }
      parseArrow(node) {
        if (this.match(14)) {
          const result = this.tryParse((abort) => {
            const returnType = this.tsParseTypeOrTypePredicateAnnotation(14);
            if (this.canInsertSemicolon() || !this.match(19)) abort();
            return returnType;
          });
          if (result.aborted) return;
          if (!result.thrown) {
            if (result.error) this.state = result.failState;
            node.returnType = result.node;
          }
        }
        return super.parseArrow(node);
      }
      parseAssignableListItemTypes(param, flags) {
        if (!(flags & 2)) return param;
        if (this.eat(17)) {
          param.optional = true;
        }
        const type = this.tsTryParseTypeAnnotation();
        if (type) param.typeAnnotation = type;
        this.resetEndLocation(param);
        return param;
      }
      isAssignable(node, isBinding) {
        switch (node.type) {
          case "TSTypeCastExpression":
            return this.isAssignable(node.expression, isBinding);
          case "TSParameterProperty":
            return true;
          default:
            return super.isAssignable(node, isBinding);
        }
      }
      toAssignable(node, isLHS = false) {
        switch (node.type) {
          case "ParenthesizedExpression":
            this.toAssignableParenthesizedExpression(node, isLHS);
            break;
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
            if (isLHS) {
              this.expressionScope.recordArrowParameterBindingError(TSErrors.UnexpectedTypeCastInParameter, node);
            } else {
              this.raise(TSErrors.UnexpectedTypeCastInParameter, node);
            }
            this.toAssignable(node.expression, isLHS);
            break;
          case "AssignmentExpression":
            if (!isLHS && node.left.type === "TSTypeCastExpression") {
              node.left = this.typeCastToParameter(node.left);
            }
          default:
            super.toAssignable(node, isLHS);
        }
      }
      toAssignableParenthesizedExpression(node, isLHS) {
        switch (node.expression.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSNonNullExpression":
          case "TSTypeAssertion":
          case "ParenthesizedExpression":
            this.toAssignable(node.expression, isLHS);
            break;
          default:
            super.toAssignable(node, isLHS);
        }
      }
      checkToRestConversion(node, allowPattern) {
        switch (node.type) {
          case "TSAsExpression":
          case "TSSatisfiesExpression":
          case "TSTypeAssertion":
          case "TSNonNullExpression":
            this.checkToRestConversion(node.expression, false);
            break;
          default:
            super.checkToRestConversion(node, allowPattern);
        }
      }
      isValidLVal(type, isUnparenthesizedInAssign, binding) {
        return getOwn({
          TSTypeCastExpression: true,
          TSParameterProperty: "parameter",
          TSNonNullExpression: "expression",
          TSInstantiationExpression: "expression",
          TSAsExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
          TSSatisfiesExpression: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true],
          TSTypeAssertion: (binding !== 64 || !isUnparenthesizedInAssign) && ["expression", true]
        }, type) || super.isValidLVal(type, isUnparenthesizedInAssign, binding);
      }
      parseBindingAtom() {
        if (this.state.type === 78) {
          return this.parseIdentifier(true);
        }
        return super.parseBindingAtom();
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsParseTypeArgumentsInExpression();
          if (this.match(10)) {
            const call = super.parseMaybeDecoratorArguments(expr);
            call.typeParameters = typeArguments;
            return call;
          }
          this.unexpected(null, 10);
        }
        return super.parseMaybeDecoratorArguments(expr);
      }
      checkCommaAfterRest(close) {
        if (this.state.isAmbientContext && this.match(12) && this.lookaheadCharCode() === close) {
          this.next();
          return false;
        }
        return super.checkCommaAfterRest(close);
      }
      isClassMethod() {
        return this.match(47) || super.isClassMethod();
      }
      isClassProperty() {
        return this.match(35) || this.match(14) || super.isClassProperty();
      }
      parseMaybeDefault(startLoc, left) {
        const node = super.parseMaybeDefault(startLoc, left);
        if (node.type === "AssignmentPattern" && node.typeAnnotation && node.right.start < node.typeAnnotation.start) {
          this.raise(TSErrors.TypeAnnotationAfterAssign, node.typeAnnotation);
        }
        return node;
      }
      getTokenFromCode(code2) {
        if (this.state.inType) {
          if (code2 === 62) {
            this.finishOp(48, 1);
            return;
          }
          if (code2 === 60) {
            this.finishOp(47, 1);
            return;
          }
        }
        super.getTokenFromCode(code2);
      }
      reScan_lt_gt() {
        const {
          type
        } = this.state;
        if (type === 47) {
          this.state.pos -= 1;
          this.readToken_lt();
        } else if (type === 48) {
          this.state.pos -= 1;
          this.readToken_gt();
        }
      }
      reScan_lt() {
        const {
          type
        } = this.state;
        if (type === 51) {
          this.state.pos -= 2;
          this.finishOp(47, 1);
          return 47;
        }
        return type;
      }
      toAssignableList(exprList, trailingCommaLoc, isLHS) {
        for (let i = 0; i < exprList.length; i++) {
          const expr = exprList[i];
          if ((expr == null ? void 0 : expr.type) === "TSTypeCastExpression") {
            exprList[i] = this.typeCastToParameter(expr);
          }
        }
        super.toAssignableList(exprList, trailingCommaLoc, isLHS);
      }
      typeCastToParameter(node) {
        node.expression.typeAnnotation = node.typeAnnotation;
        this.resetEndLocation(node.expression, node.typeAnnotation.loc.end);
        return node.expression;
      }
      shouldParseArrow(params) {
        if (this.match(14)) {
          return params.every((expr) => this.isAssignable(expr, true));
        }
        return super.shouldParseArrow(params);
      }
      shouldParseAsyncArrow() {
        return this.match(14) || super.shouldParseAsyncArrow();
      }
      canHaveLeadingDecorator() {
        return super.canHaveLeadingDecorator() || this.isAbstractClass();
      }
      jsxParseOpeningElementAfterName(node) {
        if (this.match(47) || this.match(51)) {
          const typeArguments = this.tsTryParseAndCatch(() => this.tsParseTypeArgumentsInExpression());
          if (typeArguments) node.typeParameters = typeArguments;
        }
        return super.jsxParseOpeningElementAfterName(node);
      }
      getGetterSetterExpectedParamCount(method) {
        const baseCount = super.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        const firstParam = params[0];
        const hasContextParam = firstParam && this.isThisParam(firstParam);
        return hasContextParam ? baseCount + 1 : baseCount;
      }
      parseCatchClauseParam() {
        const param = super.parseCatchClauseParam();
        const type = this.tsTryParseTypeAnnotation();
        if (type) {
          param.typeAnnotation = type;
          this.resetEndLocation(param);
        }
        return param;
      }
      tsInAmbientContext(cb) {
        const {
          isAmbientContext: oldIsAmbientContext,
          strict: oldStrict
        } = this.state;
        this.state.isAmbientContext = true;
        this.state.strict = false;
        try {
          return cb();
        } finally {
          this.state.isAmbientContext = oldIsAmbientContext;
          this.state.strict = oldStrict;
        }
      }
      parseClass(node, isStatement, optionalId) {
        const oldInAbstractClass = this.state.inAbstractClass;
        this.state.inAbstractClass = !!node.abstract;
        try {
          return super.parseClass(node, isStatement, optionalId);
        } finally {
          this.state.inAbstractClass = oldInAbstractClass;
        }
      }
      tsParseAbstractDeclaration(node, decorators) {
        if (this.match(80)) {
          node.abstract = true;
          return this.maybeTakeDecorators(decorators, this.parseClass(node, true, false));
        } else if (this.isContextual(129)) {
          if (!this.hasFollowingLineBreak()) {
            node.abstract = true;
            this.raise(TSErrors.NonClassMethodPropertyHasAbstractModifer, node);
            return this.tsParseInterfaceDeclaration(node);
          }
        } else {
          this.unexpected(null, 80);
        }
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope) {
        const method = super.parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope);
        if (method.abstract) {
          const hasBody = this.hasPlugin("estree") ? !!method.value.body : !!method.body;
          if (hasBody) {
            const {
              key
            } = method;
            this.raise(TSErrors.AbstractMethodHasImplementation, method, {
              methodName: key.type === "Identifier" && !method.computed ? key.name : `[${this.input.slice(key.start, key.end)}]`
            });
          }
        }
        return method;
      }
      tsParseTypeParameterName() {
        const typeName = this.parseIdentifier();
        return typeName.name;
      }
      shouldParseAsAmbientContext() {
        return !!this.getPluginOption("typescript", "dts");
      }
      parse() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.parse();
      }
      getExpression() {
        if (this.shouldParseAsAmbientContext()) {
          this.state.isAmbientContext = true;
        }
        return super.getExpression();
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (!isString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(node, false, isInTypeExport);
          return this.finishNode(node, "ExportSpecifier");
        }
        node.exportKind = "value";
        return super.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly);
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (!importedIsString && isMaybeTypeOnly) {
          this.parseTypeOnlyImportExportSpecifier(specifier, true, isInTypeOnlyImport);
          return this.finishNode(specifier, "ImportSpecifier");
        }
        specifier.importKind = "value";
        return super.parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, isInTypeOnlyImport ? 4098 : 4096);
      }
      parseTypeOnlyImportExportSpecifier(node, isImport, isInTypeOnlyImportExport) {
        const leftOfAsKey = isImport ? "imported" : "local";
        const rightOfAsKey = isImport ? "local" : "exported";
        let leftOfAs = node[leftOfAsKey];
        let rightOfAs;
        let hasTypeSpecifier = false;
        let canParseAsKeyword = true;
        const loc = leftOfAs.loc.start;
        if (this.isContextual(93)) {
          const firstAs = this.parseIdentifier();
          if (this.isContextual(93)) {
            const secondAs = this.parseIdentifier();
            if (tokenIsKeywordOrIdentifier(this.state.type)) {
              hasTypeSpecifier = true;
              leftOfAs = firstAs;
              rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
              canParseAsKeyword = false;
            } else {
              rightOfAs = secondAs;
              canParseAsKeyword = false;
            }
          } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
            canParseAsKeyword = false;
            rightOfAs = isImport ? this.parseIdentifier() : this.parseModuleExportName();
          } else {
            hasTypeSpecifier = true;
            leftOfAs = firstAs;
          }
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          hasTypeSpecifier = true;
          if (isImport) {
            leftOfAs = this.parseIdentifier(true);
            if (!this.isContextual(93)) {
              this.checkReservedWord(leftOfAs.name, leftOfAs.loc.start, true, true);
            }
          } else {
            leftOfAs = this.parseModuleExportName();
          }
        }
        if (hasTypeSpecifier && isInTypeOnlyImportExport) {
          this.raise(isImport ? TSErrors.TypeModifierIsUsedInTypeImports : TSErrors.TypeModifierIsUsedInTypeExports, loc);
        }
        node[leftOfAsKey] = leftOfAs;
        node[rightOfAsKey] = rightOfAs;
        const kindKey = isImport ? "importKind" : "exportKind";
        node[kindKey] = hasTypeSpecifier ? "type" : "value";
        if (canParseAsKeyword && this.eatContextual(93)) {
          node[rightOfAsKey] = isImport ? this.parseIdentifier() : this.parseModuleExportName();
        }
        if (!node[rightOfAsKey]) {
          node[rightOfAsKey] = cloneIdentifier(node[leftOfAsKey]);
        }
        if (isImport) {
          this.checkIdentifier(node[rightOfAsKey], hasTypeSpecifier ? 4098 : 4096);
        }
      }
    };
    function isPossiblyLiteralEnum(expression) {
      if (expression.type !== "MemberExpression") return false;
      const {
        computed,
        property
      } = expression;
      if (computed && property.type !== "StringLiteral" && (property.type !== "TemplateLiteral" || property.expressions.length > 0)) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    function isValidAmbientConstInitializer(expression, estree2) {
      var _expression$extra;
      const {
        type
      } = expression;
      if ((_expression$extra = expression.extra) != null && _expression$extra.parenthesized) {
        return false;
      }
      if (estree2) {
        if (type === "Literal") {
          const {
            value
          } = expression;
          if (typeof value === "string" || typeof value === "boolean") {
            return true;
          }
        }
      } else {
        if (type === "StringLiteral" || type === "BooleanLiteral") {
          return true;
        }
      }
      if (isNumber(expression, estree2) || isNegativeNumber(expression, estree2)) {
        return true;
      }
      if (type === "TemplateLiteral" && expression.expressions.length === 0) {
        return true;
      }
      if (isPossiblyLiteralEnum(expression)) {
        return true;
      }
      return false;
    }
    function isNumber(expression, estree2) {
      if (estree2) {
        return expression.type === "Literal" && (typeof expression.value === "number" || "bigint" in expression);
      }
      return expression.type === "NumericLiteral" || expression.type === "BigIntLiteral";
    }
    function isNegativeNumber(expression, estree2) {
      if (expression.type === "UnaryExpression") {
        const {
          operator,
          argument
        } = expression;
        if (operator === "-" && isNumber(argument, estree2)) {
          return true;
        }
      }
      return false;
    }
    function isUncomputedMemberExpressionChain(expression) {
      if (expression.type === "Identifier") return true;
      if (expression.type !== "MemberExpression" || expression.computed) {
        return false;
      }
      return isUncomputedMemberExpressionChain(expression.object);
    }
    var PlaceholderErrors = ParseErrorEnum`placeholders`({
      ClassNameIsRequired: "A class name is required.",
      UnexpectedSpace: "Unexpected space in placeholder."
    });
    var placeholders = (superClass) => class PlaceholdersParserMixin extends superClass {
      parsePlaceholder(expectedNode) {
        if (this.match(144)) {
          const node = this.startNode();
          this.next();
          this.assertNoSpace();
          node.name = super.parseIdentifier(true);
          this.assertNoSpace();
          this.expect(144);
          return this.finishPlaceholder(node, expectedNode);
        }
      }
      finishPlaceholder(node, expectedNode) {
        let placeholder = node;
        if (!placeholder.expectedNode || !placeholder.type) {
          placeholder = this.finishNode(placeholder, "Placeholder");
        }
        placeholder.expectedNode = expectedNode;
        return placeholder;
      }
      getTokenFromCode(code2) {
        if (code2 === 37 && this.input.charCodeAt(this.state.pos + 1) === 37) {
          this.finishOp(144, 2);
        } else {
          super.getTokenFromCode(code2);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parsePlaceholder("Expression") || super.parseExprAtom(refExpressionErrors);
      }
      parseIdentifier(liberal) {
        return this.parsePlaceholder("Identifier") || super.parseIdentifier(liberal);
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word !== void 0) {
          super.checkReservedWord(word, startLoc, checkKeywords, isBinding);
        }
      }
      parseBindingAtom() {
        return this.parsePlaceholder("Pattern") || super.parseBindingAtom();
      }
      isValidLVal(type, isParenthesized, binding) {
        return type === "Placeholder" || super.isValidLVal(type, isParenthesized, binding);
      }
      toAssignable(node, isLHS) {
        if (node && node.type === "Placeholder" && node.expectedNode === "Expression") {
          node.expectedNode = "Pattern";
        } else {
          super.toAssignable(node, isLHS);
        }
      }
      chStartsBindingIdentifier(ch, pos) {
        if (super.chStartsBindingIdentifier(ch, pos)) {
          return true;
        }
        const nextToken = this.lookahead();
        if (nextToken.type === 144) {
          return true;
        }
        return false;
      }
      verifyBreakContinue(node, isBreak) {
        if (node.label && node.label.type === "Placeholder") return;
        super.verifyBreakContinue(node, isBreak);
      }
      parseExpressionStatement(node, expr) {
        var _expr$extra;
        if (expr.type !== "Placeholder" || (_expr$extra = expr.extra) != null && _expr$extra.parenthesized) {
          return super.parseExpressionStatement(node, expr);
        }
        if (this.match(14)) {
          const stmt = node;
          stmt.label = this.finishPlaceholder(expr, "Identifier");
          this.next();
          stmt.body = super.parseStatementOrSloppyAnnexBFunctionDeclaration();
          return this.finishNode(stmt, "LabeledStatement");
        }
        this.semicolon();
        const stmtPlaceholder = node;
        stmtPlaceholder.name = expr.name;
        return this.finishPlaceholder(stmtPlaceholder, "Statement");
      }
      parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse) {
        return this.parsePlaceholder("BlockStatement") || super.parseBlock(allowDirectives, createNewLexicalScope, afterBlockParse);
      }
      parseFunctionId(requireId) {
        return this.parsePlaceholder("Identifier") || super.parseFunctionId(requireId);
      }
      parseClass(node, isStatement, optionalId) {
        const type = isStatement ? "ClassDeclaration" : "ClassExpression";
        this.next();
        const oldStrict = this.state.strict;
        const placeholder = this.parsePlaceholder("Identifier");
        if (placeholder) {
          if (this.match(81) || this.match(144) || this.match(5)) {
            node.id = placeholder;
          } else if (optionalId || !isStatement) {
            node.id = null;
            node.body = this.finishPlaceholder(placeholder, "ClassBody");
            return this.finishNode(node, type);
          } else {
            throw this.raise(PlaceholderErrors.ClassNameIsRequired, this.state.startLoc);
          }
        } else {
          this.parseClassId(node, isStatement, optionalId);
        }
        super.parseClassSuper(node);
        node.body = this.parsePlaceholder("ClassBody") || super.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, type);
      }
      parseExport(node, decorators) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseExport(node, decorators);
        const node2 = node;
        if (!this.isContextual(98) && !this.match(12)) {
          node2.specifiers = [];
          node2.source = null;
          node2.declaration = this.finishPlaceholder(placeholder, "Declaration");
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        this.expectPlugin("exportDefaultFrom");
        const specifier = this.startNode();
        specifier.exported = placeholder;
        node2.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
        return super.parseExport(node2, decorators);
      }
      isExportDefaultSpecifier() {
        if (this.match(65)) {
          const next = this.nextTokenStart();
          if (this.isUnparsedContextual(next, "from")) {
            if (this.input.startsWith(tokenLabelName(144), this.nextTokenStartSince(next + 4))) {
              return true;
            }
          }
        }
        return super.isExportDefaultSpecifier();
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        var _specifiers;
        if ((_specifiers = node.specifiers) != null && _specifiers.length) {
          return true;
        }
        return super.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
      }
      checkExport(node) {
        const {
          specifiers
        } = node;
        if (specifiers != null && specifiers.length) {
          node.specifiers = specifiers.filter((node2) => node2.exported.type === "Placeholder");
        }
        super.checkExport(node);
        node.specifiers = specifiers;
      }
      parseImport(node) {
        const placeholder = this.parsePlaceholder("Identifier");
        if (!placeholder) return super.parseImport(node);
        node.specifiers = [];
        if (!this.isContextual(98) && !this.match(12)) {
          node.source = this.finishPlaceholder(placeholder, "StringLiteral");
          this.semicolon();
          return this.finishNode(node, "ImportDeclaration");
        }
        const specifier = this.startNodeAtNode(placeholder);
        specifier.local = placeholder;
        node.specifiers.push(this.finishNode(specifier, "ImportDefaultSpecifier"));
        if (this.eat(12)) {
          const hasStarImport = this.maybeParseStarImportSpecifier(node);
          if (!hasStarImport) this.parseNamedImportSpecifiers(node);
        }
        this.expectContextual(98);
        node.source = this.parseImportSource();
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        return this.parsePlaceholder("StringLiteral") || super.parseImportSource();
      }
      assertNoSpace() {
        if (this.state.start > this.state.lastTokEndLoc.index) {
          this.raise(PlaceholderErrors.UnexpectedSpace, this.state.lastTokEndLoc);
        }
      }
    };
    var v8intrinsic = (superClass) => class V8IntrinsicMixin extends superClass {
      parseV8Intrinsic() {
        if (this.match(54)) {
          const v8IntrinsicStartLoc = this.state.startLoc;
          const node = this.startNode();
          this.next();
          if (tokenIsIdentifier(this.state.type)) {
            const name = this.parseIdentifierName();
            const identifier = this.createIdentifier(node, name);
            identifier.type = "V8IntrinsicIdentifier";
            if (this.match(10)) {
              return identifier;
            }
          }
          this.unexpected(v8IntrinsicStartLoc);
        }
      }
      parseExprAtom(refExpressionErrors) {
        return this.parseV8Intrinsic() || super.parseExprAtom(refExpressionErrors);
      }
    };
    function hasPlugin(plugins, expectedConfig) {
      const [expectedName, expectedOptions] = typeof expectedConfig === "string" ? [expectedConfig, {}] : expectedConfig;
      const expectedKeys = Object.keys(expectedOptions);
      const expectedOptionsIsEmpty = expectedKeys.length === 0;
      return plugins.some((p) => {
        if (typeof p === "string") {
          return expectedOptionsIsEmpty && p === expectedName;
        } else {
          const [pluginName, pluginOptions] = p;
          if (pluginName !== expectedName) {
            return false;
          }
          for (const key of expectedKeys) {
            if (pluginOptions[key] !== expectedOptions[key]) {
              return false;
            }
          }
          return true;
        }
      });
    }
    function getPluginOption(plugins, name, option) {
      const plugin = plugins.find((plugin2) => {
        if (Array.isArray(plugin2)) {
          return plugin2[0] === name;
        } else {
          return plugin2 === name;
        }
      });
      if (plugin && Array.isArray(plugin) && plugin.length > 1) {
        return plugin[1][option];
      }
      return null;
    }
    var PIPELINE_PROPOSALS = ["minimal", "fsharp", "hack", "smart"];
    var TOPIC_TOKENS = ["^^", "@@", "^", "%", "#"];
    function validatePlugins(plugins) {
      if (hasPlugin(plugins, "decorators")) {
        if (hasPlugin(plugins, "decorators-legacy")) {
          throw new Error("Cannot use the decorators and decorators-legacy plugin together");
        }
        const decoratorsBeforeExport = getPluginOption(plugins, "decorators", "decoratorsBeforeExport");
        if (decoratorsBeforeExport != null && typeof decoratorsBeforeExport !== "boolean") {
          throw new Error("'decoratorsBeforeExport' must be a boolean, if specified.");
        }
        const allowCallParenthesized = getPluginOption(plugins, "decorators", "allowCallParenthesized");
        if (allowCallParenthesized != null && typeof allowCallParenthesized !== "boolean") {
          throw new Error("'allowCallParenthesized' must be a boolean.");
        }
      }
      if (hasPlugin(plugins, "flow") && hasPlugin(plugins, "typescript")) {
        throw new Error("Cannot combine flow and typescript plugins.");
      }
      if (hasPlugin(plugins, "placeholders") && hasPlugin(plugins, "v8intrinsic")) {
        throw new Error("Cannot combine placeholders and v8intrinsic plugins.");
      }
      if (hasPlugin(plugins, "pipelineOperator")) {
        const proposal = getPluginOption(plugins, "pipelineOperator", "proposal");
        if (!PIPELINE_PROPOSALS.includes(proposal)) {
          const proposalList = PIPELINE_PROPOSALS.map((p) => `"${p}"`).join(", ");
          throw new Error(`"pipelineOperator" requires "proposal" option whose value must be one of: ${proposalList}.`);
        }
        const recordAndTupleConfigItem = ["recordAndTuple", {
          syntaxType: "hash"
        }];
        const tupleSyntaxIsHash = hasPlugin(plugins, recordAndTupleConfigItem);
        if (proposal === "hack") {
          if (hasPlugin(plugins, "placeholders")) {
            throw new Error("Cannot combine placeholders plugin and Hack-style pipes.");
          }
          if (hasPlugin(plugins, "v8intrinsic")) {
            throw new Error("Cannot combine v8intrinsic plugin and Hack-style pipes.");
          }
          const topicToken = getPluginOption(plugins, "pipelineOperator", "topicToken");
          if (!TOPIC_TOKENS.includes(topicToken)) {
            const tokenList = TOPIC_TOKENS.map((t) => `"${t}"`).join(", ");
            throw new Error(`"pipelineOperator" in "proposal": "hack" mode also requires a "topicToken" option whose value must be one of: ${tokenList}.`);
          }
          if (topicToken === "#" && tupleSyntaxIsHash) {
            throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "hack", topicToken: "#" }]\` and \`${JSON.stringify(recordAndTupleConfigItem)}\`.`);
          }
        } else if (proposal === "smart" && tupleSyntaxIsHash) {
          throw new Error(`Plugin conflict between \`["pipelineOperator", { proposal: "smart" }]\` and \`${JSON.stringify(recordAndTupleConfigItem)}\`.`);
        }
      }
      if (hasPlugin(plugins, "moduleAttributes")) {
        {
          if (hasPlugin(plugins, "importAssertions") || hasPlugin(plugins, "importAttributes")) {
            throw new Error("Cannot combine importAssertions, importAttributes and moduleAttributes plugins.");
          }
          const moduleAttributesVersionPluginOption = getPluginOption(plugins, "moduleAttributes", "version");
          if (moduleAttributesVersionPluginOption !== "may-2020") {
            throw new Error("The 'moduleAttributes' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is 'may-2020'.");
          }
        }
      }
      if (hasPlugin(plugins, "importAssertions") && hasPlugin(plugins, "importAttributes")) {
        throw new Error("Cannot combine importAssertions and importAttributes plugins.");
      }
      if (hasPlugin(plugins, "recordAndTuple")) {
        const syntaxType = getPluginOption(plugins, "recordAndTuple", "syntaxType");
        if (syntaxType != null) {
          {
            const RECORD_AND_TUPLE_SYNTAX_TYPES = ["hash", "bar"];
            if (!RECORD_AND_TUPLE_SYNTAX_TYPES.includes(syntaxType)) {
              throw new Error("The 'syntaxType' option of the 'recordAndTuple' plugin must be one of: " + RECORD_AND_TUPLE_SYNTAX_TYPES.map((p) => `'${p}'`).join(", "));
            }
          }
        }
      }
      if (hasPlugin(plugins, "asyncDoExpressions") && !hasPlugin(plugins, "doExpressions")) {
        const error = new Error("'asyncDoExpressions' requires 'doExpressions', please add 'doExpressions' to parser plugins.");
        error.missingPlugins = "doExpressions";
        throw error;
      }
      if (hasPlugin(plugins, "optionalChainingAssign") && getPluginOption(plugins, "optionalChainingAssign", "version") !== "2023-07") {
        throw new Error("The 'optionalChainingAssign' plugin requires a 'version' option, representing the last proposal update. Currently, the only supported value is '2023-07'.");
      }
    }
    var mixinPlugins = {
      estree,
      jsx,
      flow,
      typescript,
      v8intrinsic,
      placeholders
    };
    var mixinPluginNames = Object.keys(mixinPlugins);
    var defaultOptions = {
      sourceType: "script",
      sourceFilename: void 0,
      startColumn: 0,
      startLine: 1,
      allowAwaitOutsideFunction: false,
      allowReturnOutsideFunction: false,
      allowNewTargetOutsideFunction: false,
      allowImportExportEverywhere: false,
      allowSuperOutsideMethod: false,
      allowUndeclaredExports: false,
      plugins: [],
      strictMode: null,
      ranges: false,
      tokens: false,
      createImportExpressions: false,
      createParenthesizedExpressions: false,
      errorRecovery: false,
      attachComment: true,
      annexB: true
    };
    function getOptions(opts) {
      if (opts == null) {
        return Object.assign({}, defaultOptions);
      }
      if (opts.annexB != null && opts.annexB !== false) {
        throw new Error("The `annexB` option can only be set to `false`.");
      }
      const options = {};
      for (const key of Object.keys(defaultOptions)) {
        var _opts$key;
        options[key] = (_opts$key = opts[key]) != null ? _opts$key : defaultOptions[key];
      }
      return options;
    }
    var ExpressionParser = class extends LValParser {
      checkProto(prop, isRecord, protoRef, refExpressionErrors) {
        if (prop.type === "SpreadElement" || this.isObjectMethod(prop) || prop.computed || prop.shorthand) {
          return;
        }
        const key = prop.key;
        const name = key.type === "Identifier" ? key.name : key.value;
        if (name === "__proto__") {
          if (isRecord) {
            this.raise(Errors.RecordNoProto, key);
            return;
          }
          if (protoRef.used) {
            if (refExpressionErrors) {
              if (refExpressionErrors.doubleProtoLoc === null) {
                refExpressionErrors.doubleProtoLoc = key.loc.start;
              }
            } else {
              this.raise(Errors.DuplicateProto, key);
            }
          }
          protoRef.used = true;
        }
      }
      shouldExitDescending(expr, potentialArrowAt) {
        return expr.type === "ArrowFunctionExpression" && expr.start === potentialArrowAt;
      }
      getExpression() {
        this.enterInitialScopes();
        this.nextToken();
        const expr = this.parseExpression();
        if (!this.match(139)) {
          this.unexpected();
        }
        this.finalizeRemainingComments();
        expr.comments = this.comments;
        expr.errors = this.state.errors;
        if (this.options.tokens) {
          expr.tokens = this.tokens;
        }
        return expr;
      }
      parseExpression(disallowIn, refExpressionErrors) {
        if (disallowIn) {
          return this.disallowInAnd(() => this.parseExpressionBase(refExpressionErrors));
        }
        return this.allowInAnd(() => this.parseExpressionBase(refExpressionErrors));
      }
      parseExpressionBase(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const expr = this.parseMaybeAssign(refExpressionErrors);
        if (this.match(12)) {
          const node = this.startNodeAt(startLoc);
          node.expressions = [expr];
          while (this.eat(12)) {
            node.expressions.push(this.parseMaybeAssign(refExpressionErrors));
          }
          this.toReferencedList(node.expressions);
          return this.finishNode(node, "SequenceExpression");
        }
        return expr;
      }
      parseMaybeAssignDisallowIn(refExpressionErrors, afterLeftParse) {
        return this.disallowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      parseMaybeAssignAllowIn(refExpressionErrors, afterLeftParse) {
        return this.allowInAnd(() => this.parseMaybeAssign(refExpressionErrors, afterLeftParse));
      }
      setOptionalParametersError(refExpressionErrors, resultError) {
        var _resultError$loc;
        refExpressionErrors.optionalParametersLoc = (_resultError$loc = resultError == null ? void 0 : resultError.loc) != null ? _resultError$loc : this.state.startLoc;
      }
      parseMaybeAssign(refExpressionErrors, afterLeftParse) {
        const startLoc = this.state.startLoc;
        if (this.isContextual(108)) {
          if (this.prodParam.hasYield) {
            let left2 = this.parseYield();
            if (afterLeftParse) {
              left2 = afterLeftParse.call(this, left2, startLoc);
            }
            return left2;
          }
        }
        let ownExpressionErrors;
        if (refExpressionErrors) {
          ownExpressionErrors = false;
        } else {
          refExpressionErrors = new ExpressionErrors();
          ownExpressionErrors = true;
        }
        const {
          type
        } = this.state;
        if (type === 10 || tokenIsIdentifier(type)) {
          this.state.potentialArrowAt = this.state.start;
        }
        let left = this.parseMaybeConditional(refExpressionErrors);
        if (afterLeftParse) {
          left = afterLeftParse.call(this, left, startLoc);
        }
        if (tokenIsAssignment(this.state.type)) {
          const node = this.startNodeAt(startLoc);
          const operator = this.state.value;
          node.operator = operator;
          if (this.match(29)) {
            this.toAssignable(left, true);
            node.left = left;
            const startIndex = startLoc.index;
            if (refExpressionErrors.doubleProtoLoc != null && refExpressionErrors.doubleProtoLoc.index >= startIndex) {
              refExpressionErrors.doubleProtoLoc = null;
            }
            if (refExpressionErrors.shorthandAssignLoc != null && refExpressionErrors.shorthandAssignLoc.index >= startIndex) {
              refExpressionErrors.shorthandAssignLoc = null;
            }
            if (refExpressionErrors.privateKeyLoc != null && refExpressionErrors.privateKeyLoc.index >= startIndex) {
              this.checkDestructuringPrivate(refExpressionErrors);
              refExpressionErrors.privateKeyLoc = null;
            }
          } else {
            node.left = left;
          }
          this.next();
          node.right = this.parseMaybeAssign();
          this.checkLVal(left, {
            in: this.finishNode(node, "AssignmentExpression")
          });
          return node;
        } else if (ownExpressionErrors) {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        return left;
      }
      parseMaybeConditional(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprOps(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseConditional(expr, startLoc, refExpressionErrors);
      }
      parseConditional(expr, startLoc, refExpressionErrors) {
        if (this.eat(17)) {
          const node = this.startNodeAt(startLoc);
          node.test = expr;
          node.consequent = this.parseMaybeAssignAllowIn();
          this.expect(14);
          node.alternate = this.parseMaybeAssign();
          return this.finishNode(node, "ConditionalExpression");
        }
        return expr;
      }
      parseMaybeUnaryOrPrivate(refExpressionErrors) {
        return this.match(138) ? this.parsePrivateName() : this.parseMaybeUnary(refExpressionErrors);
      }
      parseExprOps(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseMaybeUnaryOrPrivate(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseExprOp(expr, startLoc, -1);
      }
      parseExprOp(left, leftStartLoc, minPrec) {
        if (this.isPrivateName(left)) {
          const value = this.getPrivateNameSV(left);
          if (minPrec >= tokenOperatorPrecedence(58) || !this.prodParam.hasIn || !this.match(58)) {
            this.raise(Errors.PrivateInExpectedIn, left, {
              identifierName: value
            });
          }
          this.classScope.usePrivateName(value, left.loc.start);
        }
        const op = this.state.type;
        if (tokenIsOperator(op) && (this.prodParam.hasIn || !this.match(58))) {
          let prec = tokenOperatorPrecedence(op);
          if (prec > minPrec) {
            if (op === 39) {
              this.expectPlugin("pipelineOperator");
              if (this.state.inFSharpPipelineDirectBody) {
                return left;
              }
              this.checkPipelineAtInfixOperator(left, leftStartLoc);
            }
            const node = this.startNodeAt(leftStartLoc);
            node.left = left;
            node.operator = this.state.value;
            const logical = op === 41 || op === 42;
            const coalesce = op === 40;
            if (coalesce) {
              prec = tokenOperatorPrecedence(42);
            }
            this.next();
            if (op === 39 && this.hasPlugin(["pipelineOperator", {
              proposal: "minimal"
            }])) {
              if (this.state.type === 96 && this.prodParam.hasAwait) {
                throw this.raise(Errors.UnexpectedAwaitAfterPipelineBody, this.state.startLoc);
              }
            }
            node.right = this.parseExprOpRightExpr(op, prec);
            const finishedNode = this.finishNode(node, logical || coalesce ? "LogicalExpression" : "BinaryExpression");
            const nextOp = this.state.type;
            if (coalesce && (nextOp === 41 || nextOp === 42) || logical && nextOp === 40) {
              throw this.raise(Errors.MixingCoalesceWithLogical, this.state.startLoc);
            }
            return this.parseExprOp(finishedNode, leftStartLoc, minPrec);
          }
        }
        return left;
      }
      parseExprOpRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        switch (op) {
          case 39:
            switch (this.getPluginOption("pipelineOperator", "proposal")) {
              case "hack":
                return this.withTopicBindingContext(() => {
                  return this.parseHackPipeBody();
                });
              case "smart":
                return this.withTopicBindingContext(() => {
                  if (this.prodParam.hasYield && this.isContextual(108)) {
                    throw this.raise(Errors.PipeBodyIsTighter, this.state.startLoc);
                  }
                  return this.parseSmartPipelineBodyInStyle(this.parseExprOpBaseRightExpr(op, prec), startLoc);
                });
              case "fsharp":
                return this.withSoloAwaitPermittingContext(() => {
                  return this.parseFSharpPipelineBody(prec);
                });
            }
          default:
            return this.parseExprOpBaseRightExpr(op, prec);
        }
      }
      parseExprOpBaseRightExpr(op, prec) {
        const startLoc = this.state.startLoc;
        return this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, tokenIsRightAssociative(op) ? prec - 1 : prec);
      }
      parseHackPipeBody() {
        var _body$extra;
        const {
          startLoc
        } = this.state;
        const body = this.parseMaybeAssign();
        const requiredParentheses = UnparenthesizedPipeBodyDescriptions.has(body.type);
        if (requiredParentheses && !((_body$extra = body.extra) != null && _body$extra.parenthesized)) {
          this.raise(Errors.PipeUnparenthesizedBody, startLoc, {
            type: body.type
          });
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipeTopicUnused, startLoc);
        }
        return body;
      }
      checkExponentialAfterUnary(node) {
        if (this.match(57)) {
          this.raise(Errors.UnexpectedTokenUnaryExponentiation, node.argument);
        }
      }
      parseMaybeUnary(refExpressionErrors, sawUnary) {
        const startLoc = this.state.startLoc;
        const isAwait = this.isContextual(96);
        if (isAwait && this.isAwaitAllowed()) {
          this.next();
          const expr2 = this.parseAwait(startLoc);
          if (!sawUnary) this.checkExponentialAfterUnary(expr2);
          return expr2;
        }
        const update = this.match(34);
        const node = this.startNode();
        if (tokenIsPrefix(this.state.type)) {
          node.operator = this.state.value;
          node.prefix = true;
          if (this.match(72)) {
            this.expectPlugin("throwExpressions");
          }
          const isDelete = this.match(89);
          this.next();
          node.argument = this.parseMaybeUnary(null, true);
          this.checkExpressionErrors(refExpressionErrors, true);
          if (this.state.strict && isDelete) {
            const arg = node.argument;
            if (arg.type === "Identifier") {
              this.raise(Errors.StrictDelete, node);
            } else if (this.hasPropertyAsPrivateName(arg)) {
              this.raise(Errors.DeletePrivateField, node);
            }
          }
          if (!update) {
            if (!sawUnary) {
              this.checkExponentialAfterUnary(node);
            }
            return this.finishNode(node, "UnaryExpression");
          }
        }
        const expr = this.parseUpdate(node, update, refExpressionErrors);
        if (isAwait) {
          const {
            type
          } = this.state;
          const startsExpr2 = this.hasPlugin("v8intrinsic") ? tokenCanStartExpression(type) : tokenCanStartExpression(type) && !this.match(54);
          if (startsExpr2 && !this.isAmbiguousAwait()) {
            this.raiseOverwrite(Errors.AwaitNotInAsyncContext, startLoc);
            return this.parseAwait(startLoc);
          }
        }
        return expr;
      }
      parseUpdate(node, update, refExpressionErrors) {
        if (update) {
          const updateExpressionNode = node;
          this.checkLVal(updateExpressionNode.argument, {
            in: this.finishNode(updateExpressionNode, "UpdateExpression")
          });
          return node;
        }
        const startLoc = this.state.startLoc;
        let expr = this.parseExprSubscripts(refExpressionErrors);
        if (this.checkExpressionErrors(refExpressionErrors, false)) return expr;
        while (tokenIsPostfix(this.state.type) && !this.canInsertSemicolon()) {
          const node2 = this.startNodeAt(startLoc);
          node2.operator = this.state.value;
          node2.prefix = false;
          node2.argument = expr;
          this.next();
          this.checkLVal(expr, {
            in: expr = this.finishNode(node2, "UpdateExpression")
          });
        }
        return expr;
      }
      parseExprSubscripts(refExpressionErrors) {
        const startLoc = this.state.startLoc;
        const potentialArrowAt = this.state.potentialArrowAt;
        const expr = this.parseExprAtom(refExpressionErrors);
        if (this.shouldExitDescending(expr, potentialArrowAt)) {
          return expr;
        }
        return this.parseSubscripts(expr, startLoc);
      }
      parseSubscripts(base, startLoc, noCalls) {
        const state = {
          optionalChainMember: false,
          maybeAsyncArrow: this.atPossibleAsyncArrow(base),
          stop: false
        };
        do {
          base = this.parseSubscript(base, startLoc, noCalls, state);
          state.maybeAsyncArrow = false;
        } while (!state.stop);
        return base;
      }
      parseSubscript(base, startLoc, noCalls, state) {
        const {
          type
        } = this.state;
        if (!noCalls && type === 15) {
          return this.parseBind(base, startLoc, noCalls, state);
        } else if (tokenIsTemplate(type)) {
          return this.parseTaggedTemplateExpression(base, startLoc, state);
        }
        let optional = false;
        if (type === 18) {
          if (noCalls) {
            this.raise(Errors.OptionalChainingNoNew, this.state.startLoc);
            if (this.lookaheadCharCode() === 40) {
              state.stop = true;
              return base;
            }
          }
          state.optionalChainMember = optional = true;
          this.next();
        }
        if (!noCalls && this.match(10)) {
          return this.parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional);
        } else {
          const computed = this.eat(0);
          if (computed || optional || this.eat(16)) {
            return this.parseMember(base, startLoc, state, computed, optional);
          } else {
            state.stop = true;
            return base;
          }
        }
      }
      parseMember(base, startLoc, state, computed, optional) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        node.computed = computed;
        if (computed) {
          node.property = this.parseExpression();
          this.expect(3);
        } else if (this.match(138)) {
          if (base.type === "Super") {
            this.raise(Errors.SuperPrivateField, startLoc);
          }
          this.classScope.usePrivateName(this.state.value, this.state.startLoc);
          node.property = this.parsePrivateName();
        } else {
          node.property = this.parseIdentifier(true);
        }
        if (state.optionalChainMember) {
          node.optional = optional;
          return this.finishNode(node, "OptionalMemberExpression");
        } else {
          return this.finishNode(node, "MemberExpression");
        }
      }
      parseBind(base, startLoc, noCalls, state) {
        const node = this.startNodeAt(startLoc);
        node.object = base;
        this.next();
        node.callee = this.parseNoCallExpr();
        state.stop = true;
        return this.parseSubscripts(this.finishNode(node, "BindExpression"), startLoc, noCalls);
      }
      parseCoverCallAndAsyncArrowHead(base, startLoc, state, optional) {
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        let refExpressionErrors = null;
        this.state.maybeInArrowParameters = true;
        this.next();
        const node = this.startNodeAt(startLoc);
        node.callee = base;
        const {
          maybeAsyncArrow,
          optionalChainMember
        } = state;
        if (maybeAsyncArrow) {
          this.expressionScope.enter(newAsyncArrowScope());
          refExpressionErrors = new ExpressionErrors();
        }
        if (optionalChainMember) {
          node.optional = optional;
        }
        if (optional) {
          node.arguments = this.parseCallExpressionArguments(11);
        } else {
          node.arguments = this.parseCallExpressionArguments(11, base.type === "Import", base.type !== "Super", node, refExpressionErrors);
        }
        let finishedNode = this.finishCallExpression(node, optionalChainMember);
        if (maybeAsyncArrow && this.shouldParseAsyncArrow() && !optional) {
          state.stop = true;
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          finishedNode = this.parseAsyncArrowFromCallExpression(this.startNodeAt(startLoc), finishedNode);
        } else {
          if (maybeAsyncArrow) {
            this.checkExpressionErrors(refExpressionErrors, true);
            this.expressionScope.exit();
          }
          this.toReferencedArguments(finishedNode);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return finishedNode;
      }
      toReferencedArguments(node, isParenthesizedExpr) {
        this.toReferencedListDeep(node.arguments, isParenthesizedExpr);
      }
      parseTaggedTemplateExpression(base, startLoc, state) {
        const node = this.startNodeAt(startLoc);
        node.tag = base;
        node.quasi = this.parseTemplate(true);
        if (state.optionalChainMember) {
          this.raise(Errors.OptionalChainingNoTemplate, startLoc);
        }
        return this.finishNode(node, "TaggedTemplateExpression");
      }
      atPossibleAsyncArrow(base) {
        return base.type === "Identifier" && base.name === "async" && this.state.lastTokEndLoc.index === base.end && !this.canInsertSemicolon() && base.end - base.start === 5 && base.start === this.state.potentialArrowAt;
      }
      expectImportAttributesPlugin() {
        if (!this.hasPlugin("importAssertions")) {
          this.expectPlugin("importAttributes");
        }
      }
      finishCallExpression(node, optional) {
        if (node.callee.type === "Import") {
          if (node.arguments.length === 2) {
            {
              if (!this.hasPlugin("moduleAttributes")) {
                this.expectImportAttributesPlugin();
              }
            }
          }
          if (node.arguments.length === 0 || node.arguments.length > 2) {
            this.raise(Errors.ImportCallArity, node, {
              maxArgumentCount: this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions") || this.hasPlugin("moduleAttributes") ? 2 : 1
            });
          } else {
            for (const arg of node.arguments) {
              if (arg.type === "SpreadElement") {
                this.raise(Errors.ImportCallSpreadArgument, arg);
              }
            }
          }
        }
        return this.finishNode(node, optional ? "OptionalCallExpression" : "CallExpression");
      }
      parseCallExpressionArguments(close, dynamicImport, allowPlaceholder, nodeForExtra, refExpressionErrors) {
        const elts = [];
        let first = true;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (dynamicImport && !this.hasPlugin("importAttributes") && !this.hasPlugin("importAssertions") && !this.hasPlugin("moduleAttributes")) {
                this.raise(Errors.ImportCallArgumentTrailingComma, this.state.lastTokStartLoc);
              }
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(false, refExpressionErrors, allowPlaceholder));
        }
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return elts;
      }
      shouldParseAsyncArrow() {
        return this.match(19) && !this.canInsertSemicolon();
      }
      parseAsyncArrowFromCallExpression(node, call) {
        var _call$extra;
        this.resetPreviousNodeTrailingComments(call);
        this.expect(19);
        this.parseArrowExpression(node, call.arguments, true, (_call$extra = call.extra) == null ? void 0 : _call$extra.trailingCommaLoc);
        if (call.innerComments) {
          setInnerComments(node, call.innerComments);
        }
        if (call.callee.trailingComments) {
          setInnerComments(node, call.callee.trailingComments);
        }
        return node;
      }
      parseNoCallExpr() {
        const startLoc = this.state.startLoc;
        return this.parseSubscripts(this.parseExprAtom(), startLoc, true);
      }
      parseExprAtom(refExpressionErrors) {
        let node;
        let decorators = null;
        const {
          type
        } = this.state;
        switch (type) {
          case 79:
            return this.parseSuper();
          case 83:
            node = this.startNode();
            this.next();
            if (this.match(16)) {
              return this.parseImportMetaProperty(node);
            }
            if (this.match(10)) {
              if (this.options.createImportExpressions) {
                return this.parseImportCall(node);
              } else {
                return this.finishNode(node, "Import");
              }
            } else {
              this.raise(Errors.UnsupportedImport, this.state.lastTokStartLoc);
              return this.finishNode(node, "Import");
            }
          case 78:
            node = this.startNode();
            this.next();
            return this.finishNode(node, "ThisExpression");
          case 90: {
            return this.parseDo(this.startNode(), false);
          }
          case 56:
          case 31: {
            this.readRegexp();
            return this.parseRegExpLiteral(this.state.value);
          }
          case 134:
            return this.parseNumericLiteral(this.state.value);
          case 135:
            return this.parseBigIntLiteral(this.state.value);
          case 136:
            return this.parseDecimalLiteral(this.state.value);
          case 133:
            return this.parseStringLiteral(this.state.value);
          case 84:
            return this.parseNullLiteral();
          case 85:
            return this.parseBooleanLiteral(true);
          case 86:
            return this.parseBooleanLiteral(false);
          case 10: {
            const canBeArrow = this.state.potentialArrowAt === this.state.start;
            return this.parseParenAndDistinguishExpression(canBeArrow);
          }
          case 2:
          case 1: {
            return this.parseArrayLike(this.state.type === 2 ? 4 : 3, false, true);
          }
          case 0: {
            return this.parseArrayLike(3, true, false, refExpressionErrors);
          }
          case 6:
          case 7: {
            return this.parseObjectLike(this.state.type === 6 ? 9 : 8, false, true);
          }
          case 5: {
            return this.parseObjectLike(8, false, false, refExpressionErrors);
          }
          case 68:
            return this.parseFunctionOrFunctionSent();
          case 26:
            decorators = this.parseDecorators();
          case 80:
            return this.parseClass(this.maybeTakeDecorators(decorators, this.startNode()), false);
          case 77:
            return this.parseNewOrNewTarget();
          case 25:
          case 24:
            return this.parseTemplate(false);
          case 15: {
            node = this.startNode();
            this.next();
            node.object = null;
            const callee = node.callee = this.parseNoCallExpr();
            if (callee.type === "MemberExpression") {
              return this.finishNode(node, "BindExpression");
            } else {
              throw this.raise(Errors.UnsupportedBind, callee);
            }
          }
          case 138: {
            this.raise(Errors.PrivateInExpectedIn, this.state.startLoc, {
              identifierName: this.state.value
            });
            return this.parsePrivateName();
          }
          case 33: {
            return this.parseTopicReferenceThenEqualsSign(54, "%");
          }
          case 32: {
            return this.parseTopicReferenceThenEqualsSign(44, "^");
          }
          case 37:
          case 38: {
            return this.parseTopicReference("hack");
          }
          case 44:
          case 54:
          case 27: {
            const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
            if (pipeProposal) {
              return this.parseTopicReference(pipeProposal);
            }
            this.unexpected();
            break;
          }
          case 47: {
            const lookaheadCh = this.input.codePointAt(this.nextTokenStart());
            if (isIdentifierStart(lookaheadCh) || lookaheadCh === 62) {
              this.expectOnePlugin(["jsx", "flow", "typescript"]);
            } else {
              this.unexpected();
            }
            break;
          }
          default:
            if (tokenIsIdentifier(type)) {
              if (this.isContextual(127) && this.lookaheadInLineCharCode() === 123) {
                return this.parseModuleExpression();
              }
              const canBeArrow = this.state.potentialArrowAt === this.state.start;
              const containsEsc = this.state.containsEsc;
              const id = this.parseIdentifier();
              if (!containsEsc && id.name === "async" && !this.canInsertSemicolon()) {
                const {
                  type: type2
                } = this.state;
                if (type2 === 68) {
                  this.resetPreviousNodeTrailingComments(id);
                  this.next();
                  return this.parseAsyncFunctionExpression(this.startNodeAtNode(id));
                } else if (tokenIsIdentifier(type2)) {
                  if (this.lookaheadCharCode() === 61) {
                    return this.parseAsyncArrowUnaryFunction(this.startNodeAtNode(id));
                  } else {
                    return id;
                  }
                } else if (type2 === 90) {
                  this.resetPreviousNodeTrailingComments(id);
                  return this.parseDo(this.startNodeAtNode(id), true);
                }
              }
              if (canBeArrow && this.match(19) && !this.canInsertSemicolon()) {
                this.next();
                return this.parseArrowExpression(this.startNodeAtNode(id), [id], false);
              }
              return id;
            } else {
              this.unexpected();
            }
        }
      }
      parseTopicReferenceThenEqualsSign(topicTokenType, topicTokenValue) {
        const pipeProposal = this.getPluginOption("pipelineOperator", "proposal");
        if (pipeProposal) {
          this.state.type = topicTokenType;
          this.state.value = topicTokenValue;
          this.state.pos--;
          this.state.end--;
          this.state.endLoc = createPositionWithColumnOffset(this.state.endLoc, -1);
          return this.parseTopicReference(pipeProposal);
        } else {
          this.unexpected();
        }
      }
      parseTopicReference(pipeProposal) {
        const node = this.startNode();
        const startLoc = this.state.startLoc;
        const tokenType = this.state.type;
        this.next();
        return this.finishTopicReference(node, startLoc, pipeProposal, tokenType);
      }
      finishTopicReference(node, startLoc, pipeProposal, tokenType) {
        if (this.testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType)) {
          const nodeType = pipeProposal === "smart" ? "PipelinePrimaryTopicReference" : "TopicReference";
          if (!this.topicReferenceIsAllowedInCurrentContext()) {
            this.raise(pipeProposal === "smart" ? Errors.PrimaryTopicNotAllowed : Errors.PipeTopicUnbound, startLoc);
          }
          this.registerTopicReference();
          return this.finishNode(node, nodeType);
        } else {
          throw this.raise(Errors.PipeTopicUnconfiguredToken, startLoc, {
            token: tokenLabelName(tokenType)
          });
        }
      }
      testTopicReferenceConfiguration(pipeProposal, startLoc, tokenType) {
        switch (pipeProposal) {
          case "hack": {
            return this.hasPlugin(["pipelineOperator", {
              topicToken: tokenLabelName(tokenType)
            }]);
          }
          case "smart":
            return tokenType === 27;
          default:
            throw this.raise(Errors.PipeTopicRequiresHackPipes, startLoc);
        }
      }
      parseAsyncArrowUnaryFunction(node) {
        this.prodParam.enter(functionFlags(true, this.prodParam.hasYield));
        const params = [this.parseIdentifier()];
        this.prodParam.exit();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.LineTerminatorBeforeArrow, this.state.curPosition());
        }
        this.expect(19);
        return this.parseArrowExpression(node, params, true);
      }
      parseDo(node, isAsync) {
        this.expectPlugin("doExpressions");
        if (isAsync) {
          this.expectPlugin("asyncDoExpressions");
        }
        node.async = isAsync;
        this.next();
        const oldLabels = this.state.labels;
        this.state.labels = [];
        if (isAsync) {
          this.prodParam.enter(2);
          node.body = this.parseBlock();
          this.prodParam.exit();
        } else {
          node.body = this.parseBlock();
        }
        this.state.labels = oldLabels;
        return this.finishNode(node, "DoExpression");
      }
      parseSuper() {
        const node = this.startNode();
        this.next();
        if (this.match(10) && !this.scope.allowDirectSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(Errors.SuperNotAllowed, node);
        } else if (!this.scope.allowSuper && !this.options.allowSuperOutsideMethod) {
          this.raise(Errors.UnexpectedSuper, node);
        }
        if (!this.match(10) && !this.match(0) && !this.match(16)) {
          this.raise(Errors.UnsupportedSuper, node);
        }
        return this.finishNode(node, "Super");
      }
      parsePrivateName() {
        const node = this.startNode();
        const id = this.startNodeAt(createPositionWithColumnOffset(this.state.startLoc, 1));
        const name = this.state.value;
        this.next();
        node.id = this.createIdentifier(id, name);
        return this.finishNode(node, "PrivateName");
      }
      parseFunctionOrFunctionSent() {
        const node = this.startNode();
        this.next();
        if (this.prodParam.hasYield && this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "function");
          this.next();
          if (this.match(103)) {
            this.expectPlugin("functionSent");
          } else if (!this.hasPlugin("functionSent")) {
            this.unexpected();
          }
          return this.parseMetaProperty(node, meta, "sent");
        }
        return this.parseFunction(node);
      }
      parseMetaProperty(node, meta, propertyName) {
        node.meta = meta;
        const containsEsc = this.state.containsEsc;
        node.property = this.parseIdentifier(true);
        if (node.property.name !== propertyName || containsEsc) {
          this.raise(Errors.UnsupportedMetaProperty, node.property, {
            target: meta.name,
            onlyValidPropertyName: propertyName
          });
        }
        return this.finishNode(node, "MetaProperty");
      }
      parseImportMetaProperty(node) {
        const id = this.createIdentifier(this.startNodeAtNode(node), "import");
        this.next();
        if (this.isContextual(101)) {
          if (!this.inModule) {
            this.raise(Errors.ImportMetaOutsideModule, id);
          }
          this.sawUnambiguousESM = true;
        } else if (this.isContextual(105) || this.isContextual(97)) {
          const isSource = this.isContextual(105);
          if (!isSource) this.unexpected();
          this.expectPlugin(isSource ? "sourcePhaseImports" : "deferredImportEvaluation");
          if (!this.options.createImportExpressions) {
            throw this.raise(Errors.DynamicImportPhaseRequiresImportExpressions, this.state.startLoc, {
              phase: this.state.value
            });
          }
          this.next();
          node.phase = isSource ? "source" : "defer";
          return this.parseImportCall(node);
        }
        return this.parseMetaProperty(node, id, "meta");
      }
      parseLiteralAtNode(value, type, node) {
        this.addExtra(node, "rawValue", value);
        this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
        node.value = value;
        this.next();
        return this.finishNode(node, type);
      }
      parseLiteral(value, type) {
        const node = this.startNode();
        return this.parseLiteralAtNode(value, type, node);
      }
      parseStringLiteral(value) {
        return this.parseLiteral(value, "StringLiteral");
      }
      parseNumericLiteral(value) {
        return this.parseLiteral(value, "NumericLiteral");
      }
      parseBigIntLiteral(value) {
        return this.parseLiteral(value, "BigIntLiteral");
      }
      parseDecimalLiteral(value) {
        return this.parseLiteral(value, "DecimalLiteral");
      }
      parseRegExpLiteral(value) {
        const node = this.startNode();
        this.addExtra(node, "raw", this.input.slice(node.start, this.state.end));
        node.pattern = value.pattern;
        node.flags = value.flags;
        this.next();
        return this.finishNode(node, "RegExpLiteral");
      }
      parseBooleanLiteral(value) {
        const node = this.startNode();
        node.value = value;
        this.next();
        return this.finishNode(node, "BooleanLiteral");
      }
      parseNullLiteral() {
        const node = this.startNode();
        this.next();
        return this.finishNode(node, "NullLiteral");
      }
      parseParenAndDistinguishExpression(canBeArrow) {
        const startLoc = this.state.startLoc;
        let val;
        this.next();
        this.expressionScope.enter(newArrowHeadScope());
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.maybeInArrowParameters = true;
        this.state.inFSharpPipelineDirectBody = false;
        const innerStartLoc = this.state.startLoc;
        const exprList = [];
        const refExpressionErrors = new ExpressionErrors();
        let first = true;
        let spreadStartLoc;
        let optionalCommaStartLoc;
        while (!this.match(11)) {
          if (first) {
            first = false;
          } else {
            this.expect(12, refExpressionErrors.optionalParametersLoc === null ? null : refExpressionErrors.optionalParametersLoc);
            if (this.match(11)) {
              optionalCommaStartLoc = this.state.startLoc;
              break;
            }
          }
          if (this.match(21)) {
            const spreadNodeStartLoc = this.state.startLoc;
            spreadStartLoc = this.state.startLoc;
            exprList.push(this.parseParenItem(this.parseRestBinding(), spreadNodeStartLoc));
            if (!this.checkCommaAfterRest(41)) {
              break;
            }
          } else {
            exprList.push(this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem));
          }
        }
        const innerEndLoc = this.state.lastTokEndLoc;
        this.expect(11);
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let arrowNode = this.startNodeAt(startLoc);
        if (canBeArrow && this.shouldParseArrow(exprList) && (arrowNode = this.parseArrow(arrowNode))) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.expressionScope.validateAsPattern();
          this.expressionScope.exit();
          this.parseArrowExpression(arrowNode, exprList, false);
          return arrowNode;
        }
        this.expressionScope.exit();
        if (!exprList.length) {
          this.unexpected(this.state.lastTokStartLoc);
        }
        if (optionalCommaStartLoc) this.unexpected(optionalCommaStartLoc);
        if (spreadStartLoc) this.unexpected(spreadStartLoc);
        this.checkExpressionErrors(refExpressionErrors, true);
        this.toReferencedListDeep(exprList, true);
        if (exprList.length > 1) {
          val = this.startNodeAt(innerStartLoc);
          val.expressions = exprList;
          this.finishNode(val, "SequenceExpression");
          this.resetEndLocation(val, innerEndLoc);
        } else {
          val = exprList[0];
        }
        return this.wrapParenthesis(startLoc, val);
      }
      wrapParenthesis(startLoc, expression) {
        if (!this.options.createParenthesizedExpressions) {
          this.addExtra(expression, "parenthesized", true);
          this.addExtra(expression, "parenStart", startLoc.index);
          this.takeSurroundingComments(expression, startLoc.index, this.state.lastTokEndLoc.index);
          return expression;
        }
        const parenExpression = this.startNodeAt(startLoc);
        parenExpression.expression = expression;
        return this.finishNode(parenExpression, "ParenthesizedExpression");
      }
      shouldParseArrow(params) {
        return !this.canInsertSemicolon();
      }
      parseArrow(node) {
        if (this.eat(19)) {
          return node;
        }
      }
      parseParenItem(node, startLoc) {
        return node;
      }
      parseNewOrNewTarget() {
        const node = this.startNode();
        this.next();
        if (this.match(16)) {
          const meta = this.createIdentifier(this.startNodeAtNode(node), "new");
          this.next();
          const metaProp = this.parseMetaProperty(node, meta, "target");
          if (!this.scope.inNonArrowFunction && !this.scope.inClass && !this.options.allowNewTargetOutsideFunction) {
            this.raise(Errors.UnexpectedNewTarget, metaProp);
          }
          return metaProp;
        }
        return this.parseNew(node);
      }
      parseNew(node) {
        this.parseNewCallee(node);
        if (this.eat(10)) {
          const args = this.parseExprList(11);
          this.toReferencedList(args);
          node.arguments = args;
        } else {
          node.arguments = [];
        }
        return this.finishNode(node, "NewExpression");
      }
      parseNewCallee(node) {
        const isImport = this.match(83);
        const callee = this.parseNoCallExpr();
        node.callee = callee;
        if (isImport && (callee.type === "Import" || callee.type === "ImportExpression")) {
          this.raise(Errors.ImportCallNotNewExpression, callee);
        }
      }
      parseTemplateElement(isTagged) {
        const {
          start,
          startLoc,
          end,
          value
        } = this.state;
        const elemStart = start + 1;
        const elem = this.startNodeAt(createPositionWithColumnOffset(startLoc, 1));
        if (value === null) {
          if (!isTagged) {
            this.raise(Errors.InvalidEscapeSequenceTemplate, createPositionWithColumnOffset(this.state.firstInvalidTemplateEscapePos, 1));
          }
        }
        const isTail = this.match(24);
        const endOffset = isTail ? -1 : -2;
        const elemEnd = end + endOffset;
        elem.value = {
          raw: this.input.slice(elemStart, elemEnd).replace(/\r\n?/g, "\n"),
          cooked: value === null ? null : value.slice(1, endOffset)
        };
        elem.tail = isTail;
        this.next();
        const finishedNode = this.finishNode(elem, "TemplateElement");
        this.resetEndLocation(finishedNode, createPositionWithColumnOffset(this.state.lastTokEndLoc, endOffset));
        return finishedNode;
      }
      parseTemplate(isTagged) {
        const node = this.startNode();
        let curElt = this.parseTemplateElement(isTagged);
        const quasis = [curElt];
        const substitutions = [];
        while (!curElt.tail) {
          substitutions.push(this.parseTemplateSubstitution());
          this.readTemplateContinuation();
          quasis.push(curElt = this.parseTemplateElement(isTagged));
        }
        node.expressions = substitutions;
        node.quasis = quasis;
        return this.finishNode(node, "TemplateLiteral");
      }
      parseTemplateSubstitution() {
        return this.parseExpression();
      }
      parseObjectLike(close, isPattern, isRecord, refExpressionErrors) {
        if (isRecord) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const propHash = /* @__PURE__ */ Object.create(null);
        let first = true;
        const node = this.startNode();
        node.properties = [];
        this.next();
        while (!this.match(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              this.addTrailingCommaExtraToNode(node);
              break;
            }
          }
          let prop;
          if (isPattern) {
            prop = this.parseBindingProperty();
          } else {
            prop = this.parsePropertyDefinition(refExpressionErrors);
            this.checkProto(prop, isRecord, propHash, refExpressionErrors);
          }
          if (isRecord && !this.isObjectProperty(prop) && prop.type !== "SpreadElement") {
            this.raise(Errors.InvalidRecordProperty, prop);
          }
          {
            if (prop.shorthand) {
              this.addExtra(prop, "shorthand", true);
            }
          }
          node.properties.push(prop);
        }
        this.next();
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        let type = "ObjectExpression";
        if (isPattern) {
          type = "ObjectPattern";
        } else if (isRecord) {
          type = "RecordExpression";
        }
        return this.finishNode(node, type);
      }
      addTrailingCommaExtraToNode(node) {
        this.addExtra(node, "trailingComma", this.state.lastTokStartLoc.index);
        this.addExtra(node, "trailingCommaLoc", this.state.lastTokStartLoc, false);
      }
      maybeAsyncOrAccessorProp(prop) {
        return !prop.computed && prop.key.type === "Identifier" && (this.isLiteralPropertyName() || this.match(0) || this.match(55));
      }
      parsePropertyDefinition(refExpressionErrors) {
        let decorators = [];
        if (this.match(26)) {
          if (this.hasPlugin("decorators")) {
            this.raise(Errors.UnsupportedPropertyDecorator, this.state.startLoc);
          }
          while (this.match(26)) {
            decorators.push(this.parseDecorator());
          }
        }
        const prop = this.startNode();
        let isAsync = false;
        let isAccessor = false;
        let startLoc;
        if (this.match(21)) {
          if (decorators.length) this.unexpected();
          return this.parseSpread();
        }
        if (decorators.length) {
          prop.decorators = decorators;
          decorators = [];
        }
        prop.method = false;
        if (refExpressionErrors) {
          startLoc = this.state.startLoc;
        }
        let isGenerator = this.eat(55);
        this.parsePropertyNamePrefixOperator(prop);
        const containsEsc = this.state.containsEsc;
        this.parsePropertyName(prop, refExpressionErrors);
        if (!isGenerator && !containsEsc && this.maybeAsyncOrAccessorProp(prop)) {
          const {
            key
          } = prop;
          const keyName = key.name;
          if (keyName === "async" && !this.hasPrecedingLineBreak()) {
            isAsync = true;
            this.resetPreviousNodeTrailingComments(key);
            isGenerator = this.eat(55);
            this.parsePropertyName(prop);
          }
          if (keyName === "get" || keyName === "set") {
            isAccessor = true;
            this.resetPreviousNodeTrailingComments(key);
            prop.kind = keyName;
            if (this.match(55)) {
              isGenerator = true;
              this.raise(Errors.AccessorIsGenerator, this.state.curPosition(), {
                kind: keyName
              });
              this.next();
            }
            this.parsePropertyName(prop);
          }
        }
        return this.parseObjPropValue(prop, startLoc, isGenerator, isAsync, false, isAccessor, refExpressionErrors);
      }
      getGetterSetterExpectedParamCount(method) {
        return method.kind === "get" ? 0 : 1;
      }
      getObjectOrClassMethodParams(method) {
        return method.params;
      }
      checkGetterSetterParams(method) {
        var _params;
        const paramCount = this.getGetterSetterExpectedParamCount(method);
        const params = this.getObjectOrClassMethodParams(method);
        if (params.length !== paramCount) {
          this.raise(method.kind === "get" ? Errors.BadGetterArity : Errors.BadSetterArity, method);
        }
        if (method.kind === "set" && ((_params = params[params.length - 1]) == null ? void 0 : _params.type) === "RestElement") {
          this.raise(Errors.BadSetterRestParameter, method);
        }
      }
      parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) {
        if (isAccessor) {
          const finishedProp = this.parseMethod(prop, isGenerator, false, false, false, "ObjectMethod");
          this.checkGetterSetterParams(finishedProp);
          return finishedProp;
        }
        if (isAsync || isGenerator || this.match(10)) {
          if (isPattern) this.unexpected();
          prop.kind = "method";
          prop.method = true;
          return this.parseMethod(prop, isGenerator, isAsync, false, false, "ObjectMethod");
        }
      }
      parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors) {
        prop.shorthand = false;
        if (this.eat(14)) {
          prop.value = isPattern ? this.parseMaybeDefault(this.state.startLoc) : this.parseMaybeAssignAllowIn(refExpressionErrors);
          return this.finishNode(prop, "ObjectProperty");
        }
        if (!prop.computed && prop.key.type === "Identifier") {
          this.checkReservedWord(prop.key.name, prop.key.loc.start, true, false);
          if (isPattern) {
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else if (this.match(29)) {
            const shorthandAssignLoc = this.state.startLoc;
            if (refExpressionErrors != null) {
              if (refExpressionErrors.shorthandAssignLoc === null) {
                refExpressionErrors.shorthandAssignLoc = shorthandAssignLoc;
              }
            } else {
              this.raise(Errors.InvalidCoverInitializedName, shorthandAssignLoc);
            }
            prop.value = this.parseMaybeDefault(startLoc, cloneIdentifier(prop.key));
          } else {
            prop.value = cloneIdentifier(prop.key);
          }
          prop.shorthand = true;
          return this.finishNode(prop, "ObjectProperty");
        }
      }
      parseObjPropValue(prop, startLoc, isGenerator, isAsync, isPattern, isAccessor, refExpressionErrors) {
        const node = this.parseObjectMethod(prop, isGenerator, isAsync, isPattern, isAccessor) || this.parseObjectProperty(prop, startLoc, isPattern, refExpressionErrors);
        if (!node) this.unexpected();
        return node;
      }
      parsePropertyName(prop, refExpressionErrors) {
        if (this.eat(0)) {
          prop.computed = true;
          prop.key = this.parseMaybeAssignAllowIn();
          this.expect(3);
        } else {
          const {
            type,
            value
          } = this.state;
          let key;
          if (tokenIsKeywordOrIdentifier(type)) {
            key = this.parseIdentifier(true);
          } else {
            switch (type) {
              case 134:
                key = this.parseNumericLiteral(value);
                break;
              case 133:
                key = this.parseStringLiteral(value);
                break;
              case 135:
                key = this.parseBigIntLiteral(value);
                break;
              case 136:
                key = this.parseDecimalLiteral(value);
                break;
              case 138: {
                const privateKeyLoc = this.state.startLoc;
                if (refExpressionErrors != null) {
                  if (refExpressionErrors.privateKeyLoc === null) {
                    refExpressionErrors.privateKeyLoc = privateKeyLoc;
                  }
                } else {
                  this.raise(Errors.UnexpectedPrivateField, privateKeyLoc);
                }
                key = this.parsePrivateName();
                break;
              }
              default:
                this.unexpected();
            }
          }
          prop.key = key;
          if (type !== 138) {
            prop.computed = false;
          }
        }
      }
      initFunction(node, isAsync) {
        node.id = null;
        node.generator = false;
        node.async = isAsync;
      }
      parseMethod(node, isGenerator, isAsync, isConstructor, allowDirectSuper, type, inClassScope = false) {
        this.initFunction(node, isAsync);
        node.generator = isGenerator;
        this.scope.enter(2 | 16 | (inClassScope ? 64 : 0) | (allowDirectSuper ? 32 : 0));
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        this.parseFunctionParams(node, isConstructor);
        const finishedNode = this.parseFunctionBodyAndFinish(node, type, true);
        this.prodParam.exit();
        this.scope.exit();
        return finishedNode;
      }
      parseArrayLike(close, canBePattern, isTuple, refExpressionErrors) {
        if (isTuple) {
          this.expectPlugin("recordAndTuple");
        }
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = false;
        const node = this.startNode();
        this.next();
        node.elements = this.parseExprList(close, !isTuple, refExpressionErrors, node);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return this.finishNode(node, isTuple ? "TupleExpression" : "ArrayExpression");
      }
      parseArrowExpression(node, params, isAsync, trailingCommaLoc) {
        this.scope.enter(2 | 4);
        let flags = functionFlags(isAsync, false);
        if (!this.match(5) && this.prodParam.hasIn) {
          flags |= 8;
        }
        this.prodParam.enter(flags);
        this.initFunction(node, isAsync);
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        if (params) {
          this.state.maybeInArrowParameters = true;
          this.setArrowFunctionParameters(node, params, trailingCommaLoc);
        }
        this.state.maybeInArrowParameters = false;
        this.parseFunctionBody(node, true);
        this.prodParam.exit();
        this.scope.exit();
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return this.finishNode(node, "ArrowFunctionExpression");
      }
      setArrowFunctionParameters(node, params, trailingCommaLoc) {
        this.toAssignableList(params, trailingCommaLoc, false);
        node.params = params;
      }
      parseFunctionBodyAndFinish(node, type, isMethod = false) {
        this.parseFunctionBody(node, false, isMethod);
        return this.finishNode(node, type);
      }
      parseFunctionBody(node, allowExpression, isMethod = false) {
        const isExpression = allowExpression && !this.match(5);
        this.expressionScope.enter(newExpressionScope());
        if (isExpression) {
          node.body = this.parseMaybeAssign();
          this.checkParams(node, false, allowExpression, false);
        } else {
          const oldStrict = this.state.strict;
          const oldLabels = this.state.labels;
          this.state.labels = [];
          this.prodParam.enter(this.prodParam.currentFlags() | 4);
          node.body = this.parseBlock(true, false, (hasStrictModeDirective) => {
            const nonSimple = !this.isSimpleParamList(node.params);
            if (hasStrictModeDirective && nonSimple) {
              this.raise(Errors.IllegalLanguageModeDirective, (node.kind === "method" || node.kind === "constructor") && !!node.key ? node.key.loc.end : node);
            }
            const strictModeChanged = !oldStrict && this.state.strict;
            this.checkParams(node, !this.state.strict && !allowExpression && !isMethod && !nonSimple, allowExpression, strictModeChanged);
            if (this.state.strict && node.id) {
              this.checkIdentifier(node.id, 65, strictModeChanged);
            }
          });
          this.prodParam.exit();
          this.state.labels = oldLabels;
        }
        this.expressionScope.exit();
      }
      isSimpleParameter(node) {
        return node.type === "Identifier";
      }
      isSimpleParamList(params) {
        for (let i = 0, len = params.length; i < len; i++) {
          if (!this.isSimpleParameter(params[i])) return false;
        }
        return true;
      }
      checkParams(node, allowDuplicates, isArrowFunction, strictModeChanged = true) {
        const checkClashes = !allowDuplicates && /* @__PURE__ */ new Set();
        const formalParameters = {
          type: "FormalParameters"
        };
        for (const param of node.params) {
          this.checkLVal(param, {
            in: formalParameters,
            binding: 5,
            checkClashes,
            strictModeChanged
          });
        }
      }
      parseExprList(close, allowEmpty, refExpressionErrors, nodeForExtra) {
        const elts = [];
        let first = true;
        while (!this.eat(close)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.match(close)) {
              if (nodeForExtra) {
                this.addTrailingCommaExtraToNode(nodeForExtra);
              }
              this.next();
              break;
            }
          }
          elts.push(this.parseExprListItem(allowEmpty, refExpressionErrors));
        }
        return elts;
      }
      parseExprListItem(allowEmpty, refExpressionErrors, allowPlaceholder) {
        let elt;
        if (this.match(12)) {
          if (!allowEmpty) {
            this.raise(Errors.UnexpectedToken, this.state.curPosition(), {
              unexpected: ","
            });
          }
          elt = null;
        } else if (this.match(21)) {
          const spreadNodeStartLoc = this.state.startLoc;
          elt = this.parseParenItem(this.parseSpread(refExpressionErrors), spreadNodeStartLoc);
        } else if (this.match(17)) {
          this.expectPlugin("partialApplication");
          if (!allowPlaceholder) {
            this.raise(Errors.UnexpectedArgumentPlaceholder, this.state.startLoc);
          }
          const node = this.startNode();
          this.next();
          elt = this.finishNode(node, "ArgumentPlaceholder");
        } else {
          elt = this.parseMaybeAssignAllowIn(refExpressionErrors, this.parseParenItem);
        }
        return elt;
      }
      parseIdentifier(liberal) {
        const node = this.startNode();
        const name = this.parseIdentifierName(liberal);
        return this.createIdentifier(node, name);
      }
      createIdentifier(node, name) {
        node.name = name;
        node.loc.identifierName = name;
        return this.finishNode(node, "Identifier");
      }
      parseIdentifierName(liberal) {
        let name;
        const {
          startLoc,
          type
        } = this.state;
        if (tokenIsKeywordOrIdentifier(type)) {
          name = this.state.value;
        } else {
          this.unexpected();
        }
        const tokenIsKeyword2 = tokenKeywordOrIdentifierIsKeyword(type);
        if (liberal) {
          if (tokenIsKeyword2) {
            this.replaceToken(132);
          }
        } else {
          this.checkReservedWord(name, startLoc, tokenIsKeyword2, false);
        }
        this.next();
        return name;
      }
      checkReservedWord(word, startLoc, checkKeywords, isBinding) {
        if (word.length > 10) {
          return;
        }
        if (!canBeReservedWord(word)) {
          return;
        }
        if (checkKeywords && isKeyword(word)) {
          this.raise(Errors.UnexpectedKeyword, startLoc, {
            keyword: word
          });
          return;
        }
        const reservedTest = !this.state.strict ? isReservedWord : isBinding ? isStrictBindReservedWord : isStrictReservedWord;
        if (reservedTest(word, this.inModule)) {
          this.raise(Errors.UnexpectedReservedWord, startLoc, {
            reservedWord: word
          });
          return;
        } else if (word === "yield") {
          if (this.prodParam.hasYield) {
            this.raise(Errors.YieldBindingIdentifier, startLoc);
            return;
          }
        } else if (word === "await") {
          if (this.prodParam.hasAwait) {
            this.raise(Errors.AwaitBindingIdentifier, startLoc);
            return;
          }
          if (this.scope.inStaticBlock) {
            this.raise(Errors.AwaitBindingIdentifierInStaticBlock, startLoc);
            return;
          }
          this.expressionScope.recordAsyncArrowParametersError(startLoc);
        } else if (word === "arguments") {
          if (this.scope.inClassAndNotInNonArrowFunction) {
            this.raise(Errors.ArgumentsInClass, startLoc);
            return;
          }
        }
      }
      isAwaitAllowed() {
        if (this.prodParam.hasAwait) return true;
        if (this.options.allowAwaitOutsideFunction && !this.scope.inFunction) {
          return true;
        }
        return false;
      }
      parseAwait(startLoc) {
        const node = this.startNodeAt(startLoc);
        this.expressionScope.recordParameterInitializerError(Errors.AwaitExpressionFormalParameter, node);
        if (this.eat(55)) {
          this.raise(Errors.ObsoleteAwaitStar, node);
        }
        if (!this.scope.inFunction && !this.options.allowAwaitOutsideFunction) {
          if (this.isAmbiguousAwait()) {
            this.ambiguousScriptDifferentAst = true;
          } else {
            this.sawUnambiguousESM = true;
          }
        }
        if (!this.state.soloAwait) {
          node.argument = this.parseMaybeUnary(null, true);
        }
        return this.finishNode(node, "AwaitExpression");
      }
      isAmbiguousAwait() {
        if (this.hasPrecedingLineBreak()) return true;
        const {
          type
        } = this.state;
        return type === 53 || type === 10 || type === 0 || tokenIsTemplate(type) || type === 102 && !this.state.containsEsc || type === 137 || type === 56 || this.hasPlugin("v8intrinsic") && type === 54;
      }
      parseYield() {
        const node = this.startNode();
        this.expressionScope.recordParameterInitializerError(Errors.YieldInParameter, node);
        this.next();
        let delegating = false;
        let argument = null;
        if (!this.hasPrecedingLineBreak()) {
          delegating = this.eat(55);
          switch (this.state.type) {
            case 13:
            case 139:
            case 8:
            case 11:
            case 3:
            case 9:
            case 14:
            case 12:
              if (!delegating) break;
            default:
              argument = this.parseMaybeAssign();
          }
        }
        node.delegate = delegating;
        node.argument = argument;
        return this.finishNode(node, "YieldExpression");
      }
      parseImportCall(node) {
        this.next();
        node.source = this.parseMaybeAssignAllowIn();
        if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          node.options = null;
        }
        if (this.eat(12)) {
          this.expectImportAttributesPlugin();
          if (!this.match(11)) {
            node.options = this.parseMaybeAssignAllowIn();
            this.eat(12);
          }
        }
        this.expect(11);
        return this.finishNode(node, "ImportExpression");
      }
      checkPipelineAtInfixOperator(left, leftStartLoc) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          if (left.type === "SequenceExpression") {
            this.raise(Errors.PipelineHeadSequenceExpression, leftStartLoc);
          }
        }
      }
      parseSmartPipelineBodyInStyle(childExpr, startLoc) {
        if (this.isSimpleReference(childExpr)) {
          const bodyNode = this.startNodeAt(startLoc);
          bodyNode.callee = childExpr;
          return this.finishNode(bodyNode, "PipelineBareFunction");
        } else {
          const bodyNode = this.startNodeAt(startLoc);
          this.checkSmartPipeTopicBodyEarlyErrors(startLoc);
          bodyNode.expression = childExpr;
          return this.finishNode(bodyNode, "PipelineTopicExpression");
        }
      }
      isSimpleReference(expression) {
        switch (expression.type) {
          case "MemberExpression":
            return !expression.computed && this.isSimpleReference(expression.object);
          case "Identifier":
            return true;
          default:
            return false;
        }
      }
      checkSmartPipeTopicBodyEarlyErrors(startLoc) {
        if (this.match(19)) {
          throw this.raise(Errors.PipelineBodyNoArrow, this.state.startLoc);
        }
        if (!this.topicReferenceWasUsedInCurrentContext()) {
          this.raise(Errors.PipelineTopicUnused, startLoc);
        }
      }
      withTopicBindingContext(callback) {
        const outerContextTopicState = this.state.topicContext;
        this.state.topicContext = {
          maxNumOfResolvableTopics: 1,
          maxTopicIndex: null
        };
        try {
          return callback();
        } finally {
          this.state.topicContext = outerContextTopicState;
        }
      }
      withSmartMixTopicForbiddingContext(callback) {
        if (this.hasPlugin(["pipelineOperator", {
          proposal: "smart"
        }])) {
          const outerContextTopicState = this.state.topicContext;
          this.state.topicContext = {
            maxNumOfResolvableTopics: 0,
            maxTopicIndex: null
          };
          try {
            return callback();
          } finally {
            this.state.topicContext = outerContextTopicState;
          }
        } else {
          return callback();
        }
      }
      withSoloAwaitPermittingContext(callback) {
        const outerContextSoloAwaitState = this.state.soloAwait;
        this.state.soloAwait = true;
        try {
          return callback();
        } finally {
          this.state.soloAwait = outerContextSoloAwaitState;
        }
      }
      allowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToSet = 8 & ~flags;
        if (prodParamToSet) {
          this.prodParam.enter(flags | 8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      disallowInAnd(callback) {
        const flags = this.prodParam.currentFlags();
        const prodParamToClear = 8 & flags;
        if (prodParamToClear) {
          this.prodParam.enter(flags & ~8);
          try {
            return callback();
          } finally {
            this.prodParam.exit();
          }
        }
        return callback();
      }
      registerTopicReference() {
        this.state.topicContext.maxTopicIndex = 0;
      }
      topicReferenceIsAllowedInCurrentContext() {
        return this.state.topicContext.maxNumOfResolvableTopics >= 1;
      }
      topicReferenceWasUsedInCurrentContext() {
        return this.state.topicContext.maxTopicIndex != null && this.state.topicContext.maxTopicIndex >= 0;
      }
      parseFSharpPipelineBody(prec) {
        const startLoc = this.state.startLoc;
        this.state.potentialArrowAt = this.state.start;
        const oldInFSharpPipelineDirectBody = this.state.inFSharpPipelineDirectBody;
        this.state.inFSharpPipelineDirectBody = true;
        const ret = this.parseExprOp(this.parseMaybeUnaryOrPrivate(), startLoc, prec);
        this.state.inFSharpPipelineDirectBody = oldInFSharpPipelineDirectBody;
        return ret;
      }
      parseModuleExpression() {
        this.expectPlugin("moduleBlocks");
        const node = this.startNode();
        this.next();
        if (!this.match(5)) {
          this.unexpected(null, 5);
        }
        const program = this.startNodeAt(this.state.endLoc);
        this.next();
        const revertScopes = this.initializeScopes(true);
        this.enterInitialScopes();
        try {
          node.body = this.parseProgram(program, 8, "module");
        } finally {
          revertScopes();
        }
        return this.finishNode(node, "ModuleExpression");
      }
      parsePropertyNamePrefixOperator(prop) {
      }
    };
    var loopLabel = {
      kind: 1
    };
    var switchLabel = {
      kind: 2
    };
    var loneSurrogate = /[\uD800-\uDFFF]/u;
    var keywordRelationalOperator = /in(?:stanceof)?/y;
    function babel7CompatTokens(tokens, input) {
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i];
        const {
          type
        } = token;
        if (typeof type === "number") {
          {
            if (type === 138) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const hashEndPos = start + 1;
              const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);
              tokens.splice(i, 1, new Token({
                type: getExportedToken(27),
                value: "#",
                start,
                end: hashEndPos,
                startLoc: loc.start,
                endLoc: hashEndLoc
              }), new Token({
                type: getExportedToken(132),
                value,
                start: hashEndPos,
                end,
                startLoc: hashEndLoc,
                endLoc: loc.end
              }));
              i++;
              continue;
            }
            if (tokenIsTemplate(type)) {
              const {
                loc,
                start,
                value,
                end
              } = token;
              const backquoteEnd = start + 1;
              const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);
              let startToken;
              if (input.charCodeAt(start) === 96) {
                startToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              } else {
                startToken = new Token({
                  type: getExportedToken(8),
                  value: "}",
                  start,
                  end: backquoteEnd,
                  startLoc: loc.start,
                  endLoc: backquoteEndLoc
                });
              }
              let templateValue, templateElementEnd, templateElementEndLoc, endToken;
              if (type === 24) {
                templateElementEnd = end - 1;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);
                templateValue = value === null ? null : value.slice(1, -1);
                endToken = new Token({
                  type: getExportedToken(22),
                  value: "`",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              } else {
                templateElementEnd = end - 2;
                templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);
                templateValue = value === null ? null : value.slice(1, -2);
                endToken = new Token({
                  type: getExportedToken(23),
                  value: "${",
                  start: templateElementEnd,
                  end,
                  startLoc: templateElementEndLoc,
                  endLoc: loc.end
                });
              }
              tokens.splice(i, 1, startToken, new Token({
                type: getExportedToken(20),
                value: templateValue,
                start: backquoteEnd,
                end: templateElementEnd,
                startLoc: backquoteEndLoc,
                endLoc: templateElementEndLoc
              }), endToken);
              i += 2;
              continue;
            }
          }
          token.type = getExportedToken(type);
        }
      }
      return tokens;
    }
    var StatementParser = class extends ExpressionParser {
      parseTopLevel(file, program) {
        file.program = this.parseProgram(program);
        file.comments = this.comments;
        if (this.options.tokens) {
          file.tokens = babel7CompatTokens(this.tokens, this.input);
        }
        return this.finishNode(file, "File");
      }
      parseProgram(program, end = 139, sourceType = this.options.sourceType) {
        program.sourceType = sourceType;
        program.interpreter = this.parseInterpreterDirective();
        this.parseBlockBody(program, true, true, end);
        if (this.inModule && !this.options.allowUndeclaredExports && this.scope.undefinedExports.size > 0) {
          for (const [localName, at] of Array.from(this.scope.undefinedExports)) {
            this.raise(Errors.ModuleExportUndefined, at, {
              localName
            });
          }
        }
        let finishedProgram;
        if (end === 139) {
          finishedProgram = this.finishNode(program, "Program");
        } else {
          finishedProgram = this.finishNodeAt(program, "Program", createPositionWithColumnOffset(this.state.startLoc, -1));
        }
        return finishedProgram;
      }
      stmtToDirective(stmt) {
        const directive = stmt;
        directive.type = "Directive";
        directive.value = directive.expression;
        delete directive.expression;
        const directiveLiteral = directive.value;
        const expressionValue = directiveLiteral.value;
        const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);
        const val = directiveLiteral.value = raw.slice(1, -1);
        this.addExtra(directiveLiteral, "raw", raw);
        this.addExtra(directiveLiteral, "rawValue", val);
        this.addExtra(directiveLiteral, "expressionValue", expressionValue);
        directiveLiteral.type = "DirectiveLiteral";
        return directive;
      }
      parseInterpreterDirective() {
        if (!this.match(28)) {
          return null;
        }
        const node = this.startNode();
        node.value = this.state.value;
        this.next();
        return this.finishNode(node, "InterpreterDirective");
      }
      isLet() {
        if (!this.isContextual(100)) {
          return false;
        }
        return this.hasFollowingBindingAtom();
      }
      chStartsBindingIdentifier(ch, pos) {
        if (isIdentifierStart(ch)) {
          keywordRelationalOperator.lastIndex = pos;
          if (keywordRelationalOperator.test(this.input)) {
            const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);
            if (!isIdentifierChar(endCh) && endCh !== 92) {
              return false;
            }
          }
          return true;
        } else if (ch === 92) {
          return true;
        } else {
          return false;
        }
      }
      chStartsBindingPattern(ch) {
        return ch === 91 || ch === 123;
      }
      hasFollowingBindingAtom() {
        const next = this.nextTokenStart();
        const nextCh = this.codePointAtPos(next);
        return this.chStartsBindingPattern(nextCh) || this.chStartsBindingIdentifier(nextCh, next);
      }
      hasInLineFollowingBindingIdentifierOrBrace() {
        const next = this.nextTokenInLineStart();
        const nextCh = this.codePointAtPos(next);
        return nextCh === 123 || this.chStartsBindingIdentifier(nextCh, next);
      }
      startsUsingForOf() {
        const {
          type,
          containsEsc
        } = this.lookahead();
        if (type === 102 && !containsEsc) {
          return false;
        } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {
          this.expectPlugin("explicitResourceManagement");
          return true;
        }
      }
      startsAwaitUsing() {
        let next = this.nextTokenInLineStart();
        if (this.isUnparsedContextual(next, "using")) {
          next = this.nextTokenInLineStartSince(next + 5);
          const nextCh = this.codePointAtPos(next);
          if (this.chStartsBindingIdentifier(nextCh, next)) {
            this.expectPlugin("explicitResourceManagement");
            return true;
          }
        }
        return false;
      }
      parseModuleItem() {
        return this.parseStatementLike(1 | 2 | 4 | 8);
      }
      parseStatementListItem() {
        return this.parseStatementLike(2 | 4 | (!this.options.annexB || this.state.strict ? 0 : 8));
      }
      parseStatementOrSloppyAnnexBFunctionDeclaration(allowLabeledFunction = false) {
        let flags = 0;
        if (this.options.annexB && !this.state.strict) {
          flags |= 4;
          if (allowLabeledFunction) {
            flags |= 8;
          }
        }
        return this.parseStatementLike(flags);
      }
      parseStatement() {
        return this.parseStatementLike(0);
      }
      parseStatementLike(flags) {
        let decorators = null;
        if (this.match(26)) {
          decorators = this.parseDecorators(true);
        }
        return this.parseStatementContent(flags, decorators);
      }
      parseStatementContent(flags, decorators) {
        const starttype = this.state.type;
        const node = this.startNode();
        const allowDeclaration = !!(flags & 2);
        const allowFunctionDeclaration = !!(flags & 4);
        const topLevel = flags & 1;
        switch (starttype) {
          case 60:
            return this.parseBreakContinueStatement(node, true);
          case 63:
            return this.parseBreakContinueStatement(node, false);
          case 64:
            return this.parseDebuggerStatement(node);
          case 90:
            return this.parseDoWhileStatement(node);
          case 91:
            return this.parseForStatement(node);
          case 68:
            if (this.lookaheadCharCode() === 46) break;
            if (!allowFunctionDeclaration) {
              this.raise(this.state.strict ? Errors.StrictFunction : this.options.annexB ? Errors.SloppyFunctionAnnexB : Errors.SloppyFunction, this.state.startLoc);
            }
            return this.parseFunctionStatement(node, false, !allowDeclaration && allowFunctionDeclaration);
          case 80:
            if (!allowDeclaration) this.unexpected();
            return this.parseClass(this.maybeTakeDecorators(decorators, node), true);
          case 69:
            return this.parseIfStatement(node);
          case 70:
            return this.parseReturnStatement(node);
          case 71:
            return this.parseSwitchStatement(node);
          case 72:
            return this.parseThrowStatement(node);
          case 73:
            return this.parseTryStatement(node);
          case 96:
            if (!this.state.containsEsc && this.startsAwaitUsing()) {
              if (!this.isAwaitAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, node);
              } else if (!allowDeclaration) {
                this.raise(Errors.UnexpectedLexicalDeclaration, node);
              }
              this.next();
              return this.parseVarStatement(node, "await using");
            }
            break;
          case 107:
            if (this.state.containsEsc || !this.hasInLineFollowingBindingIdentifierOrBrace()) {
              break;
            }
            this.expectPlugin("explicitResourceManagement");
            if (!this.scope.inModule && this.scope.inTopLevel) {
              this.raise(Errors.UnexpectedUsingDeclaration, this.state.startLoc);
            } else if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
            return this.parseVarStatement(node, "using");
          case 100: {
            if (this.state.containsEsc) {
              break;
            }
            const next = this.nextTokenStart();
            const nextCh = this.codePointAtPos(next);
            if (nextCh !== 91) {
              if (!allowDeclaration && this.hasFollowingLineBreak()) break;
              if (!this.chStartsBindingIdentifier(nextCh, next) && nextCh !== 123) {
                break;
              }
            }
          }
          case 75: {
            if (!allowDeclaration) {
              this.raise(Errors.UnexpectedLexicalDeclaration, this.state.startLoc);
            }
          }
          case 74: {
            const kind = this.state.value;
            return this.parseVarStatement(node, kind);
          }
          case 92:
            return this.parseWhileStatement(node);
          case 76:
            return this.parseWithStatement(node);
          case 5:
            return this.parseBlock();
          case 13:
            return this.parseEmptyStatement(node);
          case 83: {
            const nextTokenCharCode = this.lookaheadCharCode();
            if (nextTokenCharCode === 40 || nextTokenCharCode === 46) {
              break;
            }
          }
          case 82: {
            if (!this.options.allowImportExportEverywhere && !topLevel) {
              this.raise(Errors.UnexpectedImportExport, this.state.startLoc);
            }
            this.next();
            let result;
            if (starttype === 83) {
              result = this.parseImport(node);
              if (result.type === "ImportDeclaration" && (!result.importKind || result.importKind === "value")) {
                this.sawUnambiguousESM = true;
              }
            } else {
              result = this.parseExport(node, decorators);
              if (result.type === "ExportNamedDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportAllDeclaration" && (!result.exportKind || result.exportKind === "value") || result.type === "ExportDefaultDeclaration") {
                this.sawUnambiguousESM = true;
              }
            }
            this.assertModuleNodeAllowed(result);
            return result;
          }
          default: {
            if (this.isAsyncFunction()) {
              if (!allowDeclaration) {
                this.raise(Errors.AsyncFunctionInSingleStatementContext, this.state.startLoc);
              }
              this.next();
              return this.parseFunctionStatement(node, true, !allowDeclaration && allowFunctionDeclaration);
            }
          }
        }
        const maybeName = this.state.value;
        const expr = this.parseExpression();
        if (tokenIsIdentifier(starttype) && expr.type === "Identifier" && this.eat(14)) {
          return this.parseLabeledStatement(node, maybeName, expr, flags);
        } else {
          return this.parseExpressionStatement(node, expr, decorators);
        }
      }
      assertModuleNodeAllowed(node) {
        if (!this.options.allowImportExportEverywhere && !this.inModule) {
          this.raise(Errors.ImportOutsideModule, node);
        }
      }
      decoratorsEnabledBeforeExport() {
        if (this.hasPlugin("decorators-legacy")) return true;
        return this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") !== false;
      }
      maybeTakeDecorators(maybeDecorators, classNode, exportNode) {
        if (maybeDecorators) {
          if (classNode.decorators && classNode.decorators.length > 0) {
            if (typeof this.getPluginOption("decorators", "decoratorsBeforeExport") !== "boolean") {
              this.raise(Errors.DecoratorsBeforeAfterExport, classNode.decorators[0]);
            }
            classNode.decorators.unshift(...maybeDecorators);
          } else {
            classNode.decorators = maybeDecorators;
          }
          this.resetStartLocationFromNode(classNode, maybeDecorators[0]);
          if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);
        }
        return classNode;
      }
      canHaveLeadingDecorator() {
        return this.match(80);
      }
      parseDecorators(allowExport) {
        const decorators = [];
        do {
          decorators.push(this.parseDecorator());
        } while (this.match(26));
        if (this.match(82)) {
          if (!allowExport) {
            this.unexpected();
          }
          if (!this.decoratorsEnabledBeforeExport()) {
            this.raise(Errors.DecoratorExportClass, this.state.startLoc);
          }
        } else if (!this.canHaveLeadingDecorator()) {
          throw this.raise(Errors.UnexpectedLeadingDecorator, this.state.startLoc);
        }
        return decorators;
      }
      parseDecorator() {
        this.expectOnePlugin(["decorators", "decorators-legacy"]);
        const node = this.startNode();
        this.next();
        if (this.hasPlugin("decorators")) {
          const startLoc = this.state.startLoc;
          let expr;
          if (this.match(10)) {
            const startLoc2 = this.state.startLoc;
            this.next();
            expr = this.parseExpression();
            this.expect(11);
            expr = this.wrapParenthesis(startLoc2, expr);
            const paramsStartLoc = this.state.startLoc;
            node.expression = this.parseMaybeDecoratorArguments(expr);
            if (this.getPluginOption("decorators", "allowCallParenthesized") === false && node.expression !== expr) {
              this.raise(Errors.DecoratorArgumentsOutsideParentheses, paramsStartLoc);
            }
          } else {
            expr = this.parseIdentifier(false);
            while (this.eat(16)) {
              const node2 = this.startNodeAt(startLoc);
              node2.object = expr;
              if (this.match(138)) {
                this.classScope.usePrivateName(this.state.value, this.state.startLoc);
                node2.property = this.parsePrivateName();
              } else {
                node2.property = this.parseIdentifier(true);
              }
              node2.computed = false;
              expr = this.finishNode(node2, "MemberExpression");
            }
            node.expression = this.parseMaybeDecoratorArguments(expr);
          }
        } else {
          node.expression = this.parseExprSubscripts();
        }
        return this.finishNode(node, "Decorator");
      }
      parseMaybeDecoratorArguments(expr) {
        if (this.eat(10)) {
          const node = this.startNodeAtNode(expr);
          node.callee = expr;
          node.arguments = this.parseCallExpressionArguments(11, false);
          this.toReferencedList(node.arguments);
          return this.finishNode(node, "CallExpression");
        }
        return expr;
      }
      parseBreakContinueStatement(node, isBreak) {
        this.next();
        if (this.isLineTerminator()) {
          node.label = null;
        } else {
          node.label = this.parseIdentifier();
          this.semicolon();
        }
        this.verifyBreakContinue(node, isBreak);
        return this.finishNode(node, isBreak ? "BreakStatement" : "ContinueStatement");
      }
      verifyBreakContinue(node, isBreak) {
        let i;
        for (i = 0; i < this.state.labels.length; ++i) {
          const lab = this.state.labels[i];
          if (node.label == null || lab.name === node.label.name) {
            if (lab.kind != null && (isBreak || lab.kind === 1)) {
              break;
            }
            if (node.label && isBreak) break;
          }
        }
        if (i === this.state.labels.length) {
          const type = isBreak ? "BreakStatement" : "ContinueStatement";
          this.raise(Errors.IllegalBreakContinue, node, {
            type
          });
        }
      }
      parseDebuggerStatement(node) {
        this.next();
        this.semicolon();
        return this.finishNode(node, "DebuggerStatement");
      }
      parseHeaderExpression() {
        this.expect(10);
        const val = this.parseExpression();
        this.expect(11);
        return val;
      }
      parseDoWhileStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        this.expect(92);
        node.test = this.parseHeaderExpression();
        this.eat(13);
        return this.finishNode(node, "DoWhileStatement");
      }
      parseForStatement(node) {
        this.next();
        this.state.labels.push(loopLabel);
        let awaitAt = null;
        if (this.isAwaitAllowed() && this.eatContextual(96)) {
          awaitAt = this.state.lastTokStartLoc;
        }
        this.scope.enter(0);
        this.expect(10);
        if (this.match(13)) {
          if (awaitAt !== null) {
            this.unexpected(awaitAt);
          }
          return this.parseFor(node, null);
        }
        const startsWithLet = this.isContextual(100);
        {
          const startsWithAwaitUsing = this.isContextual(96) && this.startsAwaitUsing();
          const starsWithUsingDeclaration = startsWithAwaitUsing || this.isContextual(107) && this.startsUsingForOf();
          const isLetOrUsing = startsWithLet && this.hasFollowingBindingAtom() || starsWithUsingDeclaration;
          if (this.match(74) || this.match(75) || isLetOrUsing) {
            const initNode = this.startNode();
            let kind;
            if (startsWithAwaitUsing) {
              kind = "await using";
              if (!this.isAwaitAllowed()) {
                this.raise(Errors.AwaitUsingNotInAsyncContext, this.state.startLoc);
              }
              this.next();
            } else {
              kind = this.state.value;
            }
            this.next();
            this.parseVar(initNode, true, kind);
            const init2 = this.finishNode(initNode, "VariableDeclaration");
            const isForIn = this.match(58);
            if (isForIn && starsWithUsingDeclaration) {
              this.raise(Errors.ForInUsing, init2);
            }
            if ((isForIn || this.isContextual(102)) && init2.declarations.length === 1) {
              return this.parseForIn(node, init2, awaitAt);
            }
            if (awaitAt !== null) {
              this.unexpected(awaitAt);
            }
            return this.parseFor(node, init2);
          }
        }
        const startsWithAsync = this.isContextual(95);
        const refExpressionErrors = new ExpressionErrors();
        const init = this.parseExpression(true, refExpressionErrors);
        const isForOf = this.isContextual(102);
        if (isForOf) {
          if (startsWithLet) {
            this.raise(Errors.ForOfLet, init);
          }
          if (awaitAt === null && startsWithAsync && init.type === "Identifier") {
            this.raise(Errors.ForOfAsync, init);
          }
        }
        if (isForOf || this.match(58)) {
          this.checkDestructuringPrivate(refExpressionErrors);
          this.toAssignable(init, true);
          const type = isForOf ? "ForOfStatement" : "ForInStatement";
          this.checkLVal(init, {
            in: {
              type
            }
          });
          return this.parseForIn(node, init, awaitAt);
        } else {
          this.checkExpressionErrors(refExpressionErrors, true);
        }
        if (awaitAt !== null) {
          this.unexpected(awaitAt);
        }
        return this.parseFor(node, init);
      }
      parseFunctionStatement(node, isAsync, isHangingDeclaration) {
        this.next();
        return this.parseFunction(node, 1 | (isHangingDeclaration ? 2 : 0) | (isAsync ? 8 : 0));
      }
      parseIfStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();
        node.alternate = this.eat(66) ? this.parseStatementOrSloppyAnnexBFunctionDeclaration() : null;
        return this.finishNode(node, "IfStatement");
      }
      parseReturnStatement(node) {
        if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {
          this.raise(Errors.IllegalReturn, this.state.startLoc);
        }
        this.next();
        if (this.isLineTerminator()) {
          node.argument = null;
        } else {
          node.argument = this.parseExpression();
          this.semicolon();
        }
        return this.finishNode(node, "ReturnStatement");
      }
      parseSwitchStatement(node) {
        this.next();
        node.discriminant = this.parseHeaderExpression();
        const cases = node.cases = [];
        this.expect(5);
        this.state.labels.push(switchLabel);
        this.scope.enter(0);
        let cur;
        for (let sawDefault; !this.match(8); ) {
          if (this.match(61) || this.match(65)) {
            const isCase = this.match(61);
            if (cur) this.finishNode(cur, "SwitchCase");
            cases.push(cur = this.startNode());
            cur.consequent = [];
            this.next();
            if (isCase) {
              cur.test = this.parseExpression();
            } else {
              if (sawDefault) {
                this.raise(Errors.MultipleDefaultsInSwitch, this.state.lastTokStartLoc);
              }
              sawDefault = true;
              cur.test = null;
            }
            this.expect(14);
          } else {
            if (cur) {
              cur.consequent.push(this.parseStatementListItem());
            } else {
              this.unexpected();
            }
          }
        }
        this.scope.exit();
        if (cur) this.finishNode(cur, "SwitchCase");
        this.next();
        this.state.labels.pop();
        return this.finishNode(node, "SwitchStatement");
      }
      parseThrowStatement(node) {
        this.next();
        if (this.hasPrecedingLineBreak()) {
          this.raise(Errors.NewlineAfterThrow, this.state.lastTokEndLoc);
        }
        node.argument = this.parseExpression();
        this.semicolon();
        return this.finishNode(node, "ThrowStatement");
      }
      parseCatchClauseParam() {
        const param = this.parseBindingAtom();
        this.scope.enter(this.options.annexB && param.type === "Identifier" ? 8 : 0);
        this.checkLVal(param, {
          in: {
            type: "CatchClause"
          },
          binding: 9
        });
        return param;
      }
      parseTryStatement(node) {
        this.next();
        node.block = this.parseBlock();
        node.handler = null;
        if (this.match(62)) {
          const clause = this.startNode();
          this.next();
          if (this.match(10)) {
            this.expect(10);
            clause.param = this.parseCatchClauseParam();
            this.expect(11);
          } else {
            clause.param = null;
            this.scope.enter(0);
          }
          clause.body = this.withSmartMixTopicForbiddingContext(() => this.parseBlock(false, false));
          this.scope.exit();
          node.handler = this.finishNode(clause, "CatchClause");
        }
        node.finalizer = this.eat(67) ? this.parseBlock() : null;
        if (!node.handler && !node.finalizer) {
          this.raise(Errors.NoCatchOrFinally, node);
        }
        return this.finishNode(node, "TryStatement");
      }
      parseVarStatement(node, kind, allowMissingInitializer = false) {
        this.next();
        this.parseVar(node, false, kind, allowMissingInitializer);
        this.semicolon();
        return this.finishNode(node, "VariableDeclaration");
      }
      parseWhileStatement(node) {
        this.next();
        node.test = this.parseHeaderExpression();
        this.state.labels.push(loopLabel);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.state.labels.pop();
        return this.finishNode(node, "WhileStatement");
      }
      parseWithStatement(node) {
        if (this.state.strict) {
          this.raise(Errors.StrictWith, this.state.startLoc);
        }
        this.next();
        node.object = this.parseHeaderExpression();
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        return this.finishNode(node, "WithStatement");
      }
      parseEmptyStatement(node) {
        this.next();
        return this.finishNode(node, "EmptyStatement");
      }
      parseLabeledStatement(node, maybeName, expr, flags) {
        for (const label of this.state.labels) {
          if (label.name === maybeName) {
            this.raise(Errors.LabelRedeclaration, expr, {
              labelName: maybeName
            });
          }
        }
        const kind = tokenIsLoop(this.state.type) ? 1 : this.match(71) ? 2 : null;
        for (let i = this.state.labels.length - 1; i >= 0; i--) {
          const label = this.state.labels[i];
          if (label.statementStart === node.start) {
            label.statementStart = this.state.start;
            label.kind = kind;
          } else {
            break;
          }
        }
        this.state.labels.push({
          name: maybeName,
          kind,
          statementStart: this.state.start
        });
        node.body = flags & 8 ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true) : this.parseStatement();
        this.state.labels.pop();
        node.label = expr;
        return this.finishNode(node, "LabeledStatement");
      }
      parseExpressionStatement(node, expr, decorators) {
        node.expression = expr;
        this.semicolon();
        return this.finishNode(node, "ExpressionStatement");
      }
      parseBlock(allowDirectives = false, createNewLexicalScope = true, afterBlockParse) {
        const node = this.startNode();
        if (allowDirectives) {
          this.state.strictErrors.clear();
        }
        this.expect(5);
        if (createNewLexicalScope) {
          this.scope.enter(0);
        }
        this.parseBlockBody(node, allowDirectives, false, 8, afterBlockParse);
        if (createNewLexicalScope) {
          this.scope.exit();
        }
        return this.finishNode(node, "BlockStatement");
      }
      isValidDirective(stmt) {
        return stmt.type === "ExpressionStatement" && stmt.expression.type === "StringLiteral" && !stmt.expression.extra.parenthesized;
      }
      parseBlockBody(node, allowDirectives, topLevel, end, afterBlockParse) {
        const body = node.body = [];
        const directives = node.directives = [];
        this.parseBlockOrModuleBlockBody(body, allowDirectives ? directives : void 0, topLevel, end, afterBlockParse);
      }
      parseBlockOrModuleBlockBody(body, directives, topLevel, end, afterBlockParse) {
        const oldStrict = this.state.strict;
        let hasStrictModeDirective = false;
        let parsedNonDirective = false;
        while (!this.match(end)) {
          const stmt = topLevel ? this.parseModuleItem() : this.parseStatementListItem();
          if (directives && !parsedNonDirective) {
            if (this.isValidDirective(stmt)) {
              const directive = this.stmtToDirective(stmt);
              directives.push(directive);
              if (!hasStrictModeDirective && directive.value.value === "use strict") {
                hasStrictModeDirective = true;
                this.setStrict(true);
              }
              continue;
            }
            parsedNonDirective = true;
            this.state.strictErrors.clear();
          }
          body.push(stmt);
        }
        afterBlockParse == null || afterBlockParse.call(this, hasStrictModeDirective);
        if (!oldStrict) {
          this.setStrict(false);
        }
        this.next();
      }
      parseFor(node, init) {
        node.init = init;
        this.semicolon(false);
        node.test = this.match(13) ? null : this.parseExpression();
        this.semicolon(false);
        node.update = this.match(11) ? null : this.parseExpression();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, "ForStatement");
      }
      parseForIn(node, init, awaitAt) {
        const isForIn = this.match(58);
        this.next();
        if (isForIn) {
          if (awaitAt !== null) this.unexpected(awaitAt);
        } else {
          node.await = awaitAt !== null;
        }
        if (init.type === "VariableDeclaration" && init.declarations[0].init != null && (!isForIn || !this.options.annexB || this.state.strict || init.kind !== "var" || init.declarations[0].id.type !== "Identifier")) {
          this.raise(Errors.ForInOfLoopInitializer, init, {
            type: isForIn ? "ForInStatement" : "ForOfStatement"
          });
        }
        if (init.type === "AssignmentPattern") {
          this.raise(Errors.InvalidLhs, init, {
            ancestor: {
              type: "ForStatement"
            }
          });
        }
        node.left = init;
        node.right = isForIn ? this.parseExpression() : this.parseMaybeAssignAllowIn();
        this.expect(11);
        node.body = this.withSmartMixTopicForbiddingContext(() => this.parseStatement());
        this.scope.exit();
        this.state.labels.pop();
        return this.finishNode(node, isForIn ? "ForInStatement" : "ForOfStatement");
      }
      parseVar(node, isFor, kind, allowMissingInitializer = false) {
        const declarations = node.declarations = [];
        node.kind = kind;
        for (; ; ) {
          const decl = this.startNode();
          this.parseVarId(decl, kind);
          decl.init = !this.eat(29) ? null : isFor ? this.parseMaybeAssignDisallowIn() : this.parseMaybeAssignAllowIn();
          if (decl.init === null && !allowMissingInitializer) {
            if (decl.id.type !== "Identifier" && !(isFor && (this.match(58) || this.isContextual(102)))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind: "destructuring"
              });
            } else if ((kind === "const" || kind === "using" || kind === "await using") && !(this.match(58) || this.isContextual(102))) {
              this.raise(Errors.DeclarationMissingInitializer, this.state.lastTokEndLoc, {
                kind
              });
            }
          }
          declarations.push(this.finishNode(decl, "VariableDeclarator"));
          if (!this.eat(12)) break;
        }
        return node;
      }
      parseVarId(decl, kind) {
        const id = this.parseBindingAtom();
        if (kind === "using" || kind === "await using") {
          if (id.type === "ArrayPattern" || id.type === "ObjectPattern") {
            this.raise(Errors.UsingDeclarationHasBindingPattern, id.loc.start);
          }
        }
        this.checkLVal(id, {
          in: {
            type: "VariableDeclarator"
          },
          binding: kind === "var" ? 5 : 8201
        });
        decl.id = id;
      }
      parseAsyncFunctionExpression(node) {
        return this.parseFunction(node, 8);
      }
      parseFunction(node, flags = 0) {
        const hangingDeclaration = flags & 2;
        const isDeclaration = !!(flags & 1);
        const requireId = isDeclaration && !(flags & 4);
        const isAsync = !!(flags & 8);
        this.initFunction(node, isAsync);
        if (this.match(55)) {
          if (hangingDeclaration) {
            this.raise(Errors.GeneratorInSingleStatementContext, this.state.startLoc);
          }
          this.next();
          node.generator = true;
        }
        if (isDeclaration) {
          node.id = this.parseFunctionId(requireId);
        }
        const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;
        this.state.maybeInArrowParameters = false;
        this.scope.enter(2);
        this.prodParam.enter(functionFlags(isAsync, node.generator));
        if (!isDeclaration) {
          node.id = this.parseFunctionId();
        }
        this.parseFunctionParams(node, false);
        this.withSmartMixTopicForbiddingContext(() => {
          this.parseFunctionBodyAndFinish(node, isDeclaration ? "FunctionDeclaration" : "FunctionExpression");
        });
        this.prodParam.exit();
        this.scope.exit();
        if (isDeclaration && !hangingDeclaration) {
          this.registerFunctionStatementId(node);
        }
        this.state.maybeInArrowParameters = oldMaybeInArrowParameters;
        return node;
      }
      parseFunctionId(requireId) {
        return requireId || tokenIsIdentifier(this.state.type) ? this.parseIdentifier() : null;
      }
      parseFunctionParams(node, isConstructor) {
        this.expect(10);
        this.expressionScope.enter(newParameterDeclarationScope());
        node.params = this.parseBindingList(11, 41, 2 | (isConstructor ? 4 : 0));
        this.expressionScope.exit();
      }
      registerFunctionStatementId(node) {
        if (!node.id) return;
        this.scope.declareName(node.id.name, !this.options.annexB || this.state.strict || node.generator || node.async ? this.scope.treatFunctionsAsVar ? 5 : 8201 : 17, node.id.loc.start);
      }
      parseClass(node, isStatement, optionalId) {
        this.next();
        const oldStrict = this.state.strict;
        this.state.strict = true;
        this.parseClassId(node, isStatement, optionalId);
        this.parseClassSuper(node);
        node.body = this.parseClassBody(!!node.superClass, oldStrict);
        return this.finishNode(node, isStatement ? "ClassDeclaration" : "ClassExpression");
      }
      isClassProperty() {
        return this.match(29) || this.match(13) || this.match(8);
      }
      isClassMethod() {
        return this.match(10);
      }
      nameIsConstructor(key) {
        return key.type === "Identifier" && key.name === "constructor" || key.type === "StringLiteral" && key.value === "constructor";
      }
      isNonstaticConstructor(method) {
        return !method.computed && !method.static && this.nameIsConstructor(method.key);
      }
      parseClassBody(hadSuperClass, oldStrict) {
        this.classScope.enter();
        const state = {
          hadConstructor: false,
          hadSuperClass
        };
        let decorators = [];
        const classBody = this.startNode();
        classBody.body = [];
        this.expect(5);
        this.withSmartMixTopicForbiddingContext(() => {
          while (!this.match(8)) {
            if (this.eat(13)) {
              if (decorators.length > 0) {
                throw this.raise(Errors.DecoratorSemicolon, this.state.lastTokEndLoc);
              }
              continue;
            }
            if (this.match(26)) {
              decorators.push(this.parseDecorator());
              continue;
            }
            const member = this.startNode();
            if (decorators.length) {
              member.decorators = decorators;
              this.resetStartLocationFromNode(member, decorators[0]);
              decorators = [];
            }
            this.parseClassMember(classBody, member, state);
            if (member.kind === "constructor" && member.decorators && member.decorators.length > 0) {
              this.raise(Errors.DecoratorConstructor, member);
            }
          }
        });
        this.state.strict = oldStrict;
        this.next();
        if (decorators.length) {
          throw this.raise(Errors.TrailingDecorator, this.state.startLoc);
        }
        this.classScope.exit();
        return this.finishNode(classBody, "ClassBody");
      }
      parseClassMemberFromModifier(classBody, member) {
        const key = this.parseIdentifier(true);
        if (this.isClassMethod()) {
          const method = member;
          method.kind = "method";
          method.computed = false;
          method.key = key;
          method.static = false;
          this.pushClassMethod(classBody, method, false, false, false, false);
          return true;
        } else if (this.isClassProperty()) {
          const prop = member;
          prop.computed = false;
          prop.key = key;
          prop.static = false;
          classBody.body.push(this.parseClassProperty(prop));
          return true;
        }
        this.resetPreviousNodeTrailingComments(key);
        return false;
      }
      parseClassMember(classBody, member, state) {
        const isStatic = this.isContextual(106);
        if (isStatic) {
          if (this.parseClassMemberFromModifier(classBody, member)) {
            return;
          }
          if (this.eat(5)) {
            this.parseClassStaticBlock(classBody, member);
            return;
          }
        }
        this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);
      }
      parseClassMemberWithIsStatic(classBody, member, state, isStatic) {
        const publicMethod = member;
        const privateMethod = member;
        const publicProp = member;
        const privateProp = member;
        const accessorProp = member;
        const method = publicMethod;
        const publicMember = publicMethod;
        member.static = isStatic;
        this.parsePropertyNamePrefixOperator(member);
        if (this.eat(55)) {
          method.kind = "method";
          const isPrivateName = this.match(138);
          this.parseClassElementName(method);
          if (isPrivateName) {
            this.pushClassPrivateMethod(classBody, privateMethod, true, false);
            return;
          }
          if (this.isNonstaticConstructor(publicMethod)) {
            this.raise(Errors.ConstructorIsGenerator, publicMethod.key);
          }
          this.pushClassMethod(classBody, publicMethod, true, false, false, false);
          return;
        }
        const isContextual = !this.state.containsEsc && tokenIsIdentifier(this.state.type);
        const key = this.parseClassElementName(member);
        const maybeContextualKw = isContextual ? key.name : null;
        const isPrivate = this.isPrivateName(key);
        const maybeQuestionTokenStartLoc = this.state.startLoc;
        this.parsePostMemberNameModifiers(publicMember);
        if (this.isClassMethod()) {
          method.kind = "method";
          if (isPrivate) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
            return;
          }
          const isConstructor = this.isNonstaticConstructor(publicMethod);
          let allowsDirectSuper = false;
          if (isConstructor) {
            publicMethod.kind = "constructor";
            if (state.hadConstructor && !this.hasPlugin("typescript")) {
              this.raise(Errors.DuplicateConstructor, key);
            }
            if (isConstructor && this.hasPlugin("typescript") && member.override) {
              this.raise(Errors.OverrideOnConstructor, key);
            }
            state.hadConstructor = true;
            allowsDirectSuper = state.hadSuperClass;
          }
          this.pushClassMethod(classBody, publicMethod, false, false, isConstructor, allowsDirectSuper);
        } else if (this.isClassProperty()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else if (maybeContextualKw === "async" && !this.isLineTerminator()) {
          this.resetPreviousNodeTrailingComments(key);
          const isGenerator = this.eat(55);
          if (publicMember.optional) {
            this.unexpected(maybeQuestionTokenStartLoc);
          }
          method.kind = "method";
          const isPrivate2 = this.match(138);
          this.parseClassElementName(method);
          this.parsePostMemberNameModifiers(publicMember);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, isGenerator, true);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAsync, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, isGenerator, true, false, false);
          }
        } else if ((maybeContextualKw === "get" || maybeContextualKw === "set") && !(this.match(55) && this.isLineTerminator())) {
          this.resetPreviousNodeTrailingComments(key);
          method.kind = maybeContextualKw;
          const isPrivate2 = this.match(138);
          this.parseClassElementName(publicMethod);
          if (isPrivate2) {
            this.pushClassPrivateMethod(classBody, privateMethod, false, false);
          } else {
            if (this.isNonstaticConstructor(publicMethod)) {
              this.raise(Errors.ConstructorIsAccessor, publicMethod.key);
            }
            this.pushClassMethod(classBody, publicMethod, false, false, false, false);
          }
          this.checkGetterSetterParams(publicMethod);
        } else if (maybeContextualKw === "accessor" && !this.isLineTerminator()) {
          this.expectPlugin("decoratorAutoAccessors");
          this.resetPreviousNodeTrailingComments(key);
          const isPrivate2 = this.match(138);
          this.parseClassElementName(publicProp);
          this.pushClassAccessorProperty(classBody, accessorProp, isPrivate2);
        } else if (this.isLineTerminator()) {
          if (isPrivate) {
            this.pushClassPrivateProperty(classBody, privateProp);
          } else {
            this.pushClassProperty(classBody, publicProp);
          }
        } else {
          this.unexpected();
        }
      }
      parseClassElementName(member) {
        const {
          type,
          value
        } = this.state;
        if ((type === 132 || type === 133) && member.static && value === "prototype") {
          this.raise(Errors.StaticPrototype, this.state.startLoc);
        }
        if (type === 138) {
          if (value === "constructor") {
            this.raise(Errors.ConstructorClassPrivateField, this.state.startLoc);
          }
          const key = this.parsePrivateName();
          member.key = key;
          return key;
        }
        this.parsePropertyName(member);
        return member.key;
      }
      parseClassStaticBlock(classBody, member) {
        var _member$decorators;
        this.scope.enter(64 | 128 | 16);
        const oldLabels = this.state.labels;
        this.state.labels = [];
        this.prodParam.enter(0);
        const body = member.body = [];
        this.parseBlockOrModuleBlockBody(body, void 0, false, 8);
        this.prodParam.exit();
        this.scope.exit();
        this.state.labels = oldLabels;
        classBody.body.push(this.finishNode(member, "StaticBlock"));
        if ((_member$decorators = member.decorators) != null && _member$decorators.length) {
          this.raise(Errors.DecoratorStaticBlock, member);
        }
      }
      pushClassProperty(classBody, prop) {
        if (!prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        classBody.body.push(this.parseClassProperty(prop));
      }
      pushClassPrivateProperty(classBody, prop) {
        const node = this.parseClassPrivateProperty(prop);
        classBody.body.push(node);
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
      }
      pushClassAccessorProperty(classBody, prop, isPrivate) {
        if (!isPrivate && !prop.computed && this.nameIsConstructor(prop.key)) {
          this.raise(Errors.ConstructorClassField, prop.key);
        }
        const node = this.parseClassAccessorProperty(prop);
        classBody.body.push(node);
        if (isPrivate) {
          this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), 0, node.key.loc.start);
        }
      }
      pushClassMethod(classBody, method, isGenerator, isAsync, isConstructor, allowsDirectSuper) {
        classBody.body.push(this.parseMethod(method, isGenerator, isAsync, isConstructor, allowsDirectSuper, "ClassMethod", true));
      }
      pushClassPrivateMethod(classBody, method, isGenerator, isAsync) {
        const node = this.parseMethod(method, isGenerator, isAsync, false, false, "ClassPrivateMethod", true);
        classBody.body.push(node);
        const kind = node.kind === "get" ? node.static ? 6 : 2 : node.kind === "set" ? node.static ? 5 : 1 : 0;
        this.declareClassPrivateMethodInScope(node, kind);
      }
      declareClassPrivateMethodInScope(node, kind) {
        this.classScope.declarePrivateName(this.getPrivateNameSV(node.key), kind, node.key.loc.start);
      }
      parsePostMemberNameModifiers(methodOrProp) {
      }
      parseClassPrivateProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassPrivateProperty");
      }
      parseClassProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassProperty");
      }
      parseClassAccessorProperty(node) {
        this.parseInitializer(node);
        this.semicolon();
        return this.finishNode(node, "ClassAccessorProperty");
      }
      parseInitializer(node) {
        this.scope.enter(64 | 16);
        this.expressionScope.enter(newExpressionScope());
        this.prodParam.enter(0);
        node.value = this.eat(29) ? this.parseMaybeAssignAllowIn() : null;
        this.expressionScope.exit();
        this.prodParam.exit();
        this.scope.exit();
      }
      parseClassId(node, isStatement, optionalId, bindingType = 8331) {
        if (tokenIsIdentifier(this.state.type)) {
          node.id = this.parseIdentifier();
          if (isStatement) {
            this.declareNameFromIdentifier(node.id, bindingType);
          }
        } else {
          if (optionalId || !isStatement) {
            node.id = null;
          } else {
            throw this.raise(Errors.MissingClassName, this.state.startLoc);
          }
        }
      }
      parseClassSuper(node) {
        node.superClass = this.eat(81) ? this.parseExprSubscripts() : null;
      }
      parseExport(node, decorators) {
        const maybeDefaultIdentifier = this.parseMaybeImportPhase(node, true);
        const hasDefault = this.maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier);
        const parseAfterDefault = !hasDefault || this.eat(12);
        const hasStar = parseAfterDefault && this.eatExportStar(node);
        const hasNamespace = hasStar && this.maybeParseExportNamespaceSpecifier(node);
        const parseAfterNamespace = parseAfterDefault && (!hasNamespace || this.eat(12));
        const isFromRequired = hasDefault || hasStar;
        if (hasStar && !hasNamespace) {
          if (hasDefault) this.unexpected();
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, true);
          return this.finishNode(node, "ExportAllDeclaration");
        }
        const hasSpecifiers = this.maybeParseExportNamedSpecifiers(node);
        if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {
          this.unexpected(null, 5);
        }
        if (hasNamespace && parseAfterNamespace) {
          this.unexpected(null, 98);
        }
        let hasDeclaration;
        if (isFromRequired || hasSpecifiers) {
          hasDeclaration = false;
          if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.parseExportFrom(node, isFromRequired);
        } else {
          hasDeclaration = this.maybeParseExportDeclaration(node);
        }
        if (isFromRequired || hasSpecifiers || hasDeclaration) {
          var _node2$declaration;
          const node2 = node;
          this.checkExport(node2, true, false, !!node2.source);
          if (((_node2$declaration = node2.declaration) == null ? void 0 : _node2$declaration.type) === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, node2.declaration, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          return this.finishNode(node2, "ExportNamedDeclaration");
        }
        if (this.eat(65)) {
          const node2 = node;
          const decl = this.parseExportDefaultExpression();
          node2.declaration = decl;
          if (decl.type === "ClassDeclaration") {
            this.maybeTakeDecorators(decorators, decl, node2);
          } else if (decorators) {
            throw this.raise(Errors.UnsupportedDecoratorExport, node);
          }
          this.checkExport(node2, true, true);
          return this.finishNode(node2, "ExportDefaultDeclaration");
        }
        this.unexpected(null, 5);
      }
      eatExportStar(node) {
        return this.eat(55);
      }
      maybeParseExportDefaultSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier || this.isExportDefaultSpecifier()) {
          this.expectPlugin("exportDefaultFrom", maybeDefaultIdentifier == null ? void 0 : maybeDefaultIdentifier.loc.start);
          const id = maybeDefaultIdentifier || this.parseIdentifier(true);
          const specifier = this.startNodeAtNode(id);
          specifier.exported = id;
          node.specifiers = [this.finishNode(specifier, "ExportDefaultSpecifier")];
          return true;
        }
        return false;
      }
      maybeParseExportNamespaceSpecifier(node) {
        if (this.isContextual(93)) {
          var _ref, _ref$specifiers;
          (_ref$specifiers = (_ref = node).specifiers) != null ? _ref$specifiers : _ref.specifiers = [];
          const specifier = this.startNodeAt(this.state.lastTokStartLoc);
          this.next();
          specifier.exported = this.parseModuleExportName();
          node.specifiers.push(this.finishNode(specifier, "ExportNamespaceSpecifier"));
          return true;
        }
        return false;
      }
      maybeParseExportNamedSpecifiers(node) {
        if (this.match(5)) {
          const node2 = node;
          if (!node2.specifiers) node2.specifiers = [];
          const isTypeExport = node2.exportKind === "type";
          node2.specifiers.push(...this.parseExportSpecifiers(isTypeExport));
          node2.source = null;
          node2.declaration = null;
          if (this.hasPlugin("importAssertions")) {
            node2.assertions = [];
          }
          return true;
        }
        return false;
      }
      maybeParseExportDeclaration(node) {
        if (this.shouldParseExportDeclaration()) {
          node.specifiers = [];
          node.source = null;
          if (this.hasPlugin("importAssertions")) {
            node.assertions = [];
          }
          node.declaration = this.parseExportDeclaration(node);
          return true;
        }
        return false;
      }
      isAsyncFunction() {
        if (!this.isContextual(95)) return false;
        const next = this.nextTokenInLineStart();
        return this.isUnparsedContextual(next, "function");
      }
      parseExportDefaultExpression() {
        const expr = this.startNode();
        if (this.match(68)) {
          this.next();
          return this.parseFunction(expr, 1 | 4);
        } else if (this.isAsyncFunction()) {
          this.next();
          this.next();
          return this.parseFunction(expr, 1 | 4 | 8);
        }
        if (this.match(80)) {
          return this.parseClass(expr, true, true);
        }
        if (this.match(26)) {
          if (this.hasPlugin("decorators") && this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
            this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
          }
          return this.parseClass(this.maybeTakeDecorators(this.parseDecorators(false), this.startNode()), true, true);
        }
        if (this.match(75) || this.match(74) || this.isLet()) {
          throw this.raise(Errors.UnsupportedDefaultExport, this.state.startLoc);
        }
        const res = this.parseMaybeAssignAllowIn();
        this.semicolon();
        return res;
      }
      parseExportDeclaration(node) {
        if (this.match(80)) {
          const node2 = this.parseClass(this.startNode(), true, false);
          return node2;
        }
        return this.parseStatementListItem();
      }
      isExportDefaultSpecifier() {
        const {
          type
        } = this.state;
        if (tokenIsIdentifier(type)) {
          if (type === 95 && !this.state.containsEsc || type === 100) {
            return false;
          }
          if ((type === 130 || type === 129) && !this.state.containsEsc) {
            const {
              type: nextType
            } = this.lookahead();
            if (tokenIsIdentifier(nextType) && nextType !== 98 || nextType === 5) {
              this.expectOnePlugin(["flow", "typescript"]);
              return false;
            }
          }
        } else if (!this.match(65)) {
          return false;
        }
        const next = this.nextTokenStart();
        const hasFrom = this.isUnparsedContextual(next, "from");
        if (this.input.charCodeAt(next) === 44 || tokenIsIdentifier(this.state.type) && hasFrom) {
          return true;
        }
        if (this.match(65) && hasFrom) {
          const nextAfterFrom = this.input.charCodeAt(this.nextTokenStartSince(next + 4));
          return nextAfterFrom === 34 || nextAfterFrom === 39;
        }
        return false;
      }
      parseExportFrom(node, expect) {
        if (this.eatContextual(98)) {
          node.source = this.parseImportSource();
          this.checkExport(node);
          this.maybeParseImportAttributes(node);
          this.checkJSONModuleImport(node);
        } else if (expect) {
          this.unexpected();
        }
        this.semicolon();
      }
      shouldParseExportDeclaration() {
        const {
          type
        } = this.state;
        if (type === 26) {
          this.expectOnePlugin(["decorators", "decorators-legacy"]);
          if (this.hasPlugin("decorators")) {
            if (this.getPluginOption("decorators", "decoratorsBeforeExport") === true) {
              this.raise(Errors.DecoratorBeforeExport, this.state.startLoc);
            }
            return true;
          }
        }
        if (this.isContextual(107)) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        if (this.isContextual(96) && this.startsAwaitUsing()) {
          this.raise(Errors.UsingDeclarationExport, this.state.startLoc);
          return true;
        }
        return type === 74 || type === 75 || type === 68 || type === 80 || this.isLet() || this.isAsyncFunction();
      }
      checkExport(node, checkNames, isDefault, isFrom) {
        if (checkNames) {
          var _node$specifiers;
          if (isDefault) {
            this.checkDuplicateExports(node, "default");
            if (this.hasPlugin("exportDefaultFrom")) {
              var _declaration$extra;
              const declaration = node.declaration;
              if (declaration.type === "Identifier" && declaration.name === "from" && declaration.end - declaration.start === 4 && !((_declaration$extra = declaration.extra) != null && _declaration$extra.parenthesized)) {
                this.raise(Errors.ExportDefaultFromAsIdentifier, declaration);
              }
            }
          } else if ((_node$specifiers = node.specifiers) != null && _node$specifiers.length) {
            for (const specifier of node.specifiers) {
              const {
                exported
              } = specifier;
              const exportName = exported.type === "Identifier" ? exported.name : exported.value;
              this.checkDuplicateExports(specifier, exportName);
              if (!isFrom && specifier.local) {
                const {
                  local
                } = specifier;
                if (local.type !== "Identifier") {
                  this.raise(Errors.ExportBindingIsString, specifier, {
                    localName: local.value,
                    exportName
                  });
                } else {
                  this.checkReservedWord(local.name, local.loc.start, true, false);
                  this.scope.checkLocalExport(local);
                }
              }
            }
          } else if (node.declaration) {
            const decl = node.declaration;
            if (decl.type === "FunctionDeclaration" || decl.type === "ClassDeclaration") {
              const {
                id
              } = decl;
              if (!id) throw new Error("Assertion failure");
              this.checkDuplicateExports(node, id.name);
            } else if (decl.type === "VariableDeclaration") {
              for (const declaration of decl.declarations) {
                this.checkDeclaration(declaration.id);
              }
            }
          }
        }
      }
      checkDeclaration(node) {
        if (node.type === "Identifier") {
          this.checkDuplicateExports(node, node.name);
        } else if (node.type === "ObjectPattern") {
          for (const prop of node.properties) {
            this.checkDeclaration(prop);
          }
        } else if (node.type === "ArrayPattern") {
          for (const elem of node.elements) {
            if (elem) {
              this.checkDeclaration(elem);
            }
          }
        } else if (node.type === "ObjectProperty") {
          this.checkDeclaration(node.value);
        } else if (node.type === "RestElement") {
          this.checkDeclaration(node.argument);
        } else if (node.type === "AssignmentPattern") {
          this.checkDeclaration(node.left);
        }
      }
      checkDuplicateExports(node, exportName) {
        if (this.exportedIdentifiers.has(exportName)) {
          if (exportName === "default") {
            this.raise(Errors.DuplicateDefaultExport, node);
          } else {
            this.raise(Errors.DuplicateExport, node, {
              exportName
            });
          }
        }
        this.exportedIdentifiers.add(exportName);
      }
      parseExportSpecifiers(isInTypeExport) {
        const nodes = [];
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            this.expect(12);
            if (this.eat(8)) break;
          }
          const isMaybeTypeOnly = this.isContextual(130);
          const isString = this.match(133);
          const node = this.startNode();
          node.local = this.parseModuleExportName();
          nodes.push(this.parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly));
        }
        return nodes;
      }
      parseExportSpecifier(node, isString, isInTypeExport, isMaybeTypeOnly) {
        if (this.eatContextual(93)) {
          node.exported = this.parseModuleExportName();
        } else if (isString) {
          node.exported = cloneStringLiteral(node.local);
        } else if (!node.exported) {
          node.exported = cloneIdentifier(node.local);
        }
        return this.finishNode(node, "ExportSpecifier");
      }
      parseModuleExportName() {
        if (this.match(133)) {
          const result = this.parseStringLiteral(this.state.value);
          const surrogate = loneSurrogate.exec(result.value);
          if (surrogate) {
            this.raise(Errors.ModuleExportNameHasLoneSurrogate, result, {
              surrogateCharCode: surrogate[0].charCodeAt(0)
            });
          }
          return result;
        }
        return this.parseIdentifier(true);
      }
      isJSONModuleImport(node) {
        if (node.assertions != null) {
          return node.assertions.some(({
            key,
            value
          }) => {
            return value.value === "json" && (key.type === "Identifier" ? key.name === "type" : key.value === "type");
          });
        }
        return false;
      }
      checkImportReflection(node) {
        const {
          specifiers
        } = node;
        const singleBindingType = specifiers.length === 1 ? specifiers[0].type : null;
        if (node.phase === "source") {
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.SourcePhaseImportRequiresDefault, specifiers[0].loc.start);
          }
        } else if (node.phase === "defer") {
          if (singleBindingType !== "ImportNamespaceSpecifier") {
            this.raise(Errors.DeferImportRequiresNamespace, specifiers[0].loc.start);
          }
        } else if (node.module) {
          var _node$assertions;
          if (singleBindingType !== "ImportDefaultSpecifier") {
            this.raise(Errors.ImportReflectionNotBinding, specifiers[0].loc.start);
          }
          if (((_node$assertions = node.assertions) == null ? void 0 : _node$assertions.length) > 0) {
            this.raise(Errors.ImportReflectionHasAssertion, specifiers[0].loc.start);
          }
        }
      }
      checkJSONModuleImport(node) {
        if (this.isJSONModuleImport(node) && node.type !== "ExportAllDeclaration") {
          const {
            specifiers
          } = node;
          if (specifiers != null) {
            const nonDefaultNamedSpecifier = specifiers.find((specifier) => {
              let imported;
              if (specifier.type === "ExportSpecifier") {
                imported = specifier.local;
              } else if (specifier.type === "ImportSpecifier") {
                imported = specifier.imported;
              }
              if (imported !== void 0) {
                return imported.type === "Identifier" ? imported.name !== "default" : imported.value !== "default";
              }
            });
            if (nonDefaultNamedSpecifier !== void 0) {
              this.raise(Errors.ImportJSONBindingNotDefault, nonDefaultNamedSpecifier.loc.start);
            }
          }
        }
      }
      isPotentialImportPhase(isExport) {
        if (isExport) return false;
        return this.isContextual(105) || this.isContextual(97) || this.isContextual(127);
      }
      applyImportPhase(node, isExport, phase, loc) {
        if (isExport) {
          return;
        }
        if (phase === "module") {
          this.expectPlugin("importReflection", loc);
          node.module = true;
        } else if (this.hasPlugin("importReflection")) {
          node.module = false;
        }
        if (phase === "source") {
          this.expectPlugin("sourcePhaseImports", loc);
          node.phase = "source";
        } else if (phase === "defer") {
          this.expectPlugin("deferredImportEvaluation", loc);
          node.phase = "defer";
        } else if (this.hasPlugin("sourcePhaseImports")) {
          node.phase = null;
        }
      }
      parseMaybeImportPhase(node, isExport) {
        if (!this.isPotentialImportPhase(isExport)) {
          this.applyImportPhase(node, isExport, null);
          return null;
        }
        const phaseIdentifier = this.parseIdentifier(true);
        const {
          type
        } = this.state;
        const isImportPhase = tokenIsKeywordOrIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
        if (isImportPhase) {
          this.resetPreviousIdentifierLeadingComments(phaseIdentifier);
          this.applyImportPhase(node, isExport, phaseIdentifier.name, phaseIdentifier.loc.start);
          return null;
        } else {
          this.applyImportPhase(node, isExport, null);
          return phaseIdentifier;
        }
      }
      isPrecedingIdImportPhase(phase) {
        const {
          type
        } = this.state;
        return tokenIsIdentifier(type) ? type !== 98 || this.lookaheadCharCode() === 102 : type !== 12;
      }
      parseImport(node) {
        if (this.match(133)) {
          return this.parseImportSourceAndAttributes(node);
        }
        return this.parseImportSpecifiersAndAfter(node, this.parseMaybeImportPhase(node, false));
      }
      parseImportSpecifiersAndAfter(node, maybeDefaultIdentifier) {
        node.specifiers = [];
        const hasDefault = this.maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier);
        const parseNext = !hasDefault || this.eat(12);
        const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);
        if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);
        this.expectContextual(98);
        return this.parseImportSourceAndAttributes(node);
      }
      parseImportSourceAndAttributes(node) {
        var _node$specifiers2;
        (_node$specifiers2 = node.specifiers) != null ? _node$specifiers2 : node.specifiers = [];
        node.source = this.parseImportSource();
        this.maybeParseImportAttributes(node);
        this.checkImportReflection(node);
        this.checkJSONModuleImport(node);
        this.semicolon();
        return this.finishNode(node, "ImportDeclaration");
      }
      parseImportSource() {
        if (!this.match(133)) this.unexpected();
        return this.parseExprAtom();
      }
      parseImportSpecifierLocal(node, specifier, type) {
        specifier.local = this.parseIdentifier();
        node.specifiers.push(this.finishImportSpecifier(specifier, type));
      }
      finishImportSpecifier(specifier, type, bindingType = 8201) {
        this.checkLVal(specifier.local, {
          in: {
            type
          },
          binding: bindingType
        });
        return this.finishNode(specifier, type);
      }
      parseImportAttributes() {
        this.expect(5);
        const attrs = [];
        const attrNames = /* @__PURE__ */ new Set();
        do {
          if (this.match(8)) {
            break;
          }
          const node = this.startNode();
          const keyName = this.state.value;
          if (attrNames.has(keyName)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, this.state.startLoc, {
              key: keyName
            });
          }
          attrNames.add(keyName);
          if (this.match(133)) {
            node.key = this.parseStringLiteral(keyName);
          } else {
            node.key = this.parseIdentifier(true);
          }
          this.expect(14);
          if (!this.match(133)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        this.expect(8);
        return attrs;
      }
      parseModuleAttributes() {
        const attrs = [];
        const attributes = /* @__PURE__ */ new Set();
        do {
          const node = this.startNode();
          node.key = this.parseIdentifier(true);
          if (node.key.name !== "type") {
            this.raise(Errors.ModuleAttributeDifferentFromType, node.key);
          }
          if (attributes.has(node.key.name)) {
            this.raise(Errors.ModuleAttributesWithDuplicateKeys, node.key, {
              key: node.key.name
            });
          }
          attributes.add(node.key.name);
          this.expect(14);
          if (!this.match(133)) {
            throw this.raise(Errors.ModuleAttributeInvalidValue, this.state.startLoc);
          }
          node.value = this.parseStringLiteral(this.state.value);
          attrs.push(this.finishNode(node, "ImportAttribute"));
        } while (this.eat(12));
        return attrs;
      }
      maybeParseImportAttributes(node) {
        let attributes;
        let useWith = false;
        if (this.match(76)) {
          if (this.hasPrecedingLineBreak() && this.lookaheadCharCode() === 40) {
            return;
          }
          this.next();
          {
            if (this.hasPlugin("moduleAttributes")) {
              attributes = this.parseModuleAttributes();
            } else {
              this.expectImportAttributesPlugin();
              attributes = this.parseImportAttributes();
            }
          }
          useWith = true;
        } else if (this.isContextual(94) && !this.hasPrecedingLineBreak()) {
          if (this.hasPlugin("importAttributes")) {
            if (this.getPluginOption("importAttributes", "deprecatedAssertSyntax") !== true) {
              this.raise(Errors.ImportAttributesUseAssert, this.state.startLoc);
            }
            this.addExtra(node, "deprecatedAssertSyntax", true);
          } else {
            this.expectOnePlugin(["importAttributes", "importAssertions"]);
          }
          this.next();
          attributes = this.parseImportAttributes();
        } else if (this.hasPlugin("importAttributes") || this.hasPlugin("importAssertions")) {
          attributes = [];
        } else {
          if (this.hasPlugin("moduleAttributes")) {
            attributes = [];
          } else return;
        }
        if (!useWith && this.hasPlugin("importAssertions")) {
          node.assertions = attributes;
        } else {
          node.attributes = attributes;
        }
      }
      maybeParseDefaultImportSpecifier(node, maybeDefaultIdentifier) {
        if (maybeDefaultIdentifier) {
          const specifier = this.startNodeAtNode(maybeDefaultIdentifier);
          specifier.local = maybeDefaultIdentifier;
          node.specifiers.push(this.finishImportSpecifier(specifier, "ImportDefaultSpecifier"));
          return true;
        } else if (tokenIsKeywordOrIdentifier(this.state.type)) {
          this.parseImportSpecifierLocal(node, this.startNode(), "ImportDefaultSpecifier");
          return true;
        }
        return false;
      }
      maybeParseStarImportSpecifier(node) {
        if (this.match(55)) {
          const specifier = this.startNode();
          this.next();
          this.expectContextual(93);
          this.parseImportSpecifierLocal(node, specifier, "ImportNamespaceSpecifier");
          return true;
        }
        return false;
      }
      parseNamedImportSpecifiers(node) {
        let first = true;
        this.expect(5);
        while (!this.eat(8)) {
          if (first) {
            first = false;
          } else {
            if (this.eat(14)) {
              throw this.raise(Errors.DestructureNamedImport, this.state.startLoc);
            }
            this.expect(12);
            if (this.eat(8)) break;
          }
          const specifier = this.startNode();
          const importedIsString = this.match(133);
          const isMaybeTypeOnly = this.isContextual(130);
          specifier.imported = this.parseModuleExportName();
          const importSpecifier = this.parseImportSpecifier(specifier, importedIsString, node.importKind === "type" || node.importKind === "typeof", isMaybeTypeOnly, void 0);
          node.specifiers.push(importSpecifier);
        }
      }
      parseImportSpecifier(specifier, importedIsString, isInTypeOnlyImport, isMaybeTypeOnly, bindingType) {
        if (this.eatContextual(93)) {
          specifier.local = this.parseIdentifier();
        } else {
          const {
            imported
          } = specifier;
          if (importedIsString) {
            throw this.raise(Errors.ImportBindingIsString, specifier, {
              importName: imported.value
            });
          }
          this.checkReservedWord(imported.name, specifier.loc.start, true, true);
          if (!specifier.local) {
            specifier.local = cloneIdentifier(imported);
          }
        }
        return this.finishImportSpecifier(specifier, "ImportSpecifier", bindingType);
      }
      isThisParam(param) {
        return param.type === "Identifier" && param.name === "this";
      }
    };
    var Parser = class extends StatementParser {
      constructor(options, input) {
        options = getOptions(options);
        super(options, input);
        this.options = options;
        this.initializeScopes();
        this.plugins = pluginsMap(this.options.plugins);
        this.filename = options.sourceFilename;
      }
      getScopeHandler() {
        return ScopeHandler;
      }
      parse() {
        this.enterInitialScopes();
        const file = this.startNode();
        const program = this.startNode();
        this.nextToken();
        file.errors = null;
        this.parseTopLevel(file, program);
        file.errors = this.state.errors;
        file.comments.length = this.state.commentsLen;
        return file;
      }
    };
    function pluginsMap(plugins) {
      const pluginMap = /* @__PURE__ */ new Map();
      for (const plugin of plugins) {
        const [name, options] = Array.isArray(plugin) ? plugin : [plugin, {}];
        if (!pluginMap.has(name)) pluginMap.set(name, options || {});
      }
      return pluginMap;
    }
    function parse(input, options) {
      var _options;
      if (((_options = options) == null ? void 0 : _options.sourceType) === "unambiguous") {
        options = Object.assign({}, options);
        try {
          options.sourceType = "module";
          const parser = getParser(options, input);
          const ast = parser.parse();
          if (parser.sawUnambiguousESM) {
            return ast;
          }
          if (parser.ambiguousScriptDifferentAst) {
            try {
              options.sourceType = "script";
              return getParser(options, input).parse();
            } catch (_unused) {
            }
          } else {
            ast.program.sourceType = "script";
          }
          return ast;
        } catch (moduleError) {
          try {
            options.sourceType = "script";
            return getParser(options, input).parse();
          } catch (_unused2) {
          }
          throw moduleError;
        }
      } else {
        return getParser(options, input).parse();
      }
    }
    function parseExpression(input, options) {
      const parser = getParser(options, input);
      if (parser.options.strictMode) {
        parser.state.strict = true;
      }
      return parser.getExpression();
    }
    function generateExportedTokenTypes(internalTokenTypes) {
      const tokenTypes2 = {};
      for (const typeName of Object.keys(internalTokenTypes)) {
        tokenTypes2[typeName] = getExportedToken(internalTokenTypes[typeName]);
      }
      return tokenTypes2;
    }
    var tokTypes = generateExportedTokenTypes(tt);
    function getParser(options, input) {
      let cls = Parser;
      if (options != null && options.plugins) {
        validatePlugins(options.plugins);
        cls = getParserClass(options.plugins);
      }
      return new cls(options, input);
    }
    var parserClassCache = {};
    function getParserClass(pluginsFromOptions) {
      const pluginList = mixinPluginNames.filter((name) => hasPlugin(pluginsFromOptions, name));
      const key = pluginList.join("/");
      let cls = parserClassCache[key];
      if (!cls) {
        cls = Parser;
        for (const plugin of pluginList) {
          cls = mixinPlugins[plugin](cls);
        }
        parserClassCache[key] = cls;
      }
      return cls;
    }
    exports2.parse = parse;
    exports2.parseExpression = parseExpression;
    exports2.tokTypes = tokTypes;
  }
});

// node_modules/@babel/helper-plugin-utils/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/@babel/helper-plugin-utils/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.declare = declare;
    exports2.declarePreset = void 0;
    var apiPolyfills = {
      assertVersion: (api) => (range) => {
        throwVersionError(range, api.version);
      }
    };
    {
      Object.assign(apiPolyfills, {
        targets: () => () => {
          return {};
        },
        assumption: () => () => {
          return void 0;
        }
      });
    }
    function declare(builder) {
      return (api, options, dirname) => {
        var _clonedApi2;
        let clonedApi;
        for (const name of Object.keys(apiPolyfills)) {
          var _clonedApi;
          if (api[name]) continue;
          (_clonedApi = clonedApi) != null ? _clonedApi : clonedApi = copyApiObject(api);
          clonedApi[name] = apiPolyfills[name](clonedApi);
        }
        return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);
      };
    }
    var declarePreset = exports2.declarePreset = declare;
    function copyApiObject(api) {
      let proto = null;
      if (typeof api.version === "string" && /^7\./.test(api.version)) {
        proto = Object.getPrototypeOf(api);
        if (proto && (!hasOwnProperty.call(proto, "version") || !hasOwnProperty.call(proto, "transform") || !hasOwnProperty.call(proto, "template") || !hasOwnProperty.call(proto, "types"))) {
          proto = null;
        }
      }
      return Object.assign({}, proto, api);
    }
    function throwVersionError(range, version) {
      if (typeof range === "number") {
        if (!Number.isInteger(range)) {
          throw new Error("Expected string or integer value.");
        }
        range = `^${range}.0.0-0`;
      }
      if (typeof range !== "string") {
        throw new Error("Expected string or integer value.");
      }
      const limit = Error.stackTraceLimit;
      if (typeof limit === "number" && limit < 25) {
        Error.stackTraceLimit = 25;
      }
      let err;
      if (version.slice(0, 2) === "7.") {
        err = new Error(`Requires Babel "^7.0.0-beta.41", but was loaded with "${version}". You'll need to update your @babel/core version.`);
      } else {
        err = new Error(`Requires Babel "${range}", but was loaded with "${version}". If you are sure you have a compatible version of @babel/core, it is likely that something in your build process is loading the wrong version. Inspect the stack trace of this error to look for the first entry that doesn't mention "@babel/core" or "babel-core" to see what is calling Babel.`);
      }
      if (typeof limit === "number") {
        Error.stackTraceLimit = limit;
      }
      throw Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version,
        range
      });
    }
  }
});

// node_modules/function-bind/implementation.js
var require_implementation = __commonJS({
  "node_modules/function-bind/implementation.js"(exports2, module2) {
    "use strict";
    var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
    var toStr = Object.prototype.toString;
    var max = Math.max;
    var funcType = "[object Function]";
    var concatty = function concatty2(a, b) {
      var arr = [];
      for (var i = 0; i < a.length; i += 1) {
        arr[i] = a[i];
      }
      for (var j = 0; j < b.length; j += 1) {
        arr[j + a.length] = b[j];
      }
      return arr;
    };
    var slicy = function slicy2(arrLike, offset) {
      var arr = [];
      for (var i = offset || 0, j = 0; i < arrLike.length; i += 1, j += 1) {
        arr[j] = arrLike[i];
      }
      return arr;
    };
    var joiny = function(arr, joiner) {
      var str = "";
      for (var i = 0; i < arr.length; i += 1) {
        str += arr[i];
        if (i + 1 < arr.length) {
          str += joiner;
        }
      }
      return str;
    };
    module2.exports = function bind(that) {
      var target = this;
      if (typeof target !== "function" || toStr.apply(target) !== funcType) {
        throw new TypeError(ERROR_MESSAGE + target);
      }
      var args = slicy(arguments, 1);
      var bound;
      var binder = function() {
        if (this instanceof bound) {
          var result = target.apply(
            this,
            concatty(args, arguments)
          );
          if (Object(result) === result) {
            return result;
          }
          return this;
        }
        return target.apply(
          that,
          concatty(args, arguments)
        );
      };
      var boundLength = max(0, target.length - args.length);
      var boundArgs = [];
      for (var i = 0; i < boundLength; i++) {
        boundArgs[i] = "$" + i;
      }
      bound = Function("binder", "return function (" + joiny(boundArgs, ",") + "){ return binder.apply(this,arguments); }")(binder);
      if (target.prototype) {
        var Empty = function Empty2() {
        };
        Empty.prototype = target.prototype;
        bound.prototype = new Empty();
        Empty.prototype = null;
      }
      return bound;
    };
  }
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS({
  "node_modules/function-bind/index.js"(exports2, module2) {
    "use strict";
    var implementation = require_implementation();
    module2.exports = Function.prototype.bind || implementation;
  }
});

// node_modules/hasown/index.js
var require_hasown = __commonJS({
  "node_modules/hasown/index.js"(exports2, module2) {
    "use strict";
    var call = Function.prototype.call;
    var $hasOwn = Object.prototype.hasOwnProperty;
    var bind = require_function_bind();
    module2.exports = bind.call(call, $hasOwn);
  }
});

// node_modules/is-core-module/core.json
var require_core = __commonJS({
  "node_modules/is-core-module/core.json"(exports2, module2) {
    module2.exports = {
      assert: true,
      "node:assert": [">= 14.18 && < 15", ">= 16"],
      "assert/strict": ">= 15",
      "node:assert/strict": ">= 16",
      async_hooks: ">= 8",
      "node:async_hooks": [">= 14.18 && < 15", ">= 16"],
      buffer_ieee754: ">= 0.5 && < 0.9.7",
      buffer: true,
      "node:buffer": [">= 14.18 && < 15", ">= 16"],
      child_process: true,
      "node:child_process": [">= 14.18 && < 15", ">= 16"],
      cluster: ">= 0.5",
      "node:cluster": [">= 14.18 && < 15", ">= 16"],
      console: true,
      "node:console": [">= 14.18 && < 15", ">= 16"],
      constants: true,
      "node:constants": [">= 14.18 && < 15", ">= 16"],
      crypto: true,
      "node:crypto": [">= 14.18 && < 15", ">= 16"],
      _debug_agent: ">= 1 && < 8",
      _debugger: "< 8",
      dgram: true,
      "node:dgram": [">= 14.18 && < 15", ">= 16"],
      diagnostics_channel: [">= 14.17 && < 15", ">= 15.1"],
      "node:diagnostics_channel": [">= 14.18 && < 15", ">= 16"],
      dns: true,
      "node:dns": [">= 14.18 && < 15", ">= 16"],
      "dns/promises": ">= 15",
      "node:dns/promises": ">= 16",
      domain: ">= 0.7.12",
      "node:domain": [">= 14.18 && < 15", ">= 16"],
      events: true,
      "node:events": [">= 14.18 && < 15", ">= 16"],
      freelist: "< 6",
      fs: true,
      "node:fs": [">= 14.18 && < 15", ">= 16"],
      "fs/promises": [">= 10 && < 10.1", ">= 14"],
      "node:fs/promises": [">= 14.18 && < 15", ">= 16"],
      _http_agent: ">= 0.11.1",
      "node:_http_agent": [">= 14.18 && < 15", ">= 16"],
      _http_client: ">= 0.11.1",
      "node:_http_client": [">= 14.18 && < 15", ">= 16"],
      _http_common: ">= 0.11.1",
      "node:_http_common": [">= 14.18 && < 15", ">= 16"],
      _http_incoming: ">= 0.11.1",
      "node:_http_incoming": [">= 14.18 && < 15", ">= 16"],
      _http_outgoing: ">= 0.11.1",
      "node:_http_outgoing": [">= 14.18 && < 15", ">= 16"],
      _http_server: ">= 0.11.1",
      "node:_http_server": [">= 14.18 && < 15", ">= 16"],
      http: true,
      "node:http": [">= 14.18 && < 15", ">= 16"],
      http2: ">= 8.8",
      "node:http2": [">= 14.18 && < 15", ">= 16"],
      https: true,
      "node:https": [">= 14.18 && < 15", ">= 16"],
      inspector: ">= 8",
      "node:inspector": [">= 14.18 && < 15", ">= 16"],
      "inspector/promises": [">= 19"],
      "node:inspector/promises": [">= 19"],
      _linklist: "< 8",
      module: true,
      "node:module": [">= 14.18 && < 15", ">= 16"],
      net: true,
      "node:net": [">= 14.18 && < 15", ">= 16"],
      "node-inspect/lib/_inspect": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_client": ">= 7.6 && < 12",
      "node-inspect/lib/internal/inspect_repl": ">= 7.6 && < 12",
      os: true,
      "node:os": [">= 14.18 && < 15", ">= 16"],
      path: true,
      "node:path": [">= 14.18 && < 15", ">= 16"],
      "path/posix": ">= 15.3",
      "node:path/posix": ">= 16",
      "path/win32": ">= 15.3",
      "node:path/win32": ">= 16",
      perf_hooks: ">= 8.5",
      "node:perf_hooks": [">= 14.18 && < 15", ">= 16"],
      process: ">= 1",
      "node:process": [">= 14.18 && < 15", ">= 16"],
      punycode: ">= 0.5",
      "node:punycode": [">= 14.18 && < 15", ">= 16"],
      querystring: true,
      "node:querystring": [">= 14.18 && < 15", ">= 16"],
      readline: true,
      "node:readline": [">= 14.18 && < 15", ">= 16"],
      "readline/promises": ">= 17",
      "node:readline/promises": ">= 17",
      repl: true,
      "node:repl": [">= 14.18 && < 15", ">= 16"],
      "node:sea": [">= 20.12 && < 21", ">= 21.7"],
      smalloc: ">= 0.11.5 && < 3",
      _stream_duplex: ">= 0.9.4",
      "node:_stream_duplex": [">= 14.18 && < 15", ">= 16"],
      _stream_transform: ">= 0.9.4",
      "node:_stream_transform": [">= 14.18 && < 15", ">= 16"],
      _stream_wrap: ">= 1.4.1",
      "node:_stream_wrap": [">= 14.18 && < 15", ">= 16"],
      _stream_passthrough: ">= 0.9.4",
      "node:_stream_passthrough": [">= 14.18 && < 15", ">= 16"],
      _stream_readable: ">= 0.9.4",
      "node:_stream_readable": [">= 14.18 && < 15", ">= 16"],
      _stream_writable: ">= 0.9.4",
      "node:_stream_writable": [">= 14.18 && < 15", ">= 16"],
      stream: true,
      "node:stream": [">= 14.18 && < 15", ">= 16"],
      "stream/consumers": ">= 16.7",
      "node:stream/consumers": ">= 16.7",
      "stream/promises": ">= 15",
      "node:stream/promises": ">= 16",
      "stream/web": ">= 16.5",
      "node:stream/web": ">= 16.5",
      string_decoder: true,
      "node:string_decoder": [">= 14.18 && < 15", ">= 16"],
      sys: [">= 0.4 && < 0.7", ">= 0.8"],
      "node:sys": [">= 14.18 && < 15", ">= 16"],
      "test/reporters": ">= 19.9 && < 20.2",
      "node:test/reporters": [">= 18.17 && < 19", ">= 19.9", ">= 20"],
      "test/mock_loader": ">= 22.3",
      "node:test/mock_loader": ">= 22.3",
      "node:test": [">= 16.17 && < 17", ">= 18"],
      timers: true,
      "node:timers": [">= 14.18 && < 15", ">= 16"],
      "timers/promises": ">= 15",
      "node:timers/promises": ">= 16",
      _tls_common: ">= 0.11.13",
      "node:_tls_common": [">= 14.18 && < 15", ">= 16"],
      _tls_legacy: ">= 0.11.3 && < 10",
      _tls_wrap: ">= 0.11.3",
      "node:_tls_wrap": [">= 14.18 && < 15", ">= 16"],
      tls: true,
      "node:tls": [">= 14.18 && < 15", ">= 16"],
      trace_events: ">= 10",
      "node:trace_events": [">= 14.18 && < 15", ">= 16"],
      tty: true,
      "node:tty": [">= 14.18 && < 15", ">= 16"],
      url: true,
      "node:url": [">= 14.18 && < 15", ">= 16"],
      util: true,
      "node:util": [">= 14.18 && < 15", ">= 16"],
      "util/types": ">= 15.3",
      "node:util/types": ">= 16",
      "v8/tools/arguments": ">= 10 && < 12",
      "v8/tools/codemap": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/consarray": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/csvparser": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/logreader": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/profile_view": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      "v8/tools/splaytree": [">= 4.4 && < 5", ">= 5.2 && < 12"],
      v8: ">= 1",
      "node:v8": [">= 14.18 && < 15", ">= 16"],
      vm: true,
      "node:vm": [">= 14.18 && < 15", ">= 16"],
      wasi: [">= 13.4 && < 13.5", ">= 18.17 && < 19", ">= 20"],
      "node:wasi": [">= 18.17 && < 19", ">= 20"],
      worker_threads: ">= 11.7",
      "node:worker_threads": [">= 14.18 && < 15", ">= 16"],
      zlib: ">= 0.5",
      "node:zlib": [">= 14.18 && < 15", ">= 16"]
    };
  }
});

// node_modules/is-core-module/index.js
var require_is_core_module = __commonJS({
  "node_modules/is-core-module/index.js"(exports2, module2) {
    "use strict";
    var hasOwn = require_hasown();
    function specifierIncluded(current, specifier) {
      var nodeParts = current.split(".");
      var parts = specifier.split(" ");
      var op = parts.length > 1 ? parts[0] : "=";
      var versionParts = (parts.length > 1 ? parts[1] : parts[0]).split(".");
      for (var i = 0; i < 3; ++i) {
        var cur = parseInt(nodeParts[i] || 0, 10);
        var ver = parseInt(versionParts[i] || 0, 10);
        if (cur === ver) {
          continue;
        }
        if (op === "<") {
          return cur < ver;
        }
        if (op === ">=") {
          return cur >= ver;
        }
        return false;
      }
      return op === ">=";
    }
    function matchesRange(current, range) {
      var specifiers = range.split(/ ?&& ?/);
      if (specifiers.length === 0) {
        return false;
      }
      for (var i = 0; i < specifiers.length; ++i) {
        if (!specifierIncluded(current, specifiers[i])) {
          return false;
        }
      }
      return true;
    }
    function versionIncluded(nodeVersion, specifierValue) {
      if (typeof specifierValue === "boolean") {
        return specifierValue;
      }
      var current = typeof nodeVersion === "undefined" ? process.versions && process.versions.node : nodeVersion;
      if (typeof current !== "string") {
        throw new TypeError(typeof nodeVersion === "undefined" ? "Unable to determine current node version" : "If provided, a valid node version is required");
      }
      if (specifierValue && typeof specifierValue === "object") {
        for (var i = 0; i < specifierValue.length; ++i) {
          if (matchesRange(current, specifierValue[i])) {
            return true;
          }
        }
        return false;
      }
      return matchesRange(current, specifierValue);
    }
    var data = require_core();
    module2.exports = function isCore(x, nodeVersion) {
      return hasOwn(data, x) && versionIncluded(nodeVersion, data[x]);
    };
  }
});

// node_modules/resolve/lib/homedir.js
var require_homedir = __commonJS({
  "node_modules/resolve/lib/homedir.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    module2.exports = os.homedir || function homedir() {
      var home = process.env.HOME;
      var user = process.env.LOGNAME || process.env.USER || process.env.LNAME || process.env.USERNAME;
      if (process.platform === "win32") {
        return process.env.USERPROFILE || process.env.HOMEDRIVE + process.env.HOMEPATH || home || null;
      }
      if (process.platform === "darwin") {
        return home || (user ? "/Users/" + user : null);
      }
      if (process.platform === "linux") {
        return home || (process.getuid() === 0 ? "/root" : user ? "/home/" + user : null);
      }
      return home || null;
    };
  }
});

// node_modules/resolve/lib/caller.js
var require_caller = __commonJS({
  "node_modules/resolve/lib/caller.js"(exports2, module2) {
    module2.exports = function() {
      var origPrepareStackTrace = Error.prepareStackTrace;
      Error.prepareStackTrace = function(_, stack2) {
        return stack2;
      };
      var stack = new Error().stack;
      Error.prepareStackTrace = origPrepareStackTrace;
      return stack[2].getFileName();
    };
  }
});

// node_modules/path-parse/index.js
var require_path_parse = __commonJS({
  "node_modules/path-parse/index.js"(exports2, module2) {
    "use strict";
    var isWindows = process.platform === "win32";
    var splitWindowsRe = /^(((?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/]+[^\\\/]+)?[\\\/]?)(?:[^\\\/]*[\\\/])*)((\.{1,2}|[^\\\/]+?|)(\.[^.\/\\]*|))[\\\/]*$/;
    var win32 = {};
    function win32SplitPath(filename) {
      return splitWindowsRe.exec(filename).slice(1);
    }
    win32.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = win32SplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0] === allParts[1] ? allParts[0] : allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    var splitPathRe = /^((\/?)(?:[^\/]*\/)*)((\.{1,2}|[^\/]+?|)(\.[^.\/]*|))[\/]*$/;
    var posix = {};
    function posixSplitPath(filename) {
      return splitPathRe.exec(filename).slice(1);
    }
    posix.parse = function(pathString) {
      if (typeof pathString !== "string") {
        throw new TypeError(
          "Parameter 'pathString' must be a string, not " + typeof pathString
        );
      }
      var allParts = posixSplitPath(pathString);
      if (!allParts || allParts.length !== 5) {
        throw new TypeError("Invalid path '" + pathString + "'");
      }
      return {
        root: allParts[1],
        dir: allParts[0].slice(0, -1),
        base: allParts[2],
        ext: allParts[4],
        name: allParts[3]
      };
    };
    if (isWindows)
      module2.exports = win32.parse;
    else
      module2.exports = posix.parse;
    module2.exports.posix = posix.parse;
    module2.exports.win32 = win32.parse;
  }
});

// node_modules/resolve/lib/node-modules-paths.js
var require_node_modules_paths = __commonJS({
  "node_modules/resolve/lib/node-modules-paths.js"(exports2, module2) {
    var path = require("path");
    var parse = path.parse || require_path_parse();
    var getNodeModulesDirs = function getNodeModulesDirs2(absoluteStart, modules) {
      var prefix = "/";
      if (/^([A-Za-z]:)/.test(absoluteStart)) {
        prefix = "";
      } else if (/^\\\\/.test(absoluteStart)) {
        prefix = "\\\\";
      }
      var paths = [absoluteStart];
      var parsed = parse(absoluteStart);
      while (parsed.dir !== paths[paths.length - 1]) {
        paths.push(parsed.dir);
        parsed = parse(parsed.dir);
      }
      return paths.reduce(function(dirs, aPath) {
        return dirs.concat(modules.map(function(moduleDir) {
          return path.resolve(prefix, aPath, moduleDir);
        }));
      }, []);
    };
    module2.exports = function nodeModulesPaths(start, opts, request) {
      var modules = opts && opts.moduleDirectory ? [].concat(opts.moduleDirectory) : ["node_modules"];
      if (opts && typeof opts.paths === "function") {
        return opts.paths(
          request,
          start,
          function() {
            return getNodeModulesDirs(start, modules);
          },
          opts
        );
      }
      var dirs = getNodeModulesDirs(start, modules);
      return opts && opts.paths ? dirs.concat(opts.paths) : dirs;
    };
  }
});

// node_modules/resolve/lib/normalize-options.js
var require_normalize_options = __commonJS({
  "node_modules/resolve/lib/normalize-options.js"(exports2, module2) {
    module2.exports = function(x, opts) {
      return opts || {};
    };
  }
});

// node_modules/resolve/lib/sync.js
var require_sync = __commonJS({
  "node_modules/resolve/lib/sync.js"(exports2, module2) {
    var isCore = require_is_core_module();
    var fs = require("fs");
    var path = require("path");
    var getHomedir = require_homedir();
    var caller = require_caller();
    var nodeModulesPaths = require_node_modules_paths();
    var normalizeOptions = require_normalize_options();
    var realpathFS = process.platform !== "win32" && fs.realpathSync && typeof fs.realpathSync.native === "function" ? fs.realpathSync.native : fs.realpathSync;
    var homedir = getHomedir();
    var defaultPaths = function() {
      return [
        path.join(homedir, ".node_modules"),
        path.join(homedir, ".node_libraries")
      ];
    };
    var defaultIsFile = function isFile(file) {
      try {
        var stat = fs.statSync(file, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && (stat.isFile() || stat.isFIFO());
    };
    var defaultIsDir = function isDirectory(dir) {
      try {
        var stat = fs.statSync(dir, { throwIfNoEntry: false });
      } catch (e) {
        if (e && (e.code === "ENOENT" || e.code === "ENOTDIR")) return false;
        throw e;
      }
      return !!stat && stat.isDirectory();
    };
    var defaultRealpathSync = function realpathSync(x) {
      try {
        return realpathFS(x);
      } catch (realpathErr) {
        if (realpathErr.code !== "ENOENT") {
          throw realpathErr;
        }
      }
      return x;
    };
    var maybeRealpathSync = function maybeRealpathSync2(realpathSync, x, opts) {
      if (!opts || !opts.preserveSymlinks) {
        return realpathSync(x);
      }
      return x;
    };
    var defaultReadPackageSync = function defaultReadPackageSync2(readFileSync, pkgfile) {
      return JSON.parse(readFileSync(pkgfile));
    };
    var getPackageCandidates = function getPackageCandidates2(x, start, opts) {
      var dirs = nodeModulesPaths(start, opts, x);
      for (var i = 0; i < dirs.length; i++) {
        dirs[i] = path.join(dirs[i], x);
      }
      return dirs;
    };
    module2.exports = function resolveSync(x, options) {
      if (typeof x !== "string") {
        throw new TypeError("Path must be a string.");
      }
      var opts = normalizeOptions(x, options);
      var isFile = opts.isFile || defaultIsFile;
      var isDirectory = opts.isDirectory || defaultIsDir;
      var readFileSync = opts.readFileSync || fs.readFileSync;
      var realpathSync = opts.realpathSync || defaultRealpathSync;
      var readPackageSync = opts.readPackageSync || defaultReadPackageSync;
      if (opts.readFileSync && opts.readPackageSync) {
        throw new TypeError("`readFileSync` and `readPackageSync` are mutually exclusive.");
      }
      var packageIterator = opts.packageIterator;
      var extensions = opts.extensions || [".js"];
      var includeCoreModules = opts.includeCoreModules !== false;
      var basedir = opts.basedir || path.dirname(caller());
      var parent = opts.filename || basedir;
      opts.paths = opts.paths || defaultPaths();
      var absoluteStart = maybeRealpathSync(realpathSync, path.resolve(basedir), opts);
      if (opts.basedir && !isDirectory(absoluteStart)) {
        var dirError = new TypeError('Provided basedir "' + opts.basedir + '" is not a directory' + (opts.preserveSymlinks ? "" : ", or a symlink to a directory"));
        dirError.code = "INVALID_BASEDIR";
        throw dirError;
      }
      if (/^(?:\.\.?(?:\/|$)|\/|([A-Za-z]:)?[/\\])/.test(x)) {
        var res = path.resolve(absoluteStart, x);
        if (x === "." || x === ".." || x.slice(-1) === "/") res += "/";
        var m = loadAsFileSync(res) || loadAsDirectorySync(res);
        if (m) return maybeRealpathSync(realpathSync, m, opts);
      } else if (includeCoreModules && isCore(x)) {
        return x;
      } else {
        var n = loadNodeModulesSync(x, absoluteStart);
        if (n) return maybeRealpathSync(realpathSync, n, opts);
      }
      var err = new Error("Cannot find module '" + x + "' from '" + parent + "'");
      err.code = "MODULE_NOT_FOUND";
      throw err;
      function loadAsFileSync(x2) {
        var pkg = loadpkg(path.dirname(x2));
        if (pkg && pkg.dir && pkg.pkg && opts.pathFilter) {
          var rfile = path.relative(pkg.dir, x2);
          var r = opts.pathFilter(pkg.pkg, x2, rfile);
          if (r) {
            x2 = path.resolve(pkg.dir, r);
          }
        }
        if (isFile(x2)) {
          return x2;
        }
        for (var i = 0; i < extensions.length; i++) {
          var file = x2 + extensions[i];
          if (isFile(file)) {
            return file;
          }
        }
      }
      function loadpkg(dir) {
        if (dir === "" || dir === "/") return;
        if (process.platform === "win32" && /^\w:[/\\]*$/.test(dir)) {
          return;
        }
        if (/[/\\]node_modules[/\\]*$/.test(dir)) return;
        var pkgfile = path.join(isDirectory(dir) ? maybeRealpathSync(realpathSync, dir, opts) : dir, "package.json");
        if (!isFile(pkgfile)) {
          return loadpkg(path.dirname(dir));
        }
        var pkg;
        try {
          pkg = readPackageSync(readFileSync, pkgfile);
        } catch (e) {
          if (!(e instanceof SyntaxError)) {
            throw e;
          }
        }
        if (pkg && opts.packageFilter) {
          pkg = opts.packageFilter(pkg, pkgfile, dir);
        }
        return { pkg, dir };
      }
      function loadAsDirectorySync(x2) {
        var pkgfile = path.join(isDirectory(x2) ? maybeRealpathSync(realpathSync, x2, opts) : x2, "/package.json");
        if (isFile(pkgfile)) {
          try {
            var pkg = readPackageSync(readFileSync, pkgfile);
          } catch (e) {
          }
          if (pkg && opts.packageFilter) {
            pkg = opts.packageFilter(pkg, pkgfile, x2);
          }
          if (pkg && pkg.main) {
            if (typeof pkg.main !== "string") {
              var mainError = new TypeError("package \u201C" + pkg.name + "\u201D `main` must be a string");
              mainError.code = "INVALID_PACKAGE_MAIN";
              throw mainError;
            }
            if (pkg.main === "." || pkg.main === "./") {
              pkg.main = "index";
            }
            try {
              var mainPath = path.resolve(x2, pkg.main);
              var m2 = loadAsFileSync(mainPath);
              if (m2) return m2;
              var n2 = loadAsDirectorySync(mainPath);
              if (n2) return n2;
              var checkIndex = loadAsFileSync(path.resolve(x2, "index"));
              if (checkIndex) return checkIndex;
            } catch (e) {
            }
            var incorrectMainError = new Error("Cannot find module '" + path.resolve(x2, pkg.main) + `'. Please verify that the package.json has a valid "main" entry`);
            incorrectMainError.code = "INCORRECT_PACKAGE_MAIN";
            throw incorrectMainError;
          }
        }
        return loadAsFileSync(path.join(x2, "/index"));
      }
      function loadNodeModulesSync(x2, start) {
        var thunk = function() {
          return getPackageCandidates(x2, start, opts);
        };
        var dirs = packageIterator ? packageIterator(x2, start, thunk, opts) : thunk();
        for (var i = 0; i < dirs.length; i++) {
          var dir = dirs[i];
          if (isDirectory(path.dirname(dir))) {
            var m2 = loadAsFileSync(dir);
            if (m2) return m2;
            var n2 = loadAsDirectorySync(dir);
            if (n2) return n2;
          }
        }
      }
    };
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports2.isTag = isTag;
    exports2.Root = ElementType.Root;
    exports2.Text = ElementType.Text;
    exports2.Directive = ElementType.Directive;
    exports2.Comment = ElementType.Comment;
    exports2.Script = ElementType.Script;
    exports2.Style = ElementType.Style;
    exports2.Tag = ElementType.Tag;
    exports2.CDATA = ElementType.CDATA;
    exports2.Doctype = ElementType.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    }();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
    var domelementtype_1 = require_lib3();
    var nodeTypes = /* @__PURE__ */ new Map([
      [domelementtype_1.ElementType.Tag, 1],
      [domelementtype_1.ElementType.Script, 1],
      [domelementtype_1.ElementType.Style, 1],
      [domelementtype_1.ElementType.Directive, 1],
      [domelementtype_1.ElementType.Text, 3],
      [domelementtype_1.ElementType.CDATA, 4],
      [domelementtype_1.ElementType.Comment, 8],
      [domelementtype_1.ElementType.Root, 9]
    ]);
    var Node = (
      /** @class */
      function() {
        function Node2(type) {
          this.type = type;
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node2.prototype, "nodeType", {
          // Read-only aliases
          /**
           * [DOM spec](https://dom.spec.whatwg.org/#dom-node-nodetype)-compatible
           * node {@link type}.
           */
          get: function() {
            var _a;
            return (_a = nodeTypes.get(this.type)) !== null && _a !== void 0 ? _a : 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node2.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node2;
      }()
    );
    exports2.Node = Node;
    var DataNode = (
      /** @class */
      function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(type, data) {
          var _this = _super.call(this, type) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      }(Node)
    );
    exports2.DataNode = DataNode;
    var Text = (
      /** @class */
      function(_super) {
        __extends(Text2, _super);
        function Text2(data) {
          return _super.call(this, domelementtype_1.ElementType.Text, data) || this;
        }
        return Text2;
      }(DataNode)
    );
    exports2.Text = Text;
    var Comment = (
      /** @class */
      function(_super) {
        __extends(Comment2, _super);
        function Comment2(data) {
          return _super.call(this, domelementtype_1.ElementType.Comment, data) || this;
        }
        return Comment2;
      }(DataNode)
    );
    exports2.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, domelementtype_1.ElementType.Directive, data) || this;
          _this.name = name;
          return _this;
        }
        return ProcessingInstruction2;
      }(DataNode)
    );
    exports2.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(type, children) {
          var _this = _super.call(this, type) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      }(Node)
    );
    exports2.NodeWithChildren = NodeWithChildren;
    var Document = (
      /** @class */
      function(_super) {
        __extends(Document2, _super);
        function Document2(children) {
          return _super.call(this, domelementtype_1.ElementType.Root, children) || this;
        }
        return Document2;
      }(NodeWithChildren)
    );
    exports2.Document = Document;
    var Element = (
      /** @class */
      function(_super) {
        __extends(Element2, _super);
        function Element2(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, type, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          return _this;
        }
        Object.defineProperty(Element2.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element2;
      }(NodeWithChildren)
    );
    exports2.Element = Element;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports2.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports2.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports2.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports2.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports2.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports2.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports2.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new NodeWithChildren(domelementtype_1.ElementType.CDATA, children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports2.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
      }
      return children;
    }
  }
});

// node_modules/domhandler/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomHandler = void 0;
    var domelementtype_1 = require_lib3();
    var node_1 = require_node();
    __exportStar(require_node(), exports2);
    var reWhitespace = /\s+/g;
    var defaultOpts = {
      normalizeWhitespace: false,
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var normalizeWhitespace = this.options.normalizeWhitespace;
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            if (normalizeWhitespace) {
              lastNode.data = (lastNode.data + data).replace(reWhitespace, " ");
            } else {
              lastNode.data += data;
            }
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            if (normalizeWhitespace) {
              data = data.replace(reWhitespace, " ");
            }
            var node = new node_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_1.Text("");
          var node = new node_1.NodeWithChildren(domelementtype_1.ElementType.CDATA, [text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      }()
    );
    exports2.DomHandler = DomHandler;
    exports2.default = DomHandler;
  }
});

// node_modules/entities/lib/maps/entities.json
var require_entities = __commonJS({
  "node_modules/entities/lib/maps/entities.json"(exports2, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Abreve: "\u0102", abreve: "\u0103", ac: "\u223E", acd: "\u223F", acE: "\u223E\u0333", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", Acy: "\u0410", acy: "\u0430", AElig: "\xC6", aelig: "\xE6", af: "\u2061", Afr: "\u{1D504}", afr: "\u{1D51E}", Agrave: "\xC0", agrave: "\xE0", alefsym: "\u2135", aleph: "\u2135", Alpha: "\u0391", alpha: "\u03B1", Amacr: "\u0100", amacr: "\u0101", amalg: "\u2A3F", amp: "&", AMP: "&", andand: "\u2A55", And: "\u2A53", and: "\u2227", andd: "\u2A5C", andslope: "\u2A58", andv: "\u2A5A", ang: "\u2220", ange: "\u29A4", angle: "\u2220", angmsdaa: "\u29A8", angmsdab: "\u29A9", angmsdac: "\u29AA", angmsdad: "\u29AB", angmsdae: "\u29AC", angmsdaf: "\u29AD", angmsdag: "\u29AE", angmsdah: "\u29AF", angmsd: "\u2221", angrt: "\u221F", angrtvb: "\u22BE", angrtvbd: "\u299D", angsph: "\u2222", angst: "\xC5", angzarr: "\u237C", Aogon: "\u0104", aogon: "\u0105", Aopf: "\u{1D538}", aopf: "\u{1D552}", apacir: "\u2A6F", ap: "\u2248", apE: "\u2A70", ape: "\u224A", apid: "\u224B", apos: "'", ApplyFunction: "\u2061", approx: "\u2248", approxeq: "\u224A", Aring: "\xC5", aring: "\xE5", Ascr: "\u{1D49C}", ascr: "\u{1D4B6}", Assign: "\u2254", ast: "*", asymp: "\u2248", asympeq: "\u224D", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", awconint: "\u2233", awint: "\u2A11", backcong: "\u224C", backepsilon: "\u03F6", backprime: "\u2035", backsim: "\u223D", backsimeq: "\u22CD", Backslash: "\u2216", Barv: "\u2AE7", barvee: "\u22BD", barwed: "\u2305", Barwed: "\u2306", barwedge: "\u2305", bbrk: "\u23B5", bbrktbrk: "\u23B6", bcong: "\u224C", Bcy: "\u0411", bcy: "\u0431", bdquo: "\u201E", becaus: "\u2235", because: "\u2235", Because: "\u2235", bemptyv: "\u29B0", bepsi: "\u03F6", bernou: "\u212C", Bernoullis: "\u212C", Beta: "\u0392", beta: "\u03B2", beth: "\u2136", between: "\u226C", Bfr: "\u{1D505}", bfr: "\u{1D51F}", bigcap: "\u22C2", bigcirc: "\u25EF", bigcup: "\u22C3", bigodot: "\u2A00", bigoplus: "\u2A01", bigotimes: "\u2A02", bigsqcup: "\u2A06", bigstar: "\u2605", bigtriangledown: "\u25BD", bigtriangleup: "\u25B3", biguplus: "\u2A04", bigvee: "\u22C1", bigwedge: "\u22C0", bkarow: "\u290D", blacklozenge: "\u29EB", blacksquare: "\u25AA", blacktriangle: "\u25B4", blacktriangledown: "\u25BE", blacktriangleleft: "\u25C2", blacktriangleright: "\u25B8", blank: "\u2423", blk12: "\u2592", blk14: "\u2591", blk34: "\u2593", block: "\u2588", bne: "=\u20E5", bnequiv: "\u2261\u20E5", bNot: "\u2AED", bnot: "\u2310", Bopf: "\u{1D539}", bopf: "\u{1D553}", bot: "\u22A5", bottom: "\u22A5", bowtie: "\u22C8", boxbox: "\u29C9", boxdl: "\u2510", boxdL: "\u2555", boxDl: "\u2556", boxDL: "\u2557", boxdr: "\u250C", boxdR: "\u2552", boxDr: "\u2553", boxDR: "\u2554", boxh: "\u2500", boxH: "\u2550", boxhd: "\u252C", boxHd: "\u2564", boxhD: "\u2565", boxHD: "\u2566", boxhu: "\u2534", boxHu: "\u2567", boxhU: "\u2568", boxHU: "\u2569", boxminus: "\u229F", boxplus: "\u229E", boxtimes: "\u22A0", boxul: "\u2518", boxuL: "\u255B", boxUl: "\u255C", boxUL: "\u255D", boxur: "\u2514", boxuR: "\u2558", boxUr: "\u2559", boxUR: "\u255A", boxv: "\u2502", boxV: "\u2551", boxvh: "\u253C", boxvH: "\u256A", boxVh: "\u256B", boxVH: "\u256C", boxvl: "\u2524", boxvL: "\u2561", boxVl: "\u2562", boxVL: "\u2563", boxvr: "\u251C", boxvR: "\u255E", boxVr: "\u255F", boxVR: "\u2560", bprime: "\u2035", breve: "\u02D8", Breve: "\u02D8", brvbar: "\xA6", bscr: "\u{1D4B7}", Bscr: "\u212C", bsemi: "\u204F", bsim: "\u223D", bsime: "\u22CD", bsolb: "\u29C5", bsol: "\\", bsolhsub: "\u27C8", bull: "\u2022", bullet: "\u2022", bump: "\u224E", bumpE: "\u2AAE", bumpe: "\u224F", Bumpeq: "\u224E", bumpeq: "\u224F", Cacute: "\u0106", cacute: "\u0107", capand: "\u2A44", capbrcup: "\u2A49", capcap: "\u2A4B", cap: "\u2229", Cap: "\u22D2", capcup: "\u2A47", capdot: "\u2A40", CapitalDifferentialD: "\u2145", caps: "\u2229\uFE00", caret: "\u2041", caron: "\u02C7", Cayleys: "\u212D", ccaps: "\u2A4D", Ccaron: "\u010C", ccaron: "\u010D", Ccedil: "\xC7", ccedil: "\xE7", Ccirc: "\u0108", ccirc: "\u0109", Cconint: "\u2230", ccups: "\u2A4C", ccupssm: "\u2A50", Cdot: "\u010A", cdot: "\u010B", cedil: "\xB8", Cedilla: "\xB8", cemptyv: "\u29B2", cent: "\xA2", centerdot: "\xB7", CenterDot: "\xB7", cfr: "\u{1D520}", Cfr: "\u212D", CHcy: "\u0427", chcy: "\u0447", check: "\u2713", checkmark: "\u2713", Chi: "\u03A7", chi: "\u03C7", circ: "\u02C6", circeq: "\u2257", circlearrowleft: "\u21BA", circlearrowright: "\u21BB", circledast: "\u229B", circledcirc: "\u229A", circleddash: "\u229D", CircleDot: "\u2299", circledR: "\xAE", circledS: "\u24C8", CircleMinus: "\u2296", CirclePlus: "\u2295", CircleTimes: "\u2297", cir: "\u25CB", cirE: "\u29C3", cire: "\u2257", cirfnint: "\u2A10", cirmid: "\u2AEF", cirscir: "\u29C2", ClockwiseContourIntegral: "\u2232", CloseCurlyDoubleQuote: "\u201D", CloseCurlyQuote: "\u2019", clubs: "\u2663", clubsuit: "\u2663", colon: ":", Colon: "\u2237", Colone: "\u2A74", colone: "\u2254", coloneq: "\u2254", comma: ",", commat: "@", comp: "\u2201", compfn: "\u2218", complement: "\u2201", complexes: "\u2102", cong: "\u2245", congdot: "\u2A6D", Congruent: "\u2261", conint: "\u222E", Conint: "\u222F", ContourIntegral: "\u222E", copf: "\u{1D554}", Copf: "\u2102", coprod: "\u2210", Coproduct: "\u2210", copy: "\xA9", COPY: "\xA9", copysr: "\u2117", CounterClockwiseContourIntegral: "\u2233", crarr: "\u21B5", cross: "\u2717", Cross: "\u2A2F", Cscr: "\u{1D49E}", cscr: "\u{1D4B8}", csub: "\u2ACF", csube: "\u2AD1", csup: "\u2AD0", csupe: "\u2AD2", ctdot: "\u22EF", cudarrl: "\u2938", cudarrr: "\u2935", cuepr: "\u22DE", cuesc: "\u22DF", cularr: "\u21B6", cularrp: "\u293D", cupbrcap: "\u2A48", cupcap: "\u2A46", CupCap: "\u224D", cup: "\u222A", Cup: "\u22D3", cupcup: "\u2A4A", cupdot: "\u228D", cupor: "\u2A45", cups: "\u222A\uFE00", curarr: "\u21B7", curarrm: "\u293C", curlyeqprec: "\u22DE", curlyeqsucc: "\u22DF", curlyvee: "\u22CE", curlywedge: "\u22CF", curren: "\xA4", curvearrowleft: "\u21B6", curvearrowright: "\u21B7", cuvee: "\u22CE", cuwed: "\u22CF", cwconint: "\u2232", cwint: "\u2231", cylcty: "\u232D", dagger: "\u2020", Dagger: "\u2021", daleth: "\u2138", darr: "\u2193", Darr: "\u21A1", dArr: "\u21D3", dash: "\u2010", Dashv: "\u2AE4", dashv: "\u22A3", dbkarow: "\u290F", dblac: "\u02DD", Dcaron: "\u010E", dcaron: "\u010F", Dcy: "\u0414", dcy: "\u0434", ddagger: "\u2021", ddarr: "\u21CA", DD: "\u2145", dd: "\u2146", DDotrahd: "\u2911", ddotseq: "\u2A77", deg: "\xB0", Del: "\u2207", Delta: "\u0394", delta: "\u03B4", demptyv: "\u29B1", dfisht: "\u297F", Dfr: "\u{1D507}", dfr: "\u{1D521}", dHar: "\u2965", dharl: "\u21C3", dharr: "\u21C2", DiacriticalAcute: "\xB4", DiacriticalDot: "\u02D9", DiacriticalDoubleAcute: "\u02DD", DiacriticalGrave: "`", DiacriticalTilde: "\u02DC", diam: "\u22C4", diamond: "\u22C4", Diamond: "\u22C4", diamondsuit: "\u2666", diams: "\u2666", die: "\xA8", DifferentialD: "\u2146", digamma: "\u03DD", disin: "\u22F2", div: "\xF7", divide: "\xF7", divideontimes: "\u22C7", divonx: "\u22C7", DJcy: "\u0402", djcy: "\u0452", dlcorn: "\u231E", dlcrop: "\u230D", dollar: "$", Dopf: "\u{1D53B}", dopf: "\u{1D555}", Dot: "\xA8", dot: "\u02D9", DotDot: "\u20DC", doteq: "\u2250", doteqdot: "\u2251", DotEqual: "\u2250", dotminus: "\u2238", dotplus: "\u2214", dotsquare: "\u22A1", doublebarwedge: "\u2306", DoubleContourIntegral: "\u222F", DoubleDot: "\xA8", DoubleDownArrow: "\u21D3", DoubleLeftArrow: "\u21D0", DoubleLeftRightArrow: "\u21D4", DoubleLeftTee: "\u2AE4", DoubleLongLeftArrow: "\u27F8", DoubleLongLeftRightArrow: "\u27FA", DoubleLongRightArrow: "\u27F9", DoubleRightArrow: "\u21D2", DoubleRightTee: "\u22A8", DoubleUpArrow: "\u21D1", DoubleUpDownArrow: "\u21D5", DoubleVerticalBar: "\u2225", DownArrowBar: "\u2913", downarrow: "\u2193", DownArrow: "\u2193", Downarrow: "\u21D3", DownArrowUpArrow: "\u21F5", DownBreve: "\u0311", downdownarrows: "\u21CA", downharpoonleft: "\u21C3", downharpoonright: "\u21C2", DownLeftRightVector: "\u2950", DownLeftTeeVector: "\u295E", DownLeftVectorBar: "\u2956", DownLeftVector: "\u21BD", DownRightTeeVector: "\u295F", DownRightVectorBar: "\u2957", DownRightVector: "\u21C1", DownTeeArrow: "\u21A7", DownTee: "\u22A4", drbkarow: "\u2910", drcorn: "\u231F", drcrop: "\u230C", Dscr: "\u{1D49F}", dscr: "\u{1D4B9}", DScy: "\u0405", dscy: "\u0455", dsol: "\u29F6", Dstrok: "\u0110", dstrok: "\u0111", dtdot: "\u22F1", dtri: "\u25BF", dtrif: "\u25BE", duarr: "\u21F5", duhar: "\u296F", dwangle: "\u29A6", DZcy: "\u040F", dzcy: "\u045F", dzigrarr: "\u27FF", Eacute: "\xC9", eacute: "\xE9", easter: "\u2A6E", Ecaron: "\u011A", ecaron: "\u011B", Ecirc: "\xCA", ecirc: "\xEA", ecir: "\u2256", ecolon: "\u2255", Ecy: "\u042D", ecy: "\u044D", eDDot: "\u2A77", Edot: "\u0116", edot: "\u0117", eDot: "\u2251", ee: "\u2147", efDot: "\u2252", Efr: "\u{1D508}", efr: "\u{1D522}", eg: "\u2A9A", Egrave: "\xC8", egrave: "\xE8", egs: "\u2A96", egsdot: "\u2A98", el: "\u2A99", Element: "\u2208", elinters: "\u23E7", ell: "\u2113", els: "\u2A95", elsdot: "\u2A97", Emacr: "\u0112", emacr: "\u0113", empty: "\u2205", emptyset: "\u2205", EmptySmallSquare: "\u25FB", emptyv: "\u2205", EmptyVerySmallSquare: "\u25AB", emsp13: "\u2004", emsp14: "\u2005", emsp: "\u2003", ENG: "\u014A", eng: "\u014B", ensp: "\u2002", Eogon: "\u0118", eogon: "\u0119", Eopf: "\u{1D53C}", eopf: "\u{1D556}", epar: "\u22D5", eparsl: "\u29E3", eplus: "\u2A71", epsi: "\u03B5", Epsilon: "\u0395", epsilon: "\u03B5", epsiv: "\u03F5", eqcirc: "\u2256", eqcolon: "\u2255", eqsim: "\u2242", eqslantgtr: "\u2A96", eqslantless: "\u2A95", Equal: "\u2A75", equals: "=", EqualTilde: "\u2242", equest: "\u225F", Equilibrium: "\u21CC", equiv: "\u2261", equivDD: "\u2A78", eqvparsl: "\u29E5", erarr: "\u2971", erDot: "\u2253", escr: "\u212F", Escr: "\u2130", esdot: "\u2250", Esim: "\u2A73", esim: "\u2242", Eta: "\u0397", eta: "\u03B7", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", euro: "\u20AC", excl: "!", exist: "\u2203", Exists: "\u2203", expectation: "\u2130", exponentiale: "\u2147", ExponentialE: "\u2147", fallingdotseq: "\u2252", Fcy: "\u0424", fcy: "\u0444", female: "\u2640", ffilig: "\uFB03", fflig: "\uFB00", ffllig: "\uFB04", Ffr: "\u{1D509}", ffr: "\u{1D523}", filig: "\uFB01", FilledSmallSquare: "\u25FC", FilledVerySmallSquare: "\u25AA", fjlig: "fj", flat: "\u266D", fllig: "\uFB02", fltns: "\u25B1", fnof: "\u0192", Fopf: "\u{1D53D}", fopf: "\u{1D557}", forall: "\u2200", ForAll: "\u2200", fork: "\u22D4", forkv: "\u2AD9", Fouriertrf: "\u2131", fpartint: "\u2A0D", frac12: "\xBD", frac13: "\u2153", frac14: "\xBC", frac15: "\u2155", frac16: "\u2159", frac18: "\u215B", frac23: "\u2154", frac25: "\u2156", frac34: "\xBE", frac35: "\u2157", frac38: "\u215C", frac45: "\u2158", frac56: "\u215A", frac58: "\u215D", frac78: "\u215E", frasl: "\u2044", frown: "\u2322", fscr: "\u{1D4BB}", Fscr: "\u2131", gacute: "\u01F5", Gamma: "\u0393", gamma: "\u03B3", Gammad: "\u03DC", gammad: "\u03DD", gap: "\u2A86", Gbreve: "\u011E", gbreve: "\u011F", Gcedil: "\u0122", Gcirc: "\u011C", gcirc: "\u011D", Gcy: "\u0413", gcy: "\u0433", Gdot: "\u0120", gdot: "\u0121", ge: "\u2265", gE: "\u2267", gEl: "\u2A8C", gel: "\u22DB", geq: "\u2265", geqq: "\u2267", geqslant: "\u2A7E", gescc: "\u2AA9", ges: "\u2A7E", gesdot: "\u2A80", gesdoto: "\u2A82", gesdotol: "\u2A84", gesl: "\u22DB\uFE00", gesles: "\u2A94", Gfr: "\u{1D50A}", gfr: "\u{1D524}", gg: "\u226B", Gg: "\u22D9", ggg: "\u22D9", gimel: "\u2137", GJcy: "\u0403", gjcy: "\u0453", gla: "\u2AA5", gl: "\u2277", glE: "\u2A92", glj: "\u2AA4", gnap: "\u2A8A", gnapprox: "\u2A8A", gne: "\u2A88", gnE: "\u2269", gneq: "\u2A88", gneqq: "\u2269", gnsim: "\u22E7", Gopf: "\u{1D53E}", gopf: "\u{1D558}", grave: "`", GreaterEqual: "\u2265", GreaterEqualLess: "\u22DB", GreaterFullEqual: "\u2267", GreaterGreater: "\u2AA2", GreaterLess: "\u2277", GreaterSlantEqual: "\u2A7E", GreaterTilde: "\u2273", Gscr: "\u{1D4A2}", gscr: "\u210A", gsim: "\u2273", gsime: "\u2A8E", gsiml: "\u2A90", gtcc: "\u2AA7", gtcir: "\u2A7A", gt: ">", GT: ">", Gt: "\u226B", gtdot: "\u22D7", gtlPar: "\u2995", gtquest: "\u2A7C", gtrapprox: "\u2A86", gtrarr: "\u2978", gtrdot: "\u22D7", gtreqless: "\u22DB", gtreqqless: "\u2A8C", gtrless: "\u2277", gtrsim: "\u2273", gvertneqq: "\u2269\uFE00", gvnE: "\u2269\uFE00", Hacek: "\u02C7", hairsp: "\u200A", half: "\xBD", hamilt: "\u210B", HARDcy: "\u042A", hardcy: "\u044A", harrcir: "\u2948", harr: "\u2194", hArr: "\u21D4", harrw: "\u21AD", Hat: "^", hbar: "\u210F", Hcirc: "\u0124", hcirc: "\u0125", hearts: "\u2665", heartsuit: "\u2665", hellip: "\u2026", hercon: "\u22B9", hfr: "\u{1D525}", Hfr: "\u210C", HilbertSpace: "\u210B", hksearow: "\u2925", hkswarow: "\u2926", hoarr: "\u21FF", homtht: "\u223B", hookleftarrow: "\u21A9", hookrightarrow: "\u21AA", hopf: "\u{1D559}", Hopf: "\u210D", horbar: "\u2015", HorizontalLine: "\u2500", hscr: "\u{1D4BD}", Hscr: "\u210B", hslash: "\u210F", Hstrok: "\u0126", hstrok: "\u0127", HumpDownHump: "\u224E", HumpEqual: "\u224F", hybull: "\u2043", hyphen: "\u2010", Iacute: "\xCD", iacute: "\xED", ic: "\u2063", Icirc: "\xCE", icirc: "\xEE", Icy: "\u0418", icy: "\u0438", Idot: "\u0130", IEcy: "\u0415", iecy: "\u0435", iexcl: "\xA1", iff: "\u21D4", ifr: "\u{1D526}", Ifr: "\u2111", Igrave: "\xCC", igrave: "\xEC", ii: "\u2148", iiiint: "\u2A0C", iiint: "\u222D", iinfin: "\u29DC", iiota: "\u2129", IJlig: "\u0132", ijlig: "\u0133", Imacr: "\u012A", imacr: "\u012B", image: "\u2111", ImaginaryI: "\u2148", imagline: "\u2110", imagpart: "\u2111", imath: "\u0131", Im: "\u2111", imof: "\u22B7", imped: "\u01B5", Implies: "\u21D2", incare: "\u2105", in: "\u2208", infin: "\u221E", infintie: "\u29DD", inodot: "\u0131", intcal: "\u22BA", int: "\u222B", Int: "\u222C", integers: "\u2124", Integral: "\u222B", intercal: "\u22BA", Intersection: "\u22C2", intlarhk: "\u2A17", intprod: "\u2A3C", InvisibleComma: "\u2063", InvisibleTimes: "\u2062", IOcy: "\u0401", iocy: "\u0451", Iogon: "\u012E", iogon: "\u012F", Iopf: "\u{1D540}", iopf: "\u{1D55A}", Iota: "\u0399", iota: "\u03B9", iprod: "\u2A3C", iquest: "\xBF", iscr: "\u{1D4BE}", Iscr: "\u2110", isin: "\u2208", isindot: "\u22F5", isinE: "\u22F9", isins: "\u22F4", isinsv: "\u22F3", isinv: "\u2208", it: "\u2062", Itilde: "\u0128", itilde: "\u0129", Iukcy: "\u0406", iukcy: "\u0456", Iuml: "\xCF", iuml: "\xEF", Jcirc: "\u0134", jcirc: "\u0135", Jcy: "\u0419", jcy: "\u0439", Jfr: "\u{1D50D}", jfr: "\u{1D527}", jmath: "\u0237", Jopf: "\u{1D541}", jopf: "\u{1D55B}", Jscr: "\u{1D4A5}", jscr: "\u{1D4BF}", Jsercy: "\u0408", jsercy: "\u0458", Jukcy: "\u0404", jukcy: "\u0454", Kappa: "\u039A", kappa: "\u03BA", kappav: "\u03F0", Kcedil: "\u0136", kcedil: "\u0137", Kcy: "\u041A", kcy: "\u043A", Kfr: "\u{1D50E}", kfr: "\u{1D528}", kgreen: "\u0138", KHcy: "\u0425", khcy: "\u0445", KJcy: "\u040C", kjcy: "\u045C", Kopf: "\u{1D542}", kopf: "\u{1D55C}", Kscr: "\u{1D4A6}", kscr: "\u{1D4C0}", lAarr: "\u21DA", Lacute: "\u0139", lacute: "\u013A", laemptyv: "\u29B4", lagran: "\u2112", Lambda: "\u039B", lambda: "\u03BB", lang: "\u27E8", Lang: "\u27EA", langd: "\u2991", langle: "\u27E8", lap: "\u2A85", Laplacetrf: "\u2112", laquo: "\xAB", larrb: "\u21E4", larrbfs: "\u291F", larr: "\u2190", Larr: "\u219E", lArr: "\u21D0", larrfs: "\u291D", larrhk: "\u21A9", larrlp: "\u21AB", larrpl: "\u2939", larrsim: "\u2973", larrtl: "\u21A2", latail: "\u2919", lAtail: "\u291B", lat: "\u2AAB", late: "\u2AAD", lates: "\u2AAD\uFE00", lbarr: "\u290C", lBarr: "\u290E", lbbrk: "\u2772", lbrace: "{", lbrack: "[", lbrke: "\u298B", lbrksld: "\u298F", lbrkslu: "\u298D", Lcaron: "\u013D", lcaron: "\u013E", Lcedil: "\u013B", lcedil: "\u013C", lceil: "\u2308", lcub: "{", Lcy: "\u041B", lcy: "\u043B", ldca: "\u2936", ldquo: "\u201C", ldquor: "\u201E", ldrdhar: "\u2967", ldrushar: "\u294B", ldsh: "\u21B2", le: "\u2264", lE: "\u2266", LeftAngleBracket: "\u27E8", LeftArrowBar: "\u21E4", leftarrow: "\u2190", LeftArrow: "\u2190", Leftarrow: "\u21D0", LeftArrowRightArrow: "\u21C6", leftarrowtail: "\u21A2", LeftCeiling: "\u2308", LeftDoubleBracket: "\u27E6", LeftDownTeeVector: "\u2961", LeftDownVectorBar: "\u2959", LeftDownVector: "\u21C3", LeftFloor: "\u230A", leftharpoondown: "\u21BD", leftharpoonup: "\u21BC", leftleftarrows: "\u21C7", leftrightarrow: "\u2194", LeftRightArrow: "\u2194", Leftrightarrow: "\u21D4", leftrightarrows: "\u21C6", leftrightharpoons: "\u21CB", leftrightsquigarrow: "\u21AD", LeftRightVector: "\u294E", LeftTeeArrow: "\u21A4", LeftTee: "\u22A3", LeftTeeVector: "\u295A", leftthreetimes: "\u22CB", LeftTriangleBar: "\u29CF", LeftTriangle: "\u22B2", LeftTriangleEqual: "\u22B4", LeftUpDownVector: "\u2951", LeftUpTeeVector: "\u2960", LeftUpVectorBar: "\u2958", LeftUpVector: "\u21BF", LeftVectorBar: "\u2952", LeftVector: "\u21BC", lEg: "\u2A8B", leg: "\u22DA", leq: "\u2264", leqq: "\u2266", leqslant: "\u2A7D", lescc: "\u2AA8", les: "\u2A7D", lesdot: "\u2A7F", lesdoto: "\u2A81", lesdotor: "\u2A83", lesg: "\u22DA\uFE00", lesges: "\u2A93", lessapprox: "\u2A85", lessdot: "\u22D6", lesseqgtr: "\u22DA", lesseqqgtr: "\u2A8B", LessEqualGreater: "\u22DA", LessFullEqual: "\u2266", LessGreater: "\u2276", lessgtr: "\u2276", LessLess: "\u2AA1", lesssim: "\u2272", LessSlantEqual: "\u2A7D", LessTilde: "\u2272", lfisht: "\u297C", lfloor: "\u230A", Lfr: "\u{1D50F}", lfr: "\u{1D529}", lg: "\u2276", lgE: "\u2A91", lHar: "\u2962", lhard: "\u21BD", lharu: "\u21BC", lharul: "\u296A", lhblk: "\u2584", LJcy: "\u0409", ljcy: "\u0459", llarr: "\u21C7", ll: "\u226A", Ll: "\u22D8", llcorner: "\u231E", Lleftarrow: "\u21DA", llhard: "\u296B", lltri: "\u25FA", Lmidot: "\u013F", lmidot: "\u0140", lmoustache: "\u23B0", lmoust: "\u23B0", lnap: "\u2A89", lnapprox: "\u2A89", lne: "\u2A87", lnE: "\u2268", lneq: "\u2A87", lneqq: "\u2268", lnsim: "\u22E6", loang: "\u27EC", loarr: "\u21FD", lobrk: "\u27E6", longleftarrow: "\u27F5", LongLeftArrow: "\u27F5", Longleftarrow: "\u27F8", longleftrightarrow: "\u27F7", LongLeftRightArrow: "\u27F7", Longleftrightarrow: "\u27FA", longmapsto: "\u27FC", longrightarrow: "\u27F6", LongRightArrow: "\u27F6", Longrightarrow: "\u27F9", looparrowleft: "\u21AB", looparrowright: "\u21AC", lopar: "\u2985", Lopf: "\u{1D543}", lopf: "\u{1D55D}", loplus: "\u2A2D", lotimes: "\u2A34", lowast: "\u2217", lowbar: "_", LowerLeftArrow: "\u2199", LowerRightArrow: "\u2198", loz: "\u25CA", lozenge: "\u25CA", lozf: "\u29EB", lpar: "(", lparlt: "\u2993", lrarr: "\u21C6", lrcorner: "\u231F", lrhar: "\u21CB", lrhard: "\u296D", lrm: "\u200E", lrtri: "\u22BF", lsaquo: "\u2039", lscr: "\u{1D4C1}", Lscr: "\u2112", lsh: "\u21B0", Lsh: "\u21B0", lsim: "\u2272", lsime: "\u2A8D", lsimg: "\u2A8F", lsqb: "[", lsquo: "\u2018", lsquor: "\u201A", Lstrok: "\u0141", lstrok: "\u0142", ltcc: "\u2AA6", ltcir: "\u2A79", lt: "<", LT: "<", Lt: "\u226A", ltdot: "\u22D6", lthree: "\u22CB", ltimes: "\u22C9", ltlarr: "\u2976", ltquest: "\u2A7B", ltri: "\u25C3", ltrie: "\u22B4", ltrif: "\u25C2", ltrPar: "\u2996", lurdshar: "\u294A", luruhar: "\u2966", lvertneqq: "\u2268\uFE00", lvnE: "\u2268\uFE00", macr: "\xAF", male: "\u2642", malt: "\u2720", maltese: "\u2720", Map: "\u2905", map: "\u21A6", mapsto: "\u21A6", mapstodown: "\u21A7", mapstoleft: "\u21A4", mapstoup: "\u21A5", marker: "\u25AE", mcomma: "\u2A29", Mcy: "\u041C", mcy: "\u043C", mdash: "\u2014", mDDot: "\u223A", measuredangle: "\u2221", MediumSpace: "\u205F", Mellintrf: "\u2133", Mfr: "\u{1D510}", mfr: "\u{1D52A}", mho: "\u2127", micro: "\xB5", midast: "*", midcir: "\u2AF0", mid: "\u2223", middot: "\xB7", minusb: "\u229F", minus: "\u2212", minusd: "\u2238", minusdu: "\u2A2A", MinusPlus: "\u2213", mlcp: "\u2ADB", mldr: "\u2026", mnplus: "\u2213", models: "\u22A7", Mopf: "\u{1D544}", mopf: "\u{1D55E}", mp: "\u2213", mscr: "\u{1D4C2}", Mscr: "\u2133", mstpos: "\u223E", Mu: "\u039C", mu: "\u03BC", multimap: "\u22B8", mumap: "\u22B8", nabla: "\u2207", Nacute: "\u0143", nacute: "\u0144", nang: "\u2220\u20D2", nap: "\u2249", napE: "\u2A70\u0338", napid: "\u224B\u0338", napos: "\u0149", napprox: "\u2249", natural: "\u266E", naturals: "\u2115", natur: "\u266E", nbsp: "\xA0", nbump: "\u224E\u0338", nbumpe: "\u224F\u0338", ncap: "\u2A43", Ncaron: "\u0147", ncaron: "\u0148", Ncedil: "\u0145", ncedil: "\u0146", ncong: "\u2247", ncongdot: "\u2A6D\u0338", ncup: "\u2A42", Ncy: "\u041D", ncy: "\u043D", ndash: "\u2013", nearhk: "\u2924", nearr: "\u2197", neArr: "\u21D7", nearrow: "\u2197", ne: "\u2260", nedot: "\u2250\u0338", NegativeMediumSpace: "\u200B", NegativeThickSpace: "\u200B", NegativeThinSpace: "\u200B", NegativeVeryThinSpace: "\u200B", nequiv: "\u2262", nesear: "\u2928", nesim: "\u2242\u0338", NestedGreaterGreater: "\u226B", NestedLessLess: "\u226A", NewLine: "\n", nexist: "\u2204", nexists: "\u2204", Nfr: "\u{1D511}", nfr: "\u{1D52B}", ngE: "\u2267\u0338", nge: "\u2271", ngeq: "\u2271", ngeqq: "\u2267\u0338", ngeqslant: "\u2A7E\u0338", nges: "\u2A7E\u0338", nGg: "\u22D9\u0338", ngsim: "\u2275", nGt: "\u226B\u20D2", ngt: "\u226F", ngtr: "\u226F", nGtv: "\u226B\u0338", nharr: "\u21AE", nhArr: "\u21CE", nhpar: "\u2AF2", ni: "\u220B", nis: "\u22FC", nisd: "\u22FA", niv: "\u220B", NJcy: "\u040A", njcy: "\u045A", nlarr: "\u219A", nlArr: "\u21CD", nldr: "\u2025", nlE: "\u2266\u0338", nle: "\u2270", nleftarrow: "\u219A", nLeftarrow: "\u21CD", nleftrightarrow: "\u21AE", nLeftrightarrow: "\u21CE", nleq: "\u2270", nleqq: "\u2266\u0338", nleqslant: "\u2A7D\u0338", nles: "\u2A7D\u0338", nless: "\u226E", nLl: "\u22D8\u0338", nlsim: "\u2274", nLt: "\u226A\u20D2", nlt: "\u226E", nltri: "\u22EA", nltrie: "\u22EC", nLtv: "\u226A\u0338", nmid: "\u2224", NoBreak: "\u2060", NonBreakingSpace: "\xA0", nopf: "\u{1D55F}", Nopf: "\u2115", Not: "\u2AEC", not: "\xAC", NotCongruent: "\u2262", NotCupCap: "\u226D", NotDoubleVerticalBar: "\u2226", NotElement: "\u2209", NotEqual: "\u2260", NotEqualTilde: "\u2242\u0338", NotExists: "\u2204", NotGreater: "\u226F", NotGreaterEqual: "\u2271", NotGreaterFullEqual: "\u2267\u0338", NotGreaterGreater: "\u226B\u0338", NotGreaterLess: "\u2279", NotGreaterSlantEqual: "\u2A7E\u0338", NotGreaterTilde: "\u2275", NotHumpDownHump: "\u224E\u0338", NotHumpEqual: "\u224F\u0338", notin: "\u2209", notindot: "\u22F5\u0338", notinE: "\u22F9\u0338", notinva: "\u2209", notinvb: "\u22F7", notinvc: "\u22F6", NotLeftTriangleBar: "\u29CF\u0338", NotLeftTriangle: "\u22EA", NotLeftTriangleEqual: "\u22EC", NotLess: "\u226E", NotLessEqual: "\u2270", NotLessGreater: "\u2278", NotLessLess: "\u226A\u0338", NotLessSlantEqual: "\u2A7D\u0338", NotLessTilde: "\u2274", NotNestedGreaterGreater: "\u2AA2\u0338", NotNestedLessLess: "\u2AA1\u0338", notni: "\u220C", notniva: "\u220C", notnivb: "\u22FE", notnivc: "\u22FD", NotPrecedes: "\u2280", NotPrecedesEqual: "\u2AAF\u0338", NotPrecedesSlantEqual: "\u22E0", NotReverseElement: "\u220C", NotRightTriangleBar: "\u29D0\u0338", NotRightTriangle: "\u22EB", NotRightTriangleEqual: "\u22ED", NotSquareSubset: "\u228F\u0338", NotSquareSubsetEqual: "\u22E2", NotSquareSuperset: "\u2290\u0338", NotSquareSupersetEqual: "\u22E3", NotSubset: "\u2282\u20D2", NotSubsetEqual: "\u2288", NotSucceeds: "\u2281", NotSucceedsEqual: "\u2AB0\u0338", NotSucceedsSlantEqual: "\u22E1", NotSucceedsTilde: "\u227F\u0338", NotSuperset: "\u2283\u20D2", NotSupersetEqual: "\u2289", NotTilde: "\u2241", NotTildeEqual: "\u2244", NotTildeFullEqual: "\u2247", NotTildeTilde: "\u2249", NotVerticalBar: "\u2224", nparallel: "\u2226", npar: "\u2226", nparsl: "\u2AFD\u20E5", npart: "\u2202\u0338", npolint: "\u2A14", npr: "\u2280", nprcue: "\u22E0", nprec: "\u2280", npreceq: "\u2AAF\u0338", npre: "\u2AAF\u0338", nrarrc: "\u2933\u0338", nrarr: "\u219B", nrArr: "\u21CF", nrarrw: "\u219D\u0338", nrightarrow: "\u219B", nRightarrow: "\u21CF", nrtri: "\u22EB", nrtrie: "\u22ED", nsc: "\u2281", nsccue: "\u22E1", nsce: "\u2AB0\u0338", Nscr: "\u{1D4A9}", nscr: "\u{1D4C3}", nshortmid: "\u2224", nshortparallel: "\u2226", nsim: "\u2241", nsime: "\u2244", nsimeq: "\u2244", nsmid: "\u2224", nspar: "\u2226", nsqsube: "\u22E2", nsqsupe: "\u22E3", nsub: "\u2284", nsubE: "\u2AC5\u0338", nsube: "\u2288", nsubset: "\u2282\u20D2", nsubseteq: "\u2288", nsubseteqq: "\u2AC5\u0338", nsucc: "\u2281", nsucceq: "\u2AB0\u0338", nsup: "\u2285", nsupE: "\u2AC6\u0338", nsupe: "\u2289", nsupset: "\u2283\u20D2", nsupseteq: "\u2289", nsupseteqq: "\u2AC6\u0338", ntgl: "\u2279", Ntilde: "\xD1", ntilde: "\xF1", ntlg: "\u2278", ntriangleleft: "\u22EA", ntrianglelefteq: "\u22EC", ntriangleright: "\u22EB", ntrianglerighteq: "\u22ED", Nu: "\u039D", nu: "\u03BD", num: "#", numero: "\u2116", numsp: "\u2007", nvap: "\u224D\u20D2", nvdash: "\u22AC", nvDash: "\u22AD", nVdash: "\u22AE", nVDash: "\u22AF", nvge: "\u2265\u20D2", nvgt: ">\u20D2", nvHarr: "\u2904", nvinfin: "\u29DE", nvlArr: "\u2902", nvle: "\u2264\u20D2", nvlt: "<\u20D2", nvltrie: "\u22B4\u20D2", nvrArr: "\u2903", nvrtrie: "\u22B5\u20D2", nvsim: "\u223C\u20D2", nwarhk: "\u2923", nwarr: "\u2196", nwArr: "\u21D6", nwarrow: "\u2196", nwnear: "\u2927", Oacute: "\xD3", oacute: "\xF3", oast: "\u229B", Ocirc: "\xD4", ocirc: "\xF4", ocir: "\u229A", Ocy: "\u041E", ocy: "\u043E", odash: "\u229D", Odblac: "\u0150", odblac: "\u0151", odiv: "\u2A38", odot: "\u2299", odsold: "\u29BC", OElig: "\u0152", oelig: "\u0153", ofcir: "\u29BF", Ofr: "\u{1D512}", ofr: "\u{1D52C}", ogon: "\u02DB", Ograve: "\xD2", ograve: "\xF2", ogt: "\u29C1", ohbar: "\u29B5", ohm: "\u03A9", oint: "\u222E", olarr: "\u21BA", olcir: "\u29BE", olcross: "\u29BB", oline: "\u203E", olt: "\u29C0", Omacr: "\u014C", omacr: "\u014D", Omega: "\u03A9", omega: "\u03C9", Omicron: "\u039F", omicron: "\u03BF", omid: "\u29B6", ominus: "\u2296", Oopf: "\u{1D546}", oopf: "\u{1D560}", opar: "\u29B7", OpenCurlyDoubleQuote: "\u201C", OpenCurlyQuote: "\u2018", operp: "\u29B9", oplus: "\u2295", orarr: "\u21BB", Or: "\u2A54", or: "\u2228", ord: "\u2A5D", order: "\u2134", orderof: "\u2134", ordf: "\xAA", ordm: "\xBA", origof: "\u22B6", oror: "\u2A56", orslope: "\u2A57", orv: "\u2A5B", oS: "\u24C8", Oscr: "\u{1D4AA}", oscr: "\u2134", Oslash: "\xD8", oslash: "\xF8", osol: "\u2298", Otilde: "\xD5", otilde: "\xF5", otimesas: "\u2A36", Otimes: "\u2A37", otimes: "\u2297", Ouml: "\xD6", ouml: "\xF6", ovbar: "\u233D", OverBar: "\u203E", OverBrace: "\u23DE", OverBracket: "\u23B4", OverParenthesis: "\u23DC", para: "\xB6", parallel: "\u2225", par: "\u2225", parsim: "\u2AF3", parsl: "\u2AFD", part: "\u2202", PartialD: "\u2202", Pcy: "\u041F", pcy: "\u043F", percnt: "%", period: ".", permil: "\u2030", perp: "\u22A5", pertenk: "\u2031", Pfr: "\u{1D513}", pfr: "\u{1D52D}", Phi: "\u03A6", phi: "\u03C6", phiv: "\u03D5", phmmat: "\u2133", phone: "\u260E", Pi: "\u03A0", pi: "\u03C0", pitchfork: "\u22D4", piv: "\u03D6", planck: "\u210F", planckh: "\u210E", plankv: "\u210F", plusacir: "\u2A23", plusb: "\u229E", pluscir: "\u2A22", plus: "+", plusdo: "\u2214", plusdu: "\u2A25", pluse: "\u2A72", PlusMinus: "\xB1", plusmn: "\xB1", plussim: "\u2A26", plustwo: "\u2A27", pm: "\xB1", Poincareplane: "\u210C", pointint: "\u2A15", popf: "\u{1D561}", Popf: "\u2119", pound: "\xA3", prap: "\u2AB7", Pr: "\u2ABB", pr: "\u227A", prcue: "\u227C", precapprox: "\u2AB7", prec: "\u227A", preccurlyeq: "\u227C", Precedes: "\u227A", PrecedesEqual: "\u2AAF", PrecedesSlantEqual: "\u227C", PrecedesTilde: "\u227E", preceq: "\u2AAF", precnapprox: "\u2AB9", precneqq: "\u2AB5", precnsim: "\u22E8", pre: "\u2AAF", prE: "\u2AB3", precsim: "\u227E", prime: "\u2032", Prime: "\u2033", primes: "\u2119", prnap: "\u2AB9", prnE: "\u2AB5", prnsim: "\u22E8", prod: "\u220F", Product: "\u220F", profalar: "\u232E", profline: "\u2312", profsurf: "\u2313", prop: "\u221D", Proportional: "\u221D", Proportion: "\u2237", propto: "\u221D", prsim: "\u227E", prurel: "\u22B0", Pscr: "\u{1D4AB}", pscr: "\u{1D4C5}", Psi: "\u03A8", psi: "\u03C8", puncsp: "\u2008", Qfr: "\u{1D514}", qfr: "\u{1D52E}", qint: "\u2A0C", qopf: "\u{1D562}", Qopf: "\u211A", qprime: "\u2057", Qscr: "\u{1D4AC}", qscr: "\u{1D4C6}", quaternions: "\u210D", quatint: "\u2A16", quest: "?", questeq: "\u225F", quot: '"', QUOT: '"', rAarr: "\u21DB", race: "\u223D\u0331", Racute: "\u0154", racute: "\u0155", radic: "\u221A", raemptyv: "\u29B3", rang: "\u27E9", Rang: "\u27EB", rangd: "\u2992", range: "\u29A5", rangle: "\u27E9", raquo: "\xBB", rarrap: "\u2975", rarrb: "\u21E5", rarrbfs: "\u2920", rarrc: "\u2933", rarr: "\u2192", Rarr: "\u21A0", rArr: "\u21D2", rarrfs: "\u291E", rarrhk: "\u21AA", rarrlp: "\u21AC", rarrpl: "\u2945", rarrsim: "\u2974", Rarrtl: "\u2916", rarrtl: "\u21A3", rarrw: "\u219D", ratail: "\u291A", rAtail: "\u291C", ratio: "\u2236", rationals: "\u211A", rbarr: "\u290D", rBarr: "\u290F", RBarr: "\u2910", rbbrk: "\u2773", rbrace: "}", rbrack: "]", rbrke: "\u298C", rbrksld: "\u298E", rbrkslu: "\u2990", Rcaron: "\u0158", rcaron: "\u0159", Rcedil: "\u0156", rcedil: "\u0157", rceil: "\u2309", rcub: "}", Rcy: "\u0420", rcy: "\u0440", rdca: "\u2937", rdldhar: "\u2969", rdquo: "\u201D", rdquor: "\u201D", rdsh: "\u21B3", real: "\u211C", realine: "\u211B", realpart: "\u211C", reals: "\u211D", Re: "\u211C", rect: "\u25AD", reg: "\xAE", REG: "\xAE", ReverseElement: "\u220B", ReverseEquilibrium: "\u21CB", ReverseUpEquilibrium: "\u296F", rfisht: "\u297D", rfloor: "\u230B", rfr: "\u{1D52F}", Rfr: "\u211C", rHar: "\u2964", rhard: "\u21C1", rharu: "\u21C0", rharul: "\u296C", Rho: "\u03A1", rho: "\u03C1", rhov: "\u03F1", RightAngleBracket: "\u27E9", RightArrowBar: "\u21E5", rightarrow: "\u2192", RightArrow: "\u2192", Rightarrow: "\u21D2", RightArrowLeftArrow: "\u21C4", rightarrowtail: "\u21A3", RightCeiling: "\u2309", RightDoubleBracket: "\u27E7", RightDownTeeVector: "\u295D", RightDownVectorBar: "\u2955", RightDownVector: "\u21C2", RightFloor: "\u230B", rightharpoondown: "\u21C1", rightharpoonup: "\u21C0", rightleftarrows: "\u21C4", rightleftharpoons: "\u21CC", rightrightarrows: "\u21C9", rightsquigarrow: "\u219D", RightTeeArrow: "\u21A6", RightTee: "\u22A2", RightTeeVector: "\u295B", rightthreetimes: "\u22CC", RightTriangleBar: "\u29D0", RightTriangle: "\u22B3", RightTriangleEqual: "\u22B5", RightUpDownVector: "\u294F", RightUpTeeVector: "\u295C", RightUpVectorBar: "\u2954", RightUpVector: "\u21BE", RightVectorBar: "\u2953", RightVector: "\u21C0", ring: "\u02DA", risingdotseq: "\u2253", rlarr: "\u21C4", rlhar: "\u21CC", rlm: "\u200F", rmoustache: "\u23B1", rmoust: "\u23B1", rnmid: "\u2AEE", roang: "\u27ED", roarr: "\u21FE", robrk: "\u27E7", ropar: "\u2986", ropf: "\u{1D563}", Ropf: "\u211D", roplus: "\u2A2E", rotimes: "\u2A35", RoundImplies: "\u2970", rpar: ")", rpargt: "\u2994", rppolint: "\u2A12", rrarr: "\u21C9", Rrightarrow: "\u21DB", rsaquo: "\u203A", rscr: "\u{1D4C7}", Rscr: "\u211B", rsh: "\u21B1", Rsh: "\u21B1", rsqb: "]", rsquo: "\u2019", rsquor: "\u2019", rthree: "\u22CC", rtimes: "\u22CA", rtri: "\u25B9", rtrie: "\u22B5", rtrif: "\u25B8", rtriltri: "\u29CE", RuleDelayed: "\u29F4", ruluhar: "\u2968", rx: "\u211E", Sacute: "\u015A", sacute: "\u015B", sbquo: "\u201A", scap: "\u2AB8", Scaron: "\u0160", scaron: "\u0161", Sc: "\u2ABC", sc: "\u227B", sccue: "\u227D", sce: "\u2AB0", scE: "\u2AB4", Scedil: "\u015E", scedil: "\u015F", Scirc: "\u015C", scirc: "\u015D", scnap: "\u2ABA", scnE: "\u2AB6", scnsim: "\u22E9", scpolint: "\u2A13", scsim: "\u227F", Scy: "\u0421", scy: "\u0441", sdotb: "\u22A1", sdot: "\u22C5", sdote: "\u2A66", searhk: "\u2925", searr: "\u2198", seArr: "\u21D8", searrow: "\u2198", sect: "\xA7", semi: ";", seswar: "\u2929", setminus: "\u2216", setmn: "\u2216", sext: "\u2736", Sfr: "\u{1D516}", sfr: "\u{1D530}", sfrown: "\u2322", sharp: "\u266F", SHCHcy: "\u0429", shchcy: "\u0449", SHcy: "\u0428", shcy: "\u0448", ShortDownArrow: "\u2193", ShortLeftArrow: "\u2190", shortmid: "\u2223", shortparallel: "\u2225", ShortRightArrow: "\u2192", ShortUpArrow: "\u2191", shy: "\xAD", Sigma: "\u03A3", sigma: "\u03C3", sigmaf: "\u03C2", sigmav: "\u03C2", sim: "\u223C", simdot: "\u2A6A", sime: "\u2243", simeq: "\u2243", simg: "\u2A9E", simgE: "\u2AA0", siml: "\u2A9D", simlE: "\u2A9F", simne: "\u2246", simplus: "\u2A24", simrarr: "\u2972", slarr: "\u2190", SmallCircle: "\u2218", smallsetminus: "\u2216", smashp: "\u2A33", smeparsl: "\u29E4", smid: "\u2223", smile: "\u2323", smt: "\u2AAA", smte: "\u2AAC", smtes: "\u2AAC\uFE00", SOFTcy: "\u042C", softcy: "\u044C", solbar: "\u233F", solb: "\u29C4", sol: "/", Sopf: "\u{1D54A}", sopf: "\u{1D564}", spades: "\u2660", spadesuit: "\u2660", spar: "\u2225", sqcap: "\u2293", sqcaps: "\u2293\uFE00", sqcup: "\u2294", sqcups: "\u2294\uFE00", Sqrt: "\u221A", sqsub: "\u228F", sqsube: "\u2291", sqsubset: "\u228F", sqsubseteq: "\u2291", sqsup: "\u2290", sqsupe: "\u2292", sqsupset: "\u2290", sqsupseteq: "\u2292", square: "\u25A1", Square: "\u25A1", SquareIntersection: "\u2293", SquareSubset: "\u228F", SquareSubsetEqual: "\u2291", SquareSuperset: "\u2290", SquareSupersetEqual: "\u2292", SquareUnion: "\u2294", squarf: "\u25AA", squ: "\u25A1", squf: "\u25AA", srarr: "\u2192", Sscr: "\u{1D4AE}", sscr: "\u{1D4C8}", ssetmn: "\u2216", ssmile: "\u2323", sstarf: "\u22C6", Star: "\u22C6", star: "\u2606", starf: "\u2605", straightepsilon: "\u03F5", straightphi: "\u03D5", strns: "\xAF", sub: "\u2282", Sub: "\u22D0", subdot: "\u2ABD", subE: "\u2AC5", sube: "\u2286", subedot: "\u2AC3", submult: "\u2AC1", subnE: "\u2ACB", subne: "\u228A", subplus: "\u2ABF", subrarr: "\u2979", subset: "\u2282", Subset: "\u22D0", subseteq: "\u2286", subseteqq: "\u2AC5", SubsetEqual: "\u2286", subsetneq: "\u228A", subsetneqq: "\u2ACB", subsim: "\u2AC7", subsub: "\u2AD5", subsup: "\u2AD3", succapprox: "\u2AB8", succ: "\u227B", succcurlyeq: "\u227D", Succeeds: "\u227B", SucceedsEqual: "\u2AB0", SucceedsSlantEqual: "\u227D", SucceedsTilde: "\u227F", succeq: "\u2AB0", succnapprox: "\u2ABA", succneqq: "\u2AB6", succnsim: "\u22E9", succsim: "\u227F", SuchThat: "\u220B", sum: "\u2211", Sum: "\u2211", sung: "\u266A", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", sup: "\u2283", Sup: "\u22D1", supdot: "\u2ABE", supdsub: "\u2AD8", supE: "\u2AC6", supe: "\u2287", supedot: "\u2AC4", Superset: "\u2283", SupersetEqual: "\u2287", suphsol: "\u27C9", suphsub: "\u2AD7", suplarr: "\u297B", supmult: "\u2AC2", supnE: "\u2ACC", supne: "\u228B", supplus: "\u2AC0", supset: "\u2283", Supset: "\u22D1", supseteq: "\u2287", supseteqq: "\u2AC6", supsetneq: "\u228B", supsetneqq: "\u2ACC", supsim: "\u2AC8", supsub: "\u2AD4", supsup: "\u2AD6", swarhk: "\u2926", swarr: "\u2199", swArr: "\u21D9", swarrow: "\u2199", swnwar: "\u292A", szlig: "\xDF", Tab: "	", target: "\u2316", Tau: "\u03A4", tau: "\u03C4", tbrk: "\u23B4", Tcaron: "\u0164", tcaron: "\u0165", Tcedil: "\u0162", tcedil: "\u0163", Tcy: "\u0422", tcy: "\u0442", tdot: "\u20DB", telrec: "\u2315", Tfr: "\u{1D517}", tfr: "\u{1D531}", there4: "\u2234", therefore: "\u2234", Therefore: "\u2234", Theta: "\u0398", theta: "\u03B8", thetasym: "\u03D1", thetav: "\u03D1", thickapprox: "\u2248", thicksim: "\u223C", ThickSpace: "\u205F\u200A", ThinSpace: "\u2009", thinsp: "\u2009", thkap: "\u2248", thksim: "\u223C", THORN: "\xDE", thorn: "\xFE", tilde: "\u02DC", Tilde: "\u223C", TildeEqual: "\u2243", TildeFullEqual: "\u2245", TildeTilde: "\u2248", timesbar: "\u2A31", timesb: "\u22A0", times: "\xD7", timesd: "\u2A30", tint: "\u222D", toea: "\u2928", topbot: "\u2336", topcir: "\u2AF1", top: "\u22A4", Topf: "\u{1D54B}", topf: "\u{1D565}", topfork: "\u2ADA", tosa: "\u2929", tprime: "\u2034", trade: "\u2122", TRADE: "\u2122", triangle: "\u25B5", triangledown: "\u25BF", triangleleft: "\u25C3", trianglelefteq: "\u22B4", triangleq: "\u225C", triangleright: "\u25B9", trianglerighteq: "\u22B5", tridot: "\u25EC", trie: "\u225C", triminus: "\u2A3A", TripleDot: "\u20DB", triplus: "\u2A39", trisb: "\u29CD", tritime: "\u2A3B", trpezium: "\u23E2", Tscr: "\u{1D4AF}", tscr: "\u{1D4C9}", TScy: "\u0426", tscy: "\u0446", TSHcy: "\u040B", tshcy: "\u045B", Tstrok: "\u0166", tstrok: "\u0167", twixt: "\u226C", twoheadleftarrow: "\u219E", twoheadrightarrow: "\u21A0", Uacute: "\xDA", uacute: "\xFA", uarr: "\u2191", Uarr: "\u219F", uArr: "\u21D1", Uarrocir: "\u2949", Ubrcy: "\u040E", ubrcy: "\u045E", Ubreve: "\u016C", ubreve: "\u016D", Ucirc: "\xDB", ucirc: "\xFB", Ucy: "\u0423", ucy: "\u0443", udarr: "\u21C5", Udblac: "\u0170", udblac: "\u0171", udhar: "\u296E", ufisht: "\u297E", Ufr: "\u{1D518}", ufr: "\u{1D532}", Ugrave: "\xD9", ugrave: "\xF9", uHar: "\u2963", uharl: "\u21BF", uharr: "\u21BE", uhblk: "\u2580", ulcorn: "\u231C", ulcorner: "\u231C", ulcrop: "\u230F", ultri: "\u25F8", Umacr: "\u016A", umacr: "\u016B", uml: "\xA8", UnderBar: "_", UnderBrace: "\u23DF", UnderBracket: "\u23B5", UnderParenthesis: "\u23DD", Union: "\u22C3", UnionPlus: "\u228E", Uogon: "\u0172", uogon: "\u0173", Uopf: "\u{1D54C}", uopf: "\u{1D566}", UpArrowBar: "\u2912", uparrow: "\u2191", UpArrow: "\u2191", Uparrow: "\u21D1", UpArrowDownArrow: "\u21C5", updownarrow: "\u2195", UpDownArrow: "\u2195", Updownarrow: "\u21D5", UpEquilibrium: "\u296E", upharpoonleft: "\u21BF", upharpoonright: "\u21BE", uplus: "\u228E", UpperLeftArrow: "\u2196", UpperRightArrow: "\u2197", upsi: "\u03C5", Upsi: "\u03D2", upsih: "\u03D2", Upsilon: "\u03A5", upsilon: "\u03C5", UpTeeArrow: "\u21A5", UpTee: "\u22A5", upuparrows: "\u21C8", urcorn: "\u231D", urcorner: "\u231D", urcrop: "\u230E", Uring: "\u016E", uring: "\u016F", urtri: "\u25F9", Uscr: "\u{1D4B0}", uscr: "\u{1D4CA}", utdot: "\u22F0", Utilde: "\u0168", utilde: "\u0169", utri: "\u25B5", utrif: "\u25B4", uuarr: "\u21C8", Uuml: "\xDC", uuml: "\xFC", uwangle: "\u29A7", vangrt: "\u299C", varepsilon: "\u03F5", varkappa: "\u03F0", varnothing: "\u2205", varphi: "\u03D5", varpi: "\u03D6", varpropto: "\u221D", varr: "\u2195", vArr: "\u21D5", varrho: "\u03F1", varsigma: "\u03C2", varsubsetneq: "\u228A\uFE00", varsubsetneqq: "\u2ACB\uFE00", varsupsetneq: "\u228B\uFE00", varsupsetneqq: "\u2ACC\uFE00", vartheta: "\u03D1", vartriangleleft: "\u22B2", vartriangleright: "\u22B3", vBar: "\u2AE8", Vbar: "\u2AEB", vBarv: "\u2AE9", Vcy: "\u0412", vcy: "\u0432", vdash: "\u22A2", vDash: "\u22A8", Vdash: "\u22A9", VDash: "\u22AB", Vdashl: "\u2AE6", veebar: "\u22BB", vee: "\u2228", Vee: "\u22C1", veeeq: "\u225A", vellip: "\u22EE", verbar: "|", Verbar: "\u2016", vert: "|", Vert: "\u2016", VerticalBar: "\u2223", VerticalLine: "|", VerticalSeparator: "\u2758", VerticalTilde: "\u2240", VeryThinSpace: "\u200A", Vfr: "\u{1D519}", vfr: "\u{1D533}", vltri: "\u22B2", vnsub: "\u2282\u20D2", vnsup: "\u2283\u20D2", Vopf: "\u{1D54D}", vopf: "\u{1D567}", vprop: "\u221D", vrtri: "\u22B3", Vscr: "\u{1D4B1}", vscr: "\u{1D4CB}", vsubnE: "\u2ACB\uFE00", vsubne: "\u228A\uFE00", vsupnE: "\u2ACC\uFE00", vsupne: "\u228B\uFE00", Vvdash: "\u22AA", vzigzag: "\u299A", Wcirc: "\u0174", wcirc: "\u0175", wedbar: "\u2A5F", wedge: "\u2227", Wedge: "\u22C0", wedgeq: "\u2259", weierp: "\u2118", Wfr: "\u{1D51A}", wfr: "\u{1D534}", Wopf: "\u{1D54E}", wopf: "\u{1D568}", wp: "\u2118", wr: "\u2240", wreath: "\u2240", Wscr: "\u{1D4B2}", wscr: "\u{1D4CC}", xcap: "\u22C2", xcirc: "\u25EF", xcup: "\u22C3", xdtri: "\u25BD", Xfr: "\u{1D51B}", xfr: "\u{1D535}", xharr: "\u27F7", xhArr: "\u27FA", Xi: "\u039E", xi: "\u03BE", xlarr: "\u27F5", xlArr: "\u27F8", xmap: "\u27FC", xnis: "\u22FB", xodot: "\u2A00", Xopf: "\u{1D54F}", xopf: "\u{1D569}", xoplus: "\u2A01", xotime: "\u2A02", xrarr: "\u27F6", xrArr: "\u27F9", Xscr: "\u{1D4B3}", xscr: "\u{1D4CD}", xsqcup: "\u2A06", xuplus: "\u2A04", xutri: "\u25B3", xvee: "\u22C1", xwedge: "\u22C0", Yacute: "\xDD", yacute: "\xFD", YAcy: "\u042F", yacy: "\u044F", Ycirc: "\u0176", ycirc: "\u0177", Ycy: "\u042B", ycy: "\u044B", yen: "\xA5", Yfr: "\u{1D51C}", yfr: "\u{1D536}", YIcy: "\u0407", yicy: "\u0457", Yopf: "\u{1D550}", yopf: "\u{1D56A}", Yscr: "\u{1D4B4}", yscr: "\u{1D4CE}", YUcy: "\u042E", yucy: "\u044E", yuml: "\xFF", Yuml: "\u0178", Zacute: "\u0179", zacute: "\u017A", Zcaron: "\u017D", zcaron: "\u017E", Zcy: "\u0417", zcy: "\u0437", Zdot: "\u017B", zdot: "\u017C", zeetrf: "\u2128", ZeroWidthSpace: "\u200B", Zeta: "\u0396", zeta: "\u03B6", zfr: "\u{1D537}", Zfr: "\u2128", ZHcy: "\u0416", zhcy: "\u0436", zigrarr: "\u21DD", zopf: "\u{1D56B}", Zopf: "\u2124", Zscr: "\u{1D4B5}", zscr: "\u{1D4CF}", zwj: "\u200D", zwnj: "\u200C" };
  }
});

// node_modules/entities/lib/maps/legacy.json
var require_legacy = __commonJS({
  "node_modules/entities/lib/maps/legacy.json"(exports2, module2) {
    module2.exports = { Aacute: "\xC1", aacute: "\xE1", Acirc: "\xC2", acirc: "\xE2", acute: "\xB4", AElig: "\xC6", aelig: "\xE6", Agrave: "\xC0", agrave: "\xE0", amp: "&", AMP: "&", Aring: "\xC5", aring: "\xE5", Atilde: "\xC3", atilde: "\xE3", Auml: "\xC4", auml: "\xE4", brvbar: "\xA6", Ccedil: "\xC7", ccedil: "\xE7", cedil: "\xB8", cent: "\xA2", copy: "\xA9", COPY: "\xA9", curren: "\xA4", deg: "\xB0", divide: "\xF7", Eacute: "\xC9", eacute: "\xE9", Ecirc: "\xCA", ecirc: "\xEA", Egrave: "\xC8", egrave: "\xE8", ETH: "\xD0", eth: "\xF0", Euml: "\xCB", euml: "\xEB", frac12: "\xBD", frac14: "\xBC", frac34: "\xBE", gt: ">", GT: ">", Iacute: "\xCD", iacute: "\xED", Icirc: "\xCE", icirc: "\xEE", iexcl: "\xA1", Igrave: "\xCC", igrave: "\xEC", iquest: "\xBF", Iuml: "\xCF", iuml: "\xEF", laquo: "\xAB", lt: "<", LT: "<", macr: "\xAF", micro: "\xB5", middot: "\xB7", nbsp: "\xA0", not: "\xAC", Ntilde: "\xD1", ntilde: "\xF1", Oacute: "\xD3", oacute: "\xF3", Ocirc: "\xD4", ocirc: "\xF4", Ograve: "\xD2", ograve: "\xF2", ordf: "\xAA", ordm: "\xBA", Oslash: "\xD8", oslash: "\xF8", Otilde: "\xD5", otilde: "\xF5", Ouml: "\xD6", ouml: "\xF6", para: "\xB6", plusmn: "\xB1", pound: "\xA3", quot: '"', QUOT: '"', raquo: "\xBB", reg: "\xAE", REG: "\xAE", sect: "\xA7", shy: "\xAD", sup1: "\xB9", sup2: "\xB2", sup3: "\xB3", szlig: "\xDF", THORN: "\xDE", thorn: "\xFE", times: "\xD7", Uacute: "\xDA", uacute: "\xFA", Ucirc: "\xDB", ucirc: "\xFB", Ugrave: "\xD9", ugrave: "\xF9", uml: "\xA8", Uuml: "\xDC", uuml: "\xFC", Yacute: "\xDD", yacute: "\xFD", yen: "\xA5", yuml: "\xFF" };
  }
});

// node_modules/entities/lib/maps/xml.json
var require_xml = __commonJS({
  "node_modules/entities/lib/maps/xml.json"(exports2, module2) {
    module2.exports = { amp: "&", apos: "'", gt: ">", lt: "<", quot: '"' };
  }
});

// node_modules/entities/lib/maps/decode.json
var require_decode = __commonJS({
  "node_modules/entities/lib/maps/decode.json"(exports2, module2) {
    module2.exports = { "0": 65533, "128": 8364, "130": 8218, "131": 402, "132": 8222, "133": 8230, "134": 8224, "135": 8225, "136": 710, "137": 8240, "138": 352, "139": 8249, "140": 338, "142": 381, "145": 8216, "146": 8217, "147": 8220, "148": 8221, "149": 8226, "150": 8211, "151": 8212, "152": 732, "153": 8482, "154": 353, "155": 8250, "156": 339, "158": 382, "159": 376 };
  }
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var decode_json_1 = __importDefault(require_decode());
    var fromCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.fromCodePoint || function(codePoint) {
        var output = "";
        if (codePoint > 65535) {
          codePoint -= 65536;
          output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
          codePoint = 56320 | codePoint & 1023;
        }
        output += String.fromCharCode(codePoint);
        return output;
      }
    );
    function decodeCodePoint(codePoint) {
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return "\uFFFD";
      }
      if (codePoint in decode_json_1.default) {
        codePoint = decode_json_1.default[codePoint];
      }
      return fromCodePoint(codePoint);
    }
    exports2.default = decodeCodePoint;
  }
});

// node_modules/entities/lib/decode.js
var require_decode2 = __commonJS({
  "node_modules/entities/lib/decode.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeHTML = exports2.decodeHTMLStrict = exports2.decodeXML = void 0;
    var entities_json_1 = __importDefault(require_entities());
    var legacy_json_1 = __importDefault(require_legacy());
    var xml_json_1 = __importDefault(require_xml());
    var decode_codepoint_1 = __importDefault(require_decode_codepoint());
    var strictEntityRe = /&(?:[a-zA-Z0-9]+|#[xX][\da-fA-F]+|#\d+);/g;
    exports2.decodeXML = getStrictDecoder(xml_json_1.default);
    exports2.decodeHTMLStrict = getStrictDecoder(entities_json_1.default);
    function getStrictDecoder(map) {
      var replace = getReplacer(map);
      return function(str) {
        return String(str).replace(strictEntityRe, replace);
      };
    }
    var sorter = function(a, b) {
      return a < b ? 1 : -1;
    };
    exports2.decodeHTML = function() {
      var legacy = Object.keys(legacy_json_1.default).sort(sorter);
      var keys = Object.keys(entities_json_1.default).sort(sorter);
      for (var i = 0, j = 0; i < keys.length; i++) {
        if (legacy[j] === keys[i]) {
          keys[i] += ";?";
          j++;
        } else {
          keys[i] += ";";
        }
      }
      var re = new RegExp("&(?:" + keys.join("|") + "|#[xX][\\da-fA-F]+;?|#\\d+;?)", "g");
      var replace = getReplacer(entities_json_1.default);
      function replacer(str) {
        if (str.substr(-1) !== ";")
          str += ";";
        return replace(str);
      }
      return function(str) {
        return String(str).replace(re, replacer);
      };
    }();
    function getReplacer(map) {
      return function replace(str) {
        if (str.charAt(1) === "#") {
          var secondChar = str.charAt(2);
          if (secondChar === "X" || secondChar === "x") {
            return decode_codepoint_1.default(parseInt(str.substr(3), 16));
          }
          return decode_codepoint_1.default(parseInt(str.substr(2), 10));
        }
        return map[str.slice(1, -1)] || str;
      };
    }
  }
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escapeUTF8 = exports2.escape = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.encodeXML = void 0;
    var xml_json_1 = __importDefault(require_xml());
    var inverseXML = getInverseObj(xml_json_1.default);
    var xmlReplacer = getInverseReplacer(inverseXML);
    exports2.encodeXML = getASCIIEncoder(inverseXML);
    var entities_json_1 = __importDefault(require_entities());
    var inverseHTML = getInverseObj(entities_json_1.default);
    var htmlReplacer = getInverseReplacer(inverseHTML);
    exports2.encodeHTML = getInverse(inverseHTML, htmlReplacer);
    exports2.encodeNonAsciiHTML = getASCIIEncoder(inverseHTML);
    function getInverseObj(obj) {
      return Object.keys(obj).sort().reduce(function(inverse, name) {
        inverse[obj[name]] = "&" + name + ";";
        return inverse;
      }, {});
    }
    function getInverseReplacer(inverse) {
      var single = [];
      var multiple = [];
      for (var _i = 0, _a = Object.keys(inverse); _i < _a.length; _i++) {
        var k = _a[_i];
        if (k.length === 1) {
          single.push("\\" + k);
        } else {
          multiple.push(k);
        }
      }
      single.sort();
      for (var start = 0; start < single.length - 1; start++) {
        var end = start;
        while (end < single.length - 1 && single[end].charCodeAt(1) + 1 === single[end + 1].charCodeAt(1)) {
          end += 1;
        }
        var count = 1 + end - start;
        if (count < 3)
          continue;
        single.splice(start, count, single[start] + "-" + single[end]);
      }
      multiple.unshift("[" + single.join("") + "]");
      return new RegExp(multiple.join("|"), "g");
    }
    var reNonASCII = /(?:[\x80-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])/g;
    var getCodePoint = (
      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
      String.prototype.codePointAt != null ? (
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        function(str) {
          return str.codePointAt(0);
        }
      ) : (
        // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
        function(c) {
          return (c.charCodeAt(0) - 55296) * 1024 + c.charCodeAt(1) - 56320 + 65536;
        }
      )
    );
    function singleCharReplacer(c) {
      return "&#x" + (c.length > 1 ? getCodePoint(c) : c.charCodeAt(0)).toString(16).toUpperCase() + ";";
    }
    function getInverse(inverse, re) {
      return function(data) {
        return data.replace(re, function(name) {
          return inverse[name];
        }).replace(reNonASCII, singleCharReplacer);
      };
    }
    var reEscapeChars = new RegExp(xmlReplacer.source + "|" + reNonASCII.source, "g");
    function escape(data) {
      return data.replace(reEscapeChars, singleCharReplacer);
    }
    exports2.escape = escape;
    function escapeUTF8(data) {
      return data.replace(xmlReplacer, singleCharReplacer);
    }
    exports2.escapeUTF8 = escapeUTF8;
    function getASCIIEncoder(obj) {
      return function(data) {
        return data.replace(reEscapeChars, function(c) {
          return obj[c] || singleCharReplacer(c);
        });
      };
    }
  }
});

// node_modules/entities/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/entities/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.escapeUTF8 = exports2.escape = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = void 0;
    var decode_1 = require_decode2();
    var encode_1 = require_encode();
    function decode(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTML)(data);
    }
    exports2.decode = decode;
    function decodeStrict(data, level) {
      return (!level || level <= 0 ? decode_1.decodeXML : decode_1.decodeHTMLStrict)(data);
    }
    exports2.decodeStrict = decodeStrict;
    function encode(data, level) {
      return (!level || level <= 0 ? encode_1.encodeXML : encode_1.encodeHTML)(data);
    }
    exports2.encode = encode;
    var encode_2 = require_encode();
    Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
      return encode_2.encodeXML;
    } });
    Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return encode_2.escape;
    } });
    Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
      return encode_2.escapeUTF8;
    } });
    Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
      return encode_2.encodeHTML;
    } });
    var decode_2 = require_decode2();
    Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
    Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
      return decode_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_2.decodeXML;
    } });
  }
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attributeNames = exports2.elementNames = void 0;
    exports2.elementNames = /* @__PURE__ */ new Map([
      ["altglyph", "altGlyph"],
      ["altglyphdef", "altGlyphDef"],
      ["altglyphitem", "altGlyphItem"],
      ["animatecolor", "animateColor"],
      ["animatemotion", "animateMotion"],
      ["animatetransform", "animateTransform"],
      ["clippath", "clipPath"],
      ["feblend", "feBlend"],
      ["fecolormatrix", "feColorMatrix"],
      ["fecomponenttransfer", "feComponentTransfer"],
      ["fecomposite", "feComposite"],
      ["feconvolvematrix", "feConvolveMatrix"],
      ["fediffuselighting", "feDiffuseLighting"],
      ["fedisplacementmap", "feDisplacementMap"],
      ["fedistantlight", "feDistantLight"],
      ["fedropshadow", "feDropShadow"],
      ["feflood", "feFlood"],
      ["fefunca", "feFuncA"],
      ["fefuncb", "feFuncB"],
      ["fefuncg", "feFuncG"],
      ["fefuncr", "feFuncR"],
      ["fegaussianblur", "feGaussianBlur"],
      ["feimage", "feImage"],
      ["femerge", "feMerge"],
      ["femergenode", "feMergeNode"],
      ["femorphology", "feMorphology"],
      ["feoffset", "feOffset"],
      ["fepointlight", "fePointLight"],
      ["fespecularlighting", "feSpecularLighting"],
      ["fespotlight", "feSpotLight"],
      ["fetile", "feTile"],
      ["feturbulence", "feTurbulence"],
      ["foreignobject", "foreignObject"],
      ["glyphref", "glyphRef"],
      ["lineargradient", "linearGradient"],
      ["radialgradient", "radialGradient"],
      ["textpath", "textPath"]
    ]);
    exports2.attributeNames = /* @__PURE__ */ new Map([
      ["definitionurl", "definitionURL"],
      ["attributename", "attributeName"],
      ["attributetype", "attributeType"],
      ["basefrequency", "baseFrequency"],
      ["baseprofile", "baseProfile"],
      ["calcmode", "calcMode"],
      ["clippathunits", "clipPathUnits"],
      ["diffuseconstant", "diffuseConstant"],
      ["edgemode", "edgeMode"],
      ["filterunits", "filterUnits"],
      ["glyphref", "glyphRef"],
      ["gradienttransform", "gradientTransform"],
      ["gradientunits", "gradientUnits"],
      ["kernelmatrix", "kernelMatrix"],
      ["kernelunitlength", "kernelUnitLength"],
      ["keypoints", "keyPoints"],
      ["keysplines", "keySplines"],
      ["keytimes", "keyTimes"],
      ["lengthadjust", "lengthAdjust"],
      ["limitingconeangle", "limitingConeAngle"],
      ["markerheight", "markerHeight"],
      ["markerunits", "markerUnits"],
      ["markerwidth", "markerWidth"],
      ["maskcontentunits", "maskContentUnits"],
      ["maskunits", "maskUnits"],
      ["numoctaves", "numOctaves"],
      ["pathlength", "pathLength"],
      ["patterncontentunits", "patternContentUnits"],
      ["patterntransform", "patternTransform"],
      ["patternunits", "patternUnits"],
      ["pointsatx", "pointsAtX"],
      ["pointsaty", "pointsAtY"],
      ["pointsatz", "pointsAtZ"],
      ["preservealpha", "preserveAlpha"],
      ["preserveaspectratio", "preserveAspectRatio"],
      ["primitiveunits", "primitiveUnits"],
      ["refx", "refX"],
      ["refy", "refY"],
      ["repeatcount", "repeatCount"],
      ["repeatdur", "repeatDur"],
      ["requiredextensions", "requiredExtensions"],
      ["requiredfeatures", "requiredFeatures"],
      ["specularconstant", "specularConstant"],
      ["specularexponent", "specularExponent"],
      ["spreadmethod", "spreadMethod"],
      ["startoffset", "startOffset"],
      ["stddeviation", "stdDeviation"],
      ["stitchtiles", "stitchTiles"],
      ["surfacescale", "surfaceScale"],
      ["systemlanguage", "systemLanguage"],
      ["tablevalues", "tableValues"],
      ["targetx", "targetX"],
      ["targety", "targetY"],
      ["textlength", "textLength"],
      ["viewbox", "viewBox"],
      ["viewtarget", "viewTarget"],
      ["xchannelselector", "xChannelSelector"],
      ["ychannelselector", "yChannelSelector"],
      ["zoomandpan", "zoomAndPan"]
    ]);
  }
});

// node_modules/dom-serializer/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
        }
        return t;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    var ElementType = __importStar(require_lib3());
    var entities_1 = require_lib5();
    var foreignNames_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function formatAttributes(attributes, opts) {
      if (!attributes)
        return;
      return Object.keys(attributes).map(function(key) {
        var _a, _b;
        var value = (_a = attributes[key]) !== null && _a !== void 0 ? _a : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return key + '="' + (opts.decodeEntities !== false ? entities_1.encodeXML(value) : value.replace(/"/g, "&quot;")) + '"';
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
      }
      return output;
    }
    exports2.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        case ElementType.Directive:
        case ElementType.Doctype:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<" + elem.name;
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " " + attribs;
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</" + elem.name + ">";
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<" + elem.data + ">";
    }
    function renderText(elem, opts) {
      var data = elem.data || "";
      if (opts.decodeEntities !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = entities_1.encodeXML(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[" + elem.children[0].data + "]]>";
    }
    function renderComment(elem) {
      return "<!--" + elem.data + "-->";
    }
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.innerText = exports2.textContent = exports2.getText = exports2.getInnerHTML = exports2.getOuterHTML = void 0;
    var domhandler_1 = require_lib4();
    var dom_serializer_1 = __importDefault(require_lib6());
    var domelementtype_1 = require_lib3();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    exports2.getOuterHTML = getOuterHTML;
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    exports2.getInnerHTML = getInnerHTML;
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.getText = getText;
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.textContent = textContent;
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    exports2.innerText = innerText;
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prevElementSibling = exports2.nextElementSibling = exports2.getName = exports2.hasAttrib = exports2.getAttributeValue = exports2.getSiblings = exports2.getParent = exports2.getChildren = void 0;
    var domhandler_1 = require_lib4();
    var emptyArray = [];
    function getChildren(elem) {
      var _a;
      return (_a = elem.children) !== null && _a !== void 0 ? _a : emptyArray;
    }
    exports2.getChildren = getChildren;
    function getParent(elem) {
      return elem.parent || null;
    }
    exports2.getParent = getParent;
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    exports2.getSiblings = getSiblings;
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    exports2.getAttributeValue = getAttributeValue;
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    exports2.hasAttrib = hasAttrib;
    function getName(elem) {
      return elem.name;
    }
    exports2.getName = getName;
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    exports2.nextElementSibling = nextElementSibling;
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
    exports2.prevElementSibling = prevElementSibling;
  }
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.prepend = exports2.prependChild = exports2.append = exports2.appendChild = exports2.replaceElement = exports2.removeElement = void 0;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        childs.splice(childs.lastIndexOf(elem), 1);
      }
    }
    exports2.removeElement = removeElement;
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
      }
    }
    exports2.replaceElement = replaceElement;
    function appendChild(elem, child) {
      removeElement(child);
      child.next = null;
      child.parent = elem;
      if (elem.children.push(child) > 1) {
        var sibling = elem.children[elem.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    exports2.appendChild = appendChild;
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    exports2.append = append;
    function prependChild(elem, child) {
      removeElement(child);
      child.parent = elem;
      child.prev = null;
      if (elem.children.unshift(child) !== 1) {
        var sibling = elem.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    exports2.prependChild = prependChild;
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
    exports2.prepend = prepend;
  }
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.findAll = exports2.existsOne = exports2.findOne = exports2.findOneChild = exports2.find = exports2.filter = void 0;
    var domhandler_1 = require_lib4();
    function filter(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      if (!Array.isArray(node))
        node = [node];
      return find(test, node, recurse, limit);
    }
    exports2.filter = filter;
    function find(test, nodes, recurse, limit) {
      var result = [];
      for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
        var elem = nodes_1[_i];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            break;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          var children = find(test, elem.children, recurse, limit);
          result.push.apply(result, children);
          limit -= children.length;
          if (limit <= 0)
            break;
        }
      }
      return result;
    }
    exports2.find = find;
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    exports2.findOneChild = findOneChild;
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var elem = null;
      for (var i = 0; i < nodes.length && !elem; i++) {
        var checked = nodes[i];
        if (!(0, domhandler_1.isTag)(checked)) {
          continue;
        } else if (test(checked)) {
          elem = checked;
        } else if (recurse && checked.children.length > 0) {
          elem = findOne(test, checked.children);
        }
      }
      return elem;
    }
    exports2.findOne = findOne;
    function existsOne(test, nodes) {
      return nodes.some(function(checked) {
        return (0, domhandler_1.isTag)(checked) && (test(checked) || checked.children.length > 0 && existsOne(test, checked.children));
      });
    }
    exports2.existsOne = existsOne;
    function findAll(test, nodes) {
      var _a;
      var result = [];
      var stack = nodes.filter(domhandler_1.isTag);
      var elem;
      while (elem = stack.shift()) {
        var children = (_a = elem.children) === null || _a === void 0 ? void 0 : _a.filter(domhandler_1.isTag);
        if (children && children.length > 0) {
          stack.unshift.apply(stack, children);
        }
        if (test(elem))
          result.push(elem);
      }
      return result;
    }
    exports2.findAll = findAll;
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy2 = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getElementsByTagType = exports2.getElementsByTagName = exports2.getElementById = exports2.getElements = exports2.testElement = void 0;
    var domhandler_1 = require_lib4();
    var querying_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    exports2.testElement = testElement;
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_1.filter)(test, nodes, recurse, limit) : [];
    }
    exports2.getElements = getElements;
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    exports2.getElementById = getElementById;
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_name(tagName), nodes, recurse, limit);
    }
    exports2.getElementsByTagName = getElementsByTagName;
    function getElementsByTagType(type, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_1.filter)(Checks.tag_type(type), nodes, recurse, limit);
    }
    exports2.getElementsByTagType = getElementsByTagType;
  }
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.uniqueSort = exports2.compareDocumentPosition = exports2.removeSubsets = void 0;
    var domhandler_1 = require_lib4();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    exports2.removeSubsets = removeSubsets;
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return 1;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return 4 | 16;
        }
        return 4;
      }
      if (sharedParent === nodeA) {
        return 2 | 8;
      }
      return 2;
    }
    exports2.compareDocumentPosition = compareDocumentPosition;
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i, arr) {
        return !arr.includes(node, i + 1);
      });
      nodes.sort(function(a, b) {
        var relative = compareDocumentPosition(a, b);
        if (relative & 2) {
          return -1;
        } else if (relative & 4) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
    exports2.uniqueSort = uniqueSort;
  }
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFeed = void 0;
    var stringify_1 = require_stringify();
    var legacy_1 = require_legacy2();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    exports2.getFeed = getFeed;
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs.href;
          if (href2) {
            entry.link = href2;
          }
          var description = fetch("summary", children) || fetch("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs.href;
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch("pubDate", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs.medium,
          isDefault: !!attribs.isDefault
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs.expression) {
          media.expression = attribs.expression;
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_1.textContent)((0, legacy_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// node_modules/domutils/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() {
        return m[k];
      } });
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
    __exportStar(require_stringify(), exports2);
    __exportStar(require_traversal(), exports2);
    __exportStar(require_manipulation(), exports2);
    __exportStar(require_querying(), exports2);
    __exportStar(require_legacy2(), exports2);
    __exportStar(require_helpers(), exports2);
    __exportStar(require_feeds(), exports2);
    var domhandler_1 = require_lib4();
    Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports2, module2) {
    module2.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/css-what/lib/commonjs/types.js
var require_types = __commonJS({
  "node_modules/css-what/lib/commonjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeAction = exports2.IgnoreCaseMode = exports2.SelectorType = void 0;
    var SelectorType;
    (function(SelectorType2) {
      SelectorType2["Attribute"] = "attribute";
      SelectorType2["Pseudo"] = "pseudo";
      SelectorType2["PseudoElement"] = "pseudo-element";
      SelectorType2["Tag"] = "tag";
      SelectorType2["Universal"] = "universal";
      SelectorType2["Adjacent"] = "adjacent";
      SelectorType2["Child"] = "child";
      SelectorType2["Descendant"] = "descendant";
      SelectorType2["Parent"] = "parent";
      SelectorType2["Sibling"] = "sibling";
      SelectorType2["ColumnCombinator"] = "column-combinator";
    })(SelectorType = exports2.SelectorType || (exports2.SelectorType = {}));
    exports2.IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false
    };
    var AttributeAction;
    (function(AttributeAction2) {
      AttributeAction2["Any"] = "any";
      AttributeAction2["Element"] = "element";
      AttributeAction2["End"] = "end";
      AttributeAction2["Equals"] = "equals";
      AttributeAction2["Exists"] = "exists";
      AttributeAction2["Hyphen"] = "hyphen";
      AttributeAction2["Not"] = "not";
      AttributeAction2["Start"] = "start";
    })(AttributeAction = exports2.AttributeAction || (exports2.AttributeAction = {}));
  }
});

// node_modules/css-what/lib/commonjs/parse.js
var require_parse = __commonJS({
  "node_modules/css-what/lib/commonjs/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = exports2.isTraversal = void 0;
    var types_1 = require_types();
    var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    var actionTypes = /* @__PURE__ */ new Map([
      [126, types_1.AttributeAction.Element],
      [94, types_1.AttributeAction.Start],
      [36, types_1.AttributeAction.End],
      [42, types_1.AttributeAction.Any],
      [33, types_1.AttributeAction.Not],
      [124, types_1.AttributeAction.Hyphen]
    ]);
    var unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context"
    ]);
    function isTraversal(selector) {
      switch (selector.type) {
        case types_1.SelectorType.Adjacent:
        case types_1.SelectorType.Child:
        case types_1.SelectorType.Descendant:
        case types_1.SelectorType.Parent:
        case types_1.SelectorType.Sibling:
        case types_1.SelectorType.ColumnCombinator:
          return true;
        default:
          return false;
      }
    }
    exports2.isTraversal = isTraversal;
    var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
    function funescape(_, escaped, escapedWhitespace) {
      var high = parseInt(escaped, 16) - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? (
        // BMP codepoint
        String.fromCharCode(high + 65536)
      ) : (
        // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
      );
    }
    function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
    }
    function isQuote(c) {
      return c === 39 || c === 34;
    }
    function isWhitespace(c) {
      return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
    }
    function parse(selector) {
      var subselects = [];
      var endIndex = parseSelector(subselects, "".concat(selector), 0);
      if (endIndex < selector.length) {
        throw new Error("Unmatched selector: ".concat(selector.slice(endIndex)));
      }
      return subselects;
    }
    exports2.parse = parse;
    function parseSelector(subselects, selector, selectorIndex) {
      var tokens = [];
      function getName(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
          throw new Error("Expected name, found ".concat(selector.slice(selectorIndex)));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
      }
      function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
          selectorIndex++;
        }
      }
      function readValueWithParenthesis() {
        selectorIndex += 1;
        var start = selectorIndex;
        var counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
          if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
            counter++;
          } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
            counter--;
          }
        }
        if (counter) {
          throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
      }
      function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charCodeAt(--pos) === 92)
          slashCount++;
        return (slashCount & 1) === 1;
      }
      function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
          throw new Error("Did not expect successive traversals.");
        }
      }
      function addTraversal(type) {
        if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens[tokens.length - 1].type = type;
          return;
        }
        ensureNotTraversal();
        tokens.push({ type });
      }
      function addSpecialAttribute(name, action2) {
        tokens.push({
          type: types_1.SelectorType.Attribute,
          name,
          action: action2,
          value: getName(1),
          namespace: null,
          ignoreCase: "quirks"
        });
      }
      function finalizeSubselector() {
        if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens.pop();
        }
        if (tokens.length === 0) {
          throw new Error("Empty sub-selector");
        }
        subselects.push(tokens);
      }
      stripWhitespace(0);
      if (selector.length === selectorIndex) {
        return selectorIndex;
      }
      loop: while (selectorIndex < selector.length) {
        var firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
          case 32:
          case 9:
          case 10:
          case 12:
          case 13: {
            if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {
              ensureNotTraversal();
              tokens.push({ type: types_1.SelectorType.Descendant });
            }
            stripWhitespace(1);
            break;
          }
          case 62: {
            addTraversal(types_1.SelectorType.Child);
            stripWhitespace(1);
            break;
          }
          case 60: {
            addTraversal(types_1.SelectorType.Parent);
            stripWhitespace(1);
            break;
          }
          case 126: {
            addTraversal(types_1.SelectorType.Sibling);
            stripWhitespace(1);
            break;
          }
          case 43: {
            addTraversal(types_1.SelectorType.Adjacent);
            stripWhitespace(1);
            break;
          }
          case 46: {
            addSpecialAttribute("class", types_1.AttributeAction.Element);
            break;
          }
          case 35: {
            addSpecialAttribute("id", types_1.AttributeAction.Equals);
            break;
          }
          case 91: {
            stripWhitespace(1);
            var name_1 = void 0;
            var namespace = null;
            if (selector.charCodeAt(selectorIndex) === 124) {
              name_1 = getName(1);
            } else if (selector.startsWith("*|", selectorIndex)) {
              namespace = "*";
              name_1 = getName(2);
            } else {
              name_1 = getName(0);
              if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
                namespace = name_1;
                name_1 = getName(1);
              }
            }
            stripWhitespace(0);
            var action = types_1.AttributeAction.Exists;
            var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
            if (possibleAction) {
              action = possibleAction;
              if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                throw new Error("Expected `=`");
              }
              stripWhitespace(2);
            } else if (selector.charCodeAt(selectorIndex) === 61) {
              action = types_1.AttributeAction.Equals;
              stripWhitespace(1);
            }
            var value = "";
            var ignoreCase = null;
            if (action !== "exists") {
              if (isQuote(selector.charCodeAt(selectorIndex))) {
                var quote = selector.charCodeAt(selectorIndex);
                var sectionEnd = selectorIndex + 1;
                while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                  sectionEnd += 1;
                }
                if (selector.charCodeAt(sectionEnd) !== quote) {
                  throw new Error("Attribute value didn't end");
                }
                value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                selectorIndex = sectionEnd + 1;
              } else {
                var valueStart = selectorIndex;
                while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                  selectorIndex += 1;
                }
                value = unescapeCSS(selector.slice(valueStart, selectorIndex));
              }
              stripWhitespace(0);
              var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
              if (forceIgnore === 115) {
                ignoreCase = false;
                stripWhitespace(1);
              } else if (forceIgnore === 105) {
                ignoreCase = true;
                stripWhitespace(1);
              }
            }
            if (selector.charCodeAt(selectorIndex) !== 93) {
              throw new Error("Attribute selector didn't terminate");
            }
            selectorIndex += 1;
            var attributeSelector = {
              type: types_1.SelectorType.Attribute,
              name: name_1,
              action,
              value,
              namespace,
              ignoreCase
            };
            tokens.push(attributeSelector);
            break;
          }
          case 58: {
            if (selector.charCodeAt(selectorIndex + 1) === 58) {
              tokens.push({
                type: types_1.SelectorType.PseudoElement,
                name: getName(2).toLowerCase(),
                data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
              });
              continue;
            }
            var name_2 = getName(1).toLowerCase();
            var data = null;
            if (selector.charCodeAt(selectorIndex) === 40) {
              if (unpackPseudos.has(name_2)) {
                if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                  throw new Error("Pseudo-selector ".concat(name_2, " cannot be quoted"));
                }
                data = [];
                selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                if (selector.charCodeAt(selectorIndex) !== 41) {
                  throw new Error("Missing closing parenthesis in :".concat(name_2, " (").concat(selector, ")"));
                }
                selectorIndex += 1;
              } else {
                data = readValueWithParenthesis();
                if (stripQuotesFromPseudos.has(name_2)) {
                  var quot = data.charCodeAt(0);
                  if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                    data = data.slice(1, -1);
                  }
                }
                data = unescapeCSS(data);
              }
            }
            tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data });
            break;
          }
          case 44: {
            finalizeSubselector();
            tokens = [];
            stripWhitespace(1);
            break;
          }
          default: {
            if (selector.startsWith("/*", selectorIndex)) {
              var endIndex = selector.indexOf("*/", selectorIndex + 2);
              if (endIndex < 0) {
                throw new Error("Comment was not terminated");
              }
              selectorIndex = endIndex + 2;
              if (tokens.length === 0) {
                stripWhitespace(0);
              }
              break;
            }
            var namespace = null;
            var name_3 = void 0;
            if (firstChar === 42) {
              selectorIndex += 1;
              name_3 = "*";
            } else if (firstChar === 124) {
              name_3 = "";
              if (selector.charCodeAt(selectorIndex + 1) === 124) {
                addTraversal(types_1.SelectorType.ColumnCombinator);
                stripWhitespace(2);
                break;
              }
            } else if (reName.test(selector.slice(selectorIndex))) {
              name_3 = getName(0);
            } else {
              break loop;
            }
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
              namespace = name_3;
              if (selector.charCodeAt(selectorIndex + 1) === 42) {
                name_3 = "*";
                selectorIndex += 2;
              } else {
                name_3 = getName(1);
              }
            }
            tokens.push(name_3 === "*" ? { type: types_1.SelectorType.Universal, namespace } : { type: types_1.SelectorType.Tag, name: name_3, namespace });
          }
        }
      }
      finalizeSubselector();
      return selectorIndex;
    }
  }
});

// node_modules/css-what/lib/commonjs/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/css-what/lib/commonjs/stringify.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringify = void 0;
    var types_1 = require_types();
    var attribValChars = ["\\", '"'];
    var pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), ["(", ")"], false);
    var charsToEscapeInAttributeValue = new Set(attribValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [
      "~",
      "^",
      "$",
      "*",
      "+",
      "!",
      "|",
      ":",
      "[",
      "]",
      " ",
      "."
    ], false).map(function(c) {
      return c.charCodeAt(0);
    }));
    function stringify(selector) {
      return selector.map(function(token) {
        return token.map(stringifyToken).join("");
      }).join(", ");
    }
    exports2.stringify = stringify;
    function stringifyToken(token, index, arr) {
      switch (token.type) {
        case types_1.SelectorType.Child:
          return index === 0 ? "> " : " > ";
        case types_1.SelectorType.Parent:
          return index === 0 ? "< " : " < ";
        case types_1.SelectorType.Sibling:
          return index === 0 ? "~ " : " ~ ";
        case types_1.SelectorType.Adjacent:
          return index === 0 ? "+ " : " + ";
        case types_1.SelectorType.Descendant:
          return " ";
        case types_1.SelectorType.ColumnCombinator:
          return index === 0 ? "|| " : " || ";
        case types_1.SelectorType.Universal:
          return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
        case types_1.SelectorType.Tag:
          return getNamespacedName(token);
        case types_1.SelectorType.PseudoElement:
          return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
        case types_1.SelectorType.Pseudo:
          return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data), ")"));
        case types_1.SelectorType.Attribute: {
          if (token.name === "id" && token.action === types_1.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
            return "#".concat(escapeName(token.value, charsToEscapeInName));
          }
          if (token.name === "class" && token.action === types_1.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
            return ".".concat(escapeName(token.value, charsToEscapeInName));
          }
          var name_1 = getNamespacedName(token);
          if (token.action === types_1.AttributeAction.Exists) {
            return "[".concat(name_1, "]");
          }
          return "[".concat(name_1).concat(getActionValue(token.action), '="').concat(escapeName(token.value, charsToEscapeInAttributeValue), '"').concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
        }
      }
    }
    function getActionValue(action) {
      switch (action) {
        case types_1.AttributeAction.Equals:
          return "";
        case types_1.AttributeAction.Element:
          return "~";
        case types_1.AttributeAction.Start:
          return "^";
        case types_1.AttributeAction.End:
          return "$";
        case types_1.AttributeAction.Any:
          return "*";
        case types_1.AttributeAction.Not:
          return "!";
        case types_1.AttributeAction.Hyphen:
          return "|";
        case types_1.AttributeAction.Exists:
          throw new Error("Shouldn't be here");
      }
    }
    function getNamespacedName(token) {
      return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
    }
    function getNamespace(namespace) {
      return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
    }
    function escapeName(str, charsToEscape) {
      var lastIdx = 0;
      var ret = "";
      for (var i = 0; i < str.length; i++) {
        if (charsToEscape.has(str.charCodeAt(i))) {
          ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
          lastIdx = i + 1;
        }
      }
      return ret.length > 0 ? ret + str.slice(lastIdx) : str;
    }
  }
});

// node_modules/css-what/lib/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/css-what/lib/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringify = exports2.parse = exports2.isTraversal = void 0;
    __exportStar(require_types(), exports2);
    var parse_1 = require_parse();
    Object.defineProperty(exports2, "isTraversal", { enumerable: true, get: function() {
      return parse_1.isTraversal;
    } });
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    var stringify_1 = require_stringify2();
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return stringify_1.stringify;
    } });
  }
});

// node_modules/css-select/lib/procedure.js
var require_procedure = __commonJS({
  "node_modules/css-select/lib/procedure.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTraversal = exports2.procedure = void 0;
    exports2.procedure = {
      universal: 50,
      tag: 30,
      attribute: 1,
      pseudo: 0,
      "pseudo-element": 0,
      "column-combinator": -1,
      descendant: -1,
      child: -1,
      parent: -1,
      sibling: -1,
      adjacent: -1,
      _flexibleDescendant: -1
    };
    function isTraversal(t) {
      return exports2.procedure[t.type] < 0;
    }
    exports2.isTraversal = isTraversal;
  }
});

// node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "node_modules/css-select/lib/sort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    var css_what_1 = require_commonjs();
    var procedure_1 = require_procedure();
    var attributes = {
      exists: 10,
      equals: 8,
      not: 7,
      start: 6,
      end: 6,
      any: 5,
      hyphen: 4,
      element: 4
    };
    function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
          continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
          var token = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = token;
          procs[j + 1] = procs[j];
          procs[j] = procNew;
        }
      }
    }
    exports2.default = sortByProcedure;
    function getProcedure(token) {
      var proc = procedure_1.procedure[token.type];
      if (token.type === css_what_1.SelectorType.Attribute) {
        proc = attributes[token.action];
        if (proc === attributes.equals && token.name === "id") {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (token.type === css_what_1.SelectorType.Pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (Array.isArray(token.data)) {
          proc = 0;
          for (var i = 0; i < token.data.length; i++) {
            if (token.data[i].length !== 1)
              continue;
            var cur = getProcedure(token.data[i][0]);
            if (cur === 0) {
              proc = 0;
              break;
            }
            if (cur > proc)
              proc = cur;
          }
          if (token.data.length > 1 && proc > 0)
            proc -= 1;
        } else {
          proc = 1;
        }
      }
      return proc;
    }
  }
});

// node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS({
  "node_modules/css-select/lib/attributes.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attributeRules = void 0;
    var boolbase_1 = require_boolbase();
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex(value) {
      return value.replace(reChars, "\\$&");
    }
    var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink"
    ]);
    function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
    }
    exports2.attributeRules = {
      equals: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
      },
      hyphen: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function hyphenIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function hyphen(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
        };
      },
      element: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
          return boolbase_1.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
        return function element(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
        };
      },
      exists: function(next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function(elem) {
          return adapter.hasAttrib(elem, name) && next(elem);
        };
      },
      start: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
          return boolbase_1.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
        };
      },
      end: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
          return boolbase_1.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var _a;
            return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
        };
      },
      any: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
          return boolbase_1.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          var regex_1 = new RegExp(escapeRegex(value), "i");
          return function anyIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
        };
      },
      not: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
          return function(elem) {
            return !!adapter.getAttributeValue(elem, name) && next(elem);
          };
        } else if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
      }
    };
  }
});

// node_modules/nth-check/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/nth-check/lib/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = void 0;
    var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
    var ZERO = "0".charCodeAt(0);
    var NINE = "9".charCodeAt(0);
    function parse(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      }
      var idx = 0;
      var a = 0;
      var sign = readSign();
      var number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
          sign = readSign();
          skipWhitespace();
          number = readNumber();
        } else {
          sign = number = 0;
        }
      }
      if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
      }
      return [a, sign * number];
      function readSign() {
        if (formula.charAt(idx) === "-") {
          idx++;
          return -1;
        }
        if (formula.charAt(idx) === "+") {
          idx++;
        }
        return 1;
      }
      function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
          value = value * 10 + (formula.charCodeAt(idx) - ZERO);
          idx++;
        }
        return idx === start ? null : value;
      }
      function skipWhitespace() {
        while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
          idx++;
        }
      }
    }
    exports2.parse = parse;
  }
});

// node_modules/nth-check/lib/compile.js
var require_compile = __commonJS({
  "node_modules/nth-check/lib/compile.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generate = exports2.compile = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    function compile(parsed) {
      var a = parsed[0];
      var b = parsed[1] - 1;
      if (b < 0 && a <= 0)
        return boolbase_1.default.falseFunc;
      if (a === -1)
        return function(index) {
          return index <= b;
        };
      if (a === 0)
        return function(index) {
          return index === b;
        };
      if (a === 1)
        return b < 0 ? boolbase_1.default.trueFunc : function(index) {
          return index >= b;
        };
      var absA = Math.abs(a);
      var bMod = (b % absA + absA) % absA;
      return a > 1 ? function(index) {
        return index >= b && index % absA === bMod;
      } : function(index) {
        return index <= b && index % absA === bMod;
      };
    }
    exports2.compile = compile;
    function generate(parsed) {
      var a = parsed[0];
      var b = parsed[1] - 1;
      var n = 0;
      if (a < 0) {
        var aPos_1 = -a;
        var minValue_1 = (b % aPos_1 + aPos_1) % aPos_1;
        return function() {
          var val = minValue_1 + aPos_1 * n++;
          return val > b ? null : val;
        };
      }
      if (a === 0)
        return b < 0 ? (
          // There are no result — always return `null`
          function() {
            return null;
          }
        ) : (
          // Return `b` exactly once
          function() {
            return n++ === 0 ? b : null;
          }
        );
      if (b < 0) {
        b += a * Math.ceil(-b / a);
      }
      return function() {
        return a * n++ + b;
      };
    }
    exports2.generate = generate;
  }
});

// node_modules/nth-check/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/nth-check/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sequence = exports2.generate = exports2.compile = exports2.parse = void 0;
    var parse_js_1 = require_parse2();
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_js_1.parse;
    } });
    var compile_js_1 = require_compile();
    Object.defineProperty(exports2, "compile", { enumerable: true, get: function() {
      return compile_js_1.compile;
    } });
    Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
      return compile_js_1.generate;
    } });
    function nthCheck(formula) {
      return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
    }
    exports2.default = nthCheck;
    function sequence(formula) {
      return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
    }
    exports2.sequence = sequence;
  }
});

// node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/filters.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filters = void 0;
    var nth_check_1 = __importDefault(require_lib8());
    var boolbase_1 = require_boolbase();
    function getChildFunc(next, adapter) {
      return function(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
      };
    }
    exports2.filters = {
      contains: function(next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
          return next(elem) && adapter.getText(elem).includes(text);
        };
      },
      icontains: function(next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
          return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
        };
      },
      // Location specific methods
      "nth-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
          return getChildFunc(next, adapter);
        return function nthChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings.length; i++) {
            if (equals(elem, siblings[i]))
              break;
            if (adapter.isTag(siblings[i])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
              break;
            if (adapter.isTag(siblings[i])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
          return getChildFunc(next, adapter);
        return function nthOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (func === boolbase_1.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      // TODO determine the actual root element
      root: function(next, _rule, _a) {
        var adapter = _a.adapter;
        return function(elem) {
          var parent = adapter.getParent(elem);
          return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
      },
      scope: function(next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
          return exports2.filters.root(next, rule, options);
        }
        if (context.length === 1) {
          return function(elem) {
            return equals(context[0], elem) && next(elem);
          };
        }
        return function(elem) {
          return context.includes(elem) && next(elem);
        };
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive")
    };
    function dynamicStatePseudo(name) {
      return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
          return boolbase_1.falseFunc;
        }
        return function active(elem) {
          return func(elem) && next(elem);
        };
      };
    }
  }
});

// node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyPseudoArgs = exports2.pseudos = void 0;
    exports2.pseudos = {
      empty: function(elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function(elem2) {
          return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
        });
      },
      "first-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var firstChild = adapter.getSiblings(elem).find(function(elem2) {
          return adapter.isTag(elem2);
        });
        return firstChild != null && equals(elem, firstChild);
      },
      "last-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          if (equals(elem, siblings[i]))
            return true;
          if (adapter.isTag(siblings[i]))
            break;
        }
        return false;
      },
      "first-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "last-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "only-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
        });
      },
      "only-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling);
        });
      }
    };
    function verifyPseudoArgs(func, name, subselect) {
      if (subselect === null) {
        if (func.length > 2) {
          throw new Error("pseudo-selector :".concat(name, " requires an argument"));
        }
      } else if (func.length === 2) {
        throw new Error("pseudo-selector :".concat(name, " doesn't have any arguments"));
      }
    }
    exports2.verifyPseudoArgs = verifyPseudoArgs;
  }
});

// node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.aliases = void 0;
    exports2.aliases = {
      // Links
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      // Forms
      // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      // JQuery extensions
      // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])"
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.subselects = exports2.getNextSiblings = exports2.ensureIsTag = exports2.PLACEHOLDER_ELEMENT = void 0;
    var boolbase_1 = require_boolbase();
    var procedure_1 = require_procedure();
    exports2.PLACEHOLDER_ELEMENT = {};
    function ensureIsTag(next, adapter) {
      if (next === boolbase_1.falseFunc)
        return boolbase_1.falseFunc;
      return function(elem) {
        return adapter.isTag(elem) && next(elem);
      };
    }
    exports2.ensureIsTag = ensureIsTag;
    function getNextSiblings(elem, adapter) {
      var siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1)
        return [];
      var elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
    }
    exports2.getNextSiblings = getNextSiblings;
    var is = function(next, token, options, context, compileToken) {
      var opts = {
        xmlMode: !!options.xmlMode,
        adapter: options.adapter,
        equals: options.equals
      };
      var func = compileToken(token, opts, context);
      return function(elem) {
        return func(elem) && next(elem);
      };
    };
    exports2.subselects = {
      is,
      /**
       * `:matches` and `:where` are aliases for `:is`.
       */
      matches: is,
      where: is,
      not: function(next, token, options, context, compileToken) {
        var opts = {
          xmlMode: !!options.xmlMode,
          adapter: options.adapter,
          equals: options.equals
        };
        var func = compileToken(token, opts, context);
        if (func === boolbase_1.falseFunc)
          return next;
        if (func === boolbase_1.trueFunc)
          return boolbase_1.falseFunc;
        return function not(elem) {
          return !func(elem) && next(elem);
        };
      },
      has: function(next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = {
          xmlMode: !!options.xmlMode,
          adapter,
          equals: options.equals
        };
        var context = subselect.some(function(s) {
          return s.some(procedure_1.isTraversal);
        }) ? [exports2.PLACEHOLDER_ELEMENT] : void 0;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.falseFunc)
          return boolbase_1.falseFunc;
        if (compiled === boolbase_1.trueFunc) {
          return function(elem) {
            return adapter.getChildren(elem).some(adapter.isTag) && next(elem);
          };
        }
        var hasElement = ensureIsTag(compiled, adapter);
        var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings = _a === void 0 ? false : _a;
        if (context) {
          return function(elem) {
            context[0] = elem;
            var childs = adapter.getChildren(elem);
            var nextElements = shouldTestNextSiblings ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
            return next(elem) && adapter.existsOne(hasElement, nextElements);
          };
        }
        return function(elem) {
          return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
      }
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compilePseudoSelector = exports2.aliases = exports2.pseudos = exports2.filters = void 0;
    var boolbase_1 = require_boolbase();
    var css_what_1 = require_commonjs();
    var filters_1 = require_filters();
    Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
      return filters_1.filters;
    } });
    var pseudos_1 = require_pseudos();
    Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
      return pseudos_1.pseudos;
    } });
    var aliases_1 = require_aliases();
    Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
      return aliases_1.aliases;
    } });
    var subselects_1 = require_subselects();
    function compilePseudoSelector(next, selector, options, context, compileToken) {
      var name = selector.name, data = selector.data;
      if (Array.isArray(data)) {
        return subselects_1.subselects[name](next, data, options, context, compileToken);
      }
      if (name in aliases_1.aliases) {
        if (data != null) {
          throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        var alias = (0, css_what_1.parse)(aliases_1.aliases[name]);
        return subselects_1.subselects.is(next, alias, options, context, compileToken);
      }
      if (name in filters_1.filters) {
        return filters_1.filters[name](next, data, options, context);
      }
      if (name in pseudos_1.pseudos) {
        var pseudo_1 = pseudos_1.pseudos[name];
        (0, pseudos_1.verifyPseudoArgs)(pseudo_1, name, data);
        return pseudo_1 === boolbase_1.falseFunc ? boolbase_1.falseFunc : next === boolbase_1.trueFunc ? function(elem) {
          return pseudo_1(elem, options, data);
        } : function(elem) {
          return pseudo_1(elem, options, data) && next(elem);
        };
      }
      throw new Error("unmatched pseudo-class :".concat(name));
    }
    exports2.compilePseudoSelector = compilePseudoSelector;
  }
});

// node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "node_modules/css-select/lib/general.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compileGeneralSelector = void 0;
    var attributes_1 = require_attributes();
    var pseudo_selectors_1 = require_pseudo_selectors();
    var css_what_1 = require_commonjs();
    function compileGeneralSelector(next, selector, options, context, compileToken) {
      var adapter = options.adapter, equals = options.equals;
      switch (selector.type) {
        case css_what_1.SelectorType.PseudoElement: {
          throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1.SelectorType.ColumnCombinator: {
          throw new Error("Column combinators are not yet supported by css-select");
        }
        case css_what_1.SelectorType.Attribute: {
          if (selector.namespace != null) {
            throw new Error("Namespaced attributes are not yet supported by css-select");
          }
          if (!options.xmlMode || options.lowerCaseAttributeNames) {
            selector.name = selector.name.toLowerCase();
          }
          return attributes_1.attributeRules[selector.action](next, selector, options);
        }
        case css_what_1.SelectorType.Pseudo: {
          return (0, pseudo_selectors_1.compilePseudoSelector)(next, selector, options, context, compileToken);
        }
        case css_what_1.SelectorType.Tag: {
          if (selector.namespace != null) {
            throw new Error("Namespaced tag names are not yet supported by css-select");
          }
          var name_1 = selector.name;
          if (!options.xmlMode || options.lowerCaseTags) {
            name_1 = name_1.toLowerCase();
          }
          return function tag(elem) {
            return adapter.getName(elem) === name_1 && next(elem);
          };
        }
        case css_what_1.SelectorType.Descendant: {
          if (options.cacheResults === false || typeof WeakSet === "undefined") {
            return function descendant(elem) {
              var current = elem;
              while (current = adapter.getParent(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
              }
              return false;
            };
          }
          var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
          return function cachedDescendant(elem) {
            var current = elem;
            while (current = adapter.getParent(current)) {
              if (!isFalseCache_1.has(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
                isFalseCache_1.add(current);
              }
            }
            return false;
          };
        }
        case "_flexibleDescendant": {
          return function flexibleDescendant(elem) {
            var current = elem;
            do {
              if (adapter.isTag(current) && next(current))
                return true;
            } while (current = adapter.getParent(current));
            return false;
          };
        }
        case css_what_1.SelectorType.Parent: {
          return function parent(elem) {
            return adapter.getChildren(elem).some(function(elem2) {
              return adapter.isTag(elem2) && next(elem2);
            });
          };
        }
        case css_what_1.SelectorType.Child: {
          return function child(elem) {
            var parent = adapter.getParent(elem);
            return parent != null && adapter.isTag(parent) && next(parent);
          };
        }
        case css_what_1.SelectorType.Sibling: {
          return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling) && next(currentSibling)) {
                return true;
              }
            }
            return false;
          };
        }
        case css_what_1.SelectorType.Adjacent: {
          if (adapter.prevElementSibling) {
            return function adjacent(elem) {
              var previous = adapter.prevElementSibling(elem);
              return previous != null && next(previous);
            };
          }
          return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem);
            var lastElement;
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling)) {
                lastElement = currentSibling;
              }
            }
            return !!lastElement && next(lastElement);
          };
        }
        case css_what_1.SelectorType.Universal: {
          if (selector.namespace != null && selector.namespace !== "*") {
            throw new Error("Namespaced universal selectors are not yet supported by css-select");
          }
          return next;
        }
      }
    }
    exports2.compileGeneralSelector = compileGeneralSelector;
  }
});

// node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/css-select/lib/compile.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compileToken = exports2.compileUnsafe = exports2.compile = void 0;
    var css_what_1 = require_commonjs();
    var boolbase_1 = require_boolbase();
    var sort_1 = __importDefault(require_sort());
    var procedure_1 = require_procedure();
    var general_1 = require_general();
    var subselects_1 = require_subselects();
    function compile(selector, options, context) {
      var next = compileUnsafe(selector, options, context);
      return (0, subselects_1.ensureIsTag)(next, options.adapter);
    }
    exports2.compile = compile;
    function compileUnsafe(selector, options, context) {
      var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
      return compileToken(token, options, context);
    }
    exports2.compileUnsafe = compileUnsafe;
    function includesScopePseudo(t) {
      return t.type === "pseudo" && (t.name === "scope" || Array.isArray(t.data) && t.data.some(function(data) {
        return data.some(includesScopePseudo);
      }));
    }
    var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
    var FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant"
    };
    var SCOPE_TOKEN = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null
    };
    function absolutize(token, _a, context) {
      var adapter = _a.adapter;
      var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function(e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
      }));
      for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t = token_1[_i];
        if (t.length > 0 && (0, procedure_1.isTraversal)(t[0]) && t[0].type !== "descendant") {
        } else if (hasContext && !t.some(includesScopePseudo)) {
          t.unshift(DESCENDANT_TOKEN);
        } else {
          continue;
        }
        t.unshift(SCOPE_TOKEN);
      }
    }
    function compileToken(token, options, context) {
      var _a;
      token = token.filter(function(t) {
        return t.length > 0;
      });
      token.forEach(sort_1.default);
      context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
      var isArrayContext = Array.isArray(context);
      var finalContext = context && (Array.isArray(context) ? context : [context]);
      absolutize(token, options, finalContext);
      var shouldTestNextSiblings = false;
      var query = token.map(function(rules) {
        if (rules.length >= 2) {
          var first = rules[0], second = rules[1];
          if (first.type !== "pseudo" || first.name !== "scope") {
          } else if (isArrayContext && second.type === "descendant") {
            rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
          } else if (second.type === "adjacent" || second.type === "sibling") {
            shouldTestNextSiblings = true;
          }
        }
        return compileRules(rules, options, finalContext);
      }).reduce(reduceRules, boolbase_1.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
    }
    exports2.compileToken = compileToken;
    function compileRules(rules, options, context) {
      var _a;
      return rules.reduce(function(previous, rule) {
        return previous === boolbase_1.falseFunc ? boolbase_1.falseFunc : (0, general_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
      }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.trueFunc);
    }
    function reduceRules(a, b) {
      if (b === boolbase_1.falseFunc || a === boolbase_1.trueFunc) {
        return a;
      }
      if (a === boolbase_1.falseFunc || b === boolbase_1.trueFunc) {
        return b;
      }
      return function combine(elem) {
        return a(elem) || b(elem);
      };
    }
  }
});

// node_modules/css-select/lib/index.js
var require_lib9 = __commonJS({
  "node_modules/css-select/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    } : function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    });
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    } : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.aliases = exports2.pseudos = exports2.filters = exports2.is = exports2.selectOne = exports2.selectAll = exports2.prepareContext = exports2._compileToken = exports2._compileUnsafe = exports2.compile = void 0;
    var DomUtils = __importStar(require_lib7());
    var boolbase_1 = require_boolbase();
    var compile_1 = require_compile2();
    var subselects_1 = require_subselects();
    var defaultEquals = function(a, b) {
      return a === b;
    };
    var defaultOptions = {
      adapter: DomUtils,
      equals: defaultEquals
    };
    function convertOptionFormats(options) {
      var _a, _b, _c, _d;
      var opts = options !== null && options !== void 0 ? options : defaultOptions;
      (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
      (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
      return opts;
    }
    function wrapCompile(func) {
      return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
      };
    }
    exports2.compile = wrapCompile(compile_1.compile);
    exports2._compileUnsafe = wrapCompile(compile_1.compileUnsafe);
    exports2._compileToken = wrapCompile(compile_1.compileToken);
    function getSelectorFunc(searchFunc) {
      return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
          query = (0, compile_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
      };
    }
    function prepareContext(elems, adapter, shouldTestNextSiblings) {
      if (shouldTestNextSiblings === void 0) {
        shouldTestNextSiblings = false;
      }
      if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
      }
      return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
    }
    exports2.prepareContext = prepareContext;
    function appendNextSiblings(elem, adapter) {
      var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
      var elemsLength = elems.length;
      for (var i = 0; i < elemsLength; i++) {
        var nextSiblings = (0, subselects_1.getNextSiblings)(elems[i], adapter);
        elems.push.apply(elems, nextSiblings);
      }
      return elems;
    }
    exports2.selectAll = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
    });
    exports2.selectOne = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
    });
    function is(elem, query, options) {
      var opts = convertOptionFormats(options);
      return (typeof query === "function" ? query : (0, compile_1.compile)(query, opts))(elem);
    }
    exports2.is = is;
    exports2.default = exports2.selectAll;
    var pseudo_selectors_1 = require_pseudo_selectors();
    Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
      return pseudo_selectors_1.filters;
    } });
    Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
      return pseudo_selectors_1.pseudos;
    } });
    Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
      return pseudo_selectors_1.aliases;
    } });
  }
});

// node_modules/svgo/lib/svgo/css-select-adapter.js
var require_css_select_adapter = __commonJS({
  "node_modules/svgo/lib/svgo/css-select-adapter.js"(exports2, module2) {
    "use strict";
    var isTag = (node) => {
      return node.type === "element";
    };
    var existsOne = (test, elems) => {
      return elems.some((elem) => {
        if (isTag(elem)) {
          return test(elem) || existsOne(test, getChildren(elem));
        } else {
          return false;
        }
      });
    };
    var getAttributeValue = (elem, name) => {
      return elem.attributes[name];
    };
    var getChildren = (node) => {
      return node.children || [];
    };
    var getName = (elemAst) => {
      return elemAst.name;
    };
    var getParent = (node) => {
      return node.parentNode || null;
    };
    var getSiblings = (elem) => {
      var parent = getParent(elem);
      return parent ? getChildren(parent) : [];
    };
    var getText = (node) => {
      if (node.children[0].type === "text" && node.children[0].type === "cdata") {
        return node.children[0].value;
      }
      return "";
    };
    var hasAttrib = (elem, name) => {
      return elem.attributes[name] !== void 0;
    };
    var removeSubsets = (nodes) => {
      let idx = nodes.length;
      let node;
      let ancestor;
      let replace;
      while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
          if (nodes.includes(ancestor)) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }
          ancestor = getParent(ancestor);
        }
        if (replace) {
          nodes[idx] = node;
        }
      }
      return nodes;
    };
    var findAll = (test, elems) => {
      const result = [];
      for (const elem of elems) {
        if (isTag(elem)) {
          if (test(elem)) {
            result.push(elem);
          }
          result.push(...findAll(test, getChildren(elem)));
        }
      }
      return result;
    };
    var findOne = (test, elems) => {
      for (const elem of elems) {
        if (isTag(elem)) {
          if (test(elem)) {
            return elem;
          }
          const result = findOne(test, getChildren(elem));
          if (result) {
            return result;
          }
        }
      }
      return null;
    };
    var svgoCssSelectAdapter = {
      isTag,
      existsOne,
      getAttributeValue,
      getChildren,
      getName,
      getParent,
      getSiblings,
      getText,
      hasAttrib,
      removeSubsets,
      findAll,
      findOne
    };
    module2.exports = svgoCssSelectAdapter;
  }
});

// node_modules/svgo/lib/xast.js
var require_xast = __commonJS({
  "node_modules/svgo/lib/xast.js"(exports2) {
    "use strict";
    var { selectAll, selectOne, is } = require_lib9();
    var xastAdaptor = require_css_select_adapter();
    var cssSelectOptions = {
      xmlMode: true,
      adapter: xastAdaptor
    };
    var querySelectorAll = (node, selector) => {
      return selectAll(selector, node, cssSelectOptions);
    };
    exports2.querySelectorAll = querySelectorAll;
    var querySelector = (node, selector) => {
      return selectOne(selector, node, cssSelectOptions);
    };
    exports2.querySelector = querySelector;
    var matches = (node, selector) => {
      return is(node, selector, cssSelectOptions);
    };
    exports2.matches = matches;
    var closestByName = (node, name) => {
      let currentNode = node;
      while (currentNode) {
        if (currentNode.type === "element" && currentNode.name === name) {
          return currentNode;
        }
        currentNode = currentNode.parentNode;
      }
      return null;
    };
    exports2.closestByName = closestByName;
    var visitSkip = Symbol();
    exports2.visitSkip = visitSkip;
    var visit = (node, visitor, parentNode) => {
      const callbacks = visitor[node.type];
      if (callbacks && callbacks.enter) {
        const symbol = callbacks.enter(node, parentNode);
        if (symbol === visitSkip) {
          return;
        }
      }
      if (node.type === "root") {
        for (const child of node.children) {
          visit(child, visitor, node);
        }
      }
      if (node.type === "element") {
        if (parentNode.children.includes(node)) {
          for (const child of node.children) {
            visit(child, visitor, node);
          }
        }
      }
      if (callbacks && callbacks.exit) {
        callbacks.exit(node, parentNode);
      }
    };
    exports2.visit = visit;
    var detachNodeFromParent = (node, parentNode) => {
      parentNode.children = parentNode.children.filter((child) => child !== node);
    };
    exports2.detachNodeFromParent = detachNodeFromParent;
  }
});

// node_modules/svgo/lib/svgo/plugins.js
var require_plugins = __commonJS({
  "node_modules/svgo/lib/svgo/plugins.js"(exports2) {
    "use strict";
    var { visit } = require_xast();
    var invokePlugins = (ast, info, plugins, overrides, globalOverrides) => {
      for (const plugin of plugins) {
        const override = overrides == null ? null : overrides[plugin.name];
        if (override === false) {
          continue;
        }
        const params = { ...plugin.params, ...globalOverrides, ...override };
        if (plugin.type === "perItem") {
          ast = perItem(ast, info, plugin, params);
        }
        if (plugin.type === "perItemReverse") {
          ast = perItem(ast, info, plugin, params, true);
        }
        if (plugin.type === "full") {
          if (plugin.active) {
            ast = plugin.fn(ast, params, info);
          }
        }
        if (plugin.type === "visitor") {
          if (plugin.active) {
            const visitor = plugin.fn(ast, params, info);
            if (visitor != null) {
              visit(ast, visitor);
            }
          }
        }
      }
      return ast;
    };
    exports2.invokePlugins = invokePlugins;
    function perItem(data, info, plugin, params, reverse) {
      function monkeys(items) {
        items.children = items.children.filter(function(item) {
          if (reverse && item.children) {
            monkeys(item);
          }
          let kept = true;
          if (plugin.active) {
            kept = plugin.fn(item, params, info) !== false;
          }
          if (!reverse && item.children) {
            monkeys(item);
          }
          return kept;
        });
        return items;
      }
      return monkeys(data);
    }
    var createPreset = ({ name, plugins }) => {
      return {
        name,
        type: "full",
        fn: (ast, params, info) => {
          const { floatPrecision, overrides } = params;
          const globalOverrides = {};
          if (floatPrecision != null) {
            globalOverrides.floatPrecision = floatPrecision;
          }
          if (overrides) {
            for (const [pluginName, override] of Object.entries(overrides)) {
              if (override === true) {
                console.warn(
                  `You are trying to enable ${pluginName} which is not part of preset.
Try to put it before or after preset, for example

plugins: [
  {
    name: 'preset-default',
  },
  'cleanupListOfValues'
]
`
                );
              }
            }
          }
          return invokePlugins(ast, info, plugins, overrides, globalOverrides);
        }
      };
    };
    exports2.createPreset = createPreset;
  }
});

// node_modules/svgo/plugins/removeDoctype.js
var require_removeDoctype = __commonJS({
  "node_modules/svgo/plugins/removeDoctype.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeDoctype";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "removes doctype declaration";
    exports2.fn = () => {
      return {
        doctype: {
          enter: (node, parentNode) => {
            detachNodeFromParent(node, parentNode);
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeXMLProcInst.js
var require_removeXMLProcInst = __commonJS({
  "node_modules/svgo/plugins/removeXMLProcInst.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeXMLProcInst";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "removes XML processing instructions";
    exports2.fn = () => {
      return {
        instruction: {
          enter: (node, parentNode) => {
            if (node.name === "xml") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeComments.js
var require_removeComments = __commonJS({
  "node_modules/svgo/plugins/removeComments.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeComments";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "removes comments";
    exports2.fn = () => {
      return {
        comment: {
          enter: (node, parentNode) => {
            if (node.value.charAt(0) !== "!") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeMetadata.js
var require_removeMetadata = __commonJS({
  "node_modules/svgo/plugins/removeMetadata.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeMetadata";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "removes <metadata>";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "metadata") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/_collections.js
var require_collections = __commonJS({
  "node_modules/svgo/plugins/_collections.js"(exports2) {
    "use strict";
    exports2.elemsGroups = {
      animation: [
        "animate",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "set"
      ],
      descriptive: ["desc", "metadata", "title"],
      shape: ["circle", "ellipse", "line", "path", "polygon", "polyline", "rect"],
      structural: ["defs", "g", "svg", "symbol", "use"],
      paintServer: [
        "solidColor",
        "linearGradient",
        "radialGradient",
        "meshGradient",
        "pattern",
        "hatch"
      ],
      nonRendering: [
        "linearGradient",
        "radialGradient",
        "pattern",
        "clipPath",
        "mask",
        "marker",
        "symbol",
        "filter",
        "solidColor"
      ],
      container: [
        "a",
        "defs",
        "g",
        "marker",
        "mask",
        "missing-glyph",
        "pattern",
        "svg",
        "switch",
        "symbol",
        "foreignObject"
      ],
      textContent: [
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "glyph",
        "glyphRef",
        "textPath",
        "text",
        "tref",
        "tspan"
      ],
      textContentChild: ["altGlyph", "textPath", "tref", "tspan"],
      lightSource: [
        "feDiffuseLighting",
        "feSpecularLighting",
        "feDistantLight",
        "fePointLight",
        "feSpotLight"
      ],
      filterPrimitive: [
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "feSpecularLighting",
        "feTile",
        "feTurbulence"
      ]
    };
    exports2.textElems = exports2.elemsGroups.textContent.concat("title");
    exports2.pathElems = ["path", "glyph", "missing-glyph"];
    exports2.attrsGroups = {
      animationAddition: ["additive", "accumulate"],
      animationAttributeTarget: ["attributeType", "attributeName"],
      animationEvent: ["onbegin", "onend", "onrepeat", "onload"],
      animationTiming: [
        "begin",
        "dur",
        "end",
        "min",
        "max",
        "restart",
        "repeatCount",
        "repeatDur",
        "fill"
      ],
      animationValue: [
        "calcMode",
        "values",
        "keyTimes",
        "keySplines",
        "from",
        "to",
        "by"
      ],
      conditionalProcessing: [
        "requiredFeatures",
        "requiredExtensions",
        "systemLanguage"
      ],
      core: ["id", "tabindex", "xml:base", "xml:lang", "xml:space"],
      graphicalEvent: [
        "onfocusin",
        "onfocusout",
        "onactivate",
        "onclick",
        "onmousedown",
        "onmouseup",
        "onmouseover",
        "onmousemove",
        "onmouseout",
        "onload"
      ],
      presentation: [
        "alignment-baseline",
        "baseline-shift",
        "clip",
        "clip-path",
        "clip-rule",
        "color",
        "color-interpolation",
        "color-interpolation-filters",
        "color-profile",
        "color-rendering",
        "cursor",
        "direction",
        "display",
        "dominant-baseline",
        "enable-background",
        "fill",
        "fill-opacity",
        "fill-rule",
        "filter",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size",
        "font-size-adjust",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "opacity",
        "overflow",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "stroke",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "text-anchor",
        "text-decoration",
        "text-overflow",
        "text-rendering",
        "transform",
        "transform-origin",
        "unicode-bidi",
        "vector-effect",
        "visibility",
        "word-spacing",
        "writing-mode"
      ],
      xlink: [
        "xlink:href",
        "xlink:show",
        "xlink:actuate",
        "xlink:type",
        "xlink:role",
        "xlink:arcrole",
        "xlink:title"
      ],
      documentEvent: [
        "onunload",
        "onabort",
        "onerror",
        "onresize",
        "onscroll",
        "onzoom"
      ],
      filterPrimitive: ["x", "y", "width", "height", "result"],
      transferFunction: [
        "type",
        "tableValues",
        "slope",
        "intercept",
        "amplitude",
        "exponent",
        "offset"
      ]
    };
    exports2.attrsGroupsDefaults = {
      core: { "xml:space": "default" },
      presentation: {
        clip: "auto",
        "clip-path": "none",
        "clip-rule": "nonzero",
        mask: "none",
        opacity: "1",
        "stop-color": "#000",
        "stop-opacity": "1",
        "fill-opacity": "1",
        "fill-rule": "nonzero",
        fill: "#000",
        stroke: "none",
        "stroke-width": "1",
        "stroke-linecap": "butt",
        "stroke-linejoin": "miter",
        "stroke-miterlimit": "4",
        "stroke-dasharray": "none",
        "stroke-dashoffset": "0",
        "stroke-opacity": "1",
        "paint-order": "normal",
        "vector-effect": "none",
        display: "inline",
        visibility: "visible",
        "marker-start": "none",
        "marker-mid": "none",
        "marker-end": "none",
        "color-interpolation": "sRGB",
        "color-interpolation-filters": "linearRGB",
        "color-rendering": "auto",
        "shape-rendering": "auto",
        "text-rendering": "auto",
        "image-rendering": "auto",
        "font-style": "normal",
        "font-variant": "normal",
        "font-weight": "normal",
        "font-stretch": "normal",
        "font-size": "medium",
        "font-size-adjust": "none",
        kerning: "auto",
        "letter-spacing": "normal",
        "word-spacing": "normal",
        "text-decoration": "none",
        "text-anchor": "start",
        "text-overflow": "clip",
        "writing-mode": "lr-tb",
        "glyph-orientation-vertical": "auto",
        "glyph-orientation-horizontal": "0deg",
        direction: "ltr",
        "unicode-bidi": "normal",
        "dominant-baseline": "auto",
        "alignment-baseline": "baseline",
        "baseline-shift": "baseline"
      },
      transferFunction: {
        slope: "1",
        intercept: "0",
        amplitude: "1",
        exponent: "1",
        offset: "0"
      }
    };
    exports2.elems = {
      a: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "target"
        ],
        defaults: {
          target: "_self"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view",
          // not spec compliant
          "tspan"
        ]
      },
      altGlyph: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x",
          "y",
          "dx",
          "dy",
          "glyphRef",
          "format",
          "rotate"
        ]
      },
      altGlyphDef: {
        attrsGroups: ["core"],
        content: ["glyphRef"]
      },
      altGlyphItem: {
        attrsGroups: ["core"],
        content: ["glyphRef", "altGlyphItem"]
      },
      animate: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animationAddition",
          "animationAttributeTarget",
          "animationEvent",
          "animationTiming",
          "animationValue",
          "presentation",
          "xlink"
        ],
        attrs: ["externalResourcesRequired"],
        contentGroups: ["descriptive"]
      },
      animateColor: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animationEvent",
          "xlink",
          "animationAttributeTarget",
          "animationTiming",
          "animationValue",
          "animationAddition",
          "presentation"
        ],
        attrs: ["externalResourcesRequired"],
        contentGroups: ["descriptive"]
      },
      animateMotion: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animationEvent",
          "xlink",
          "animationTiming",
          "animationValue",
          "animationAddition"
        ],
        attrs: [
          "externalResourcesRequired",
          "path",
          "keyPoints",
          "rotate",
          "origin"
        ],
        defaults: {
          rotate: "0"
        },
        contentGroups: ["descriptive"],
        content: ["mpath"]
      },
      animateTransform: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animationEvent",
          "xlink",
          "animationAttributeTarget",
          "animationTiming",
          "animationValue",
          "animationAddition"
        ],
        attrs: ["externalResourcesRequired", "type"],
        contentGroups: ["descriptive"]
      },
      circle: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "cx",
          "cy",
          "r"
        ],
        defaults: {
          cx: "0",
          cy: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      clipPath: {
        attrsGroups: ["conditionalProcessing", "core", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "clipPathUnits"
        ],
        defaults: {
          clipPathUnits: "userSpaceOnUse"
        },
        contentGroups: ["animation", "descriptive", "shape"],
        content: ["text", "use"]
      },
      "color-profile": {
        attrsGroups: ["core", "xlink"],
        attrs: ["local", "name", "rendering-intent"],
        defaults: {
          name: "sRGB",
          "rendering-intent": "auto"
        },
        contentGroups: ["descriptive"]
      },
      cursor: {
        attrsGroups: ["core", "conditionalProcessing", "xlink"],
        attrs: ["externalResourcesRequired", "x", "y"],
        defaults: {
          x: "0",
          y: "0"
        },
        contentGroups: ["descriptive"]
      },
      defs: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: ["class", "style", "externalResourcesRequired", "transform"],
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      desc: {
        attrsGroups: ["core"],
        attrs: ["class", "style"]
      },
      ellipse: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "cx",
          "cy",
          "rx",
          "ry"
        ],
        defaults: {
          cx: "0",
          cy: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      feBlend: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          // TODO: in - 'If no value is provided and this is the first filter primitive,
          // then this filter primitive will use SourceGraphic as its input'
          "in",
          "in2",
          "mode"
        ],
        defaults: {
          mode: "normal"
        },
        content: ["animate", "set"]
      },
      feColorMatrix: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "type", "values"],
        defaults: {
          type: "matrix"
        },
        content: ["animate", "set"]
      },
      feComponentTransfer: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in"],
        content: ["feFuncA", "feFuncB", "feFuncG", "feFuncR"]
      },
      feComposite: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "in2", "operator", "k1", "k2", "k3", "k4"],
        defaults: {
          operator: "over",
          k1: "0",
          k2: "0",
          k3: "0",
          k4: "0"
        },
        content: ["animate", "set"]
      },
      feConvolveMatrix: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "in",
          "order",
          "kernelMatrix",
          // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
          // with the exception that if the sum is zero, then the divisor is set to 1'
          "divisor",
          "bias",
          // TODO: targetX - 'By default, the convolution matrix is centered in X over each
          // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
          "targetX",
          "targetY",
          "edgeMode",
          // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
          // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
          "kernelUnitLength",
          "preserveAlpha"
        ],
        defaults: {
          order: "3",
          bias: "0",
          edgeMode: "duplicate",
          preserveAlpha: "false"
        },
        content: ["animate", "set"]
      },
      feDiffuseLighting: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "in",
          "surfaceScale",
          "diffuseConstant",
          "kernelUnitLength"
        ],
        defaults: {
          surfaceScale: "1",
          diffuseConstant: "1"
        },
        contentGroups: ["descriptive"],
        content: [
          // TODO: 'exactly one light source element, in any order'
          "feDistantLight",
          "fePointLight",
          "feSpotLight"
        ]
      },
      feDisplacementMap: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "in",
          "in2",
          "scale",
          "xChannelSelector",
          "yChannelSelector"
        ],
        defaults: {
          scale: "0",
          xChannelSelector: "A",
          yChannelSelector: "A"
        },
        content: ["animate", "set"]
      },
      feDistantLight: {
        attrsGroups: ["core"],
        attrs: ["azimuth", "elevation"],
        defaults: {
          azimuth: "0",
          elevation: "0"
        },
        content: ["animate", "set"]
      },
      feFlood: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style"],
        content: ["animate", "animateColor", "set"]
      },
      feFuncA: {
        attrsGroups: ["core", "transferFunction"],
        content: ["set", "animate"]
      },
      feFuncB: {
        attrsGroups: ["core", "transferFunction"],
        content: ["set", "animate"]
      },
      feFuncG: {
        attrsGroups: ["core", "transferFunction"],
        content: ["set", "animate"]
      },
      feFuncR: {
        attrsGroups: ["core", "transferFunction"],
        content: ["set", "animate"]
      },
      feGaussianBlur: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "stdDeviation"],
        defaults: {
          stdDeviation: "0"
        },
        content: ["set", "animate"]
      },
      feImage: {
        attrsGroups: ["core", "presentation", "filterPrimitive", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "preserveAspectRatio",
          "href",
          "xlink:href"
        ],
        defaults: {
          preserveAspectRatio: "xMidYMid meet"
        },
        content: ["animate", "animateTransform", "set"]
      },
      feMerge: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style"],
        content: ["feMergeNode"]
      },
      feMergeNode: {
        attrsGroups: ["core"],
        attrs: ["in"],
        content: ["animate", "set"]
      },
      feMorphology: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "operator", "radius"],
        defaults: {
          operator: "erode",
          radius: "0"
        },
        content: ["animate", "set"]
      },
      feOffset: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in", "dx", "dy"],
        defaults: {
          dx: "0",
          dy: "0"
        },
        content: ["animate", "set"]
      },
      fePointLight: {
        attrsGroups: ["core"],
        attrs: ["x", "y", "z"],
        defaults: {
          x: "0",
          y: "0",
          z: "0"
        },
        content: ["animate", "set"]
      },
      feSpecularLighting: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "in",
          "surfaceScale",
          "specularConstant",
          "specularExponent",
          "kernelUnitLength"
        ],
        defaults: {
          surfaceScale: "1",
          specularConstant: "1",
          specularExponent: "1"
        },
        contentGroups: [
          "descriptive",
          // TODO: exactly one 'light source element'
          "lightSource"
        ]
      },
      feSpotLight: {
        attrsGroups: ["core"],
        attrs: [
          "x",
          "y",
          "z",
          "pointsAtX",
          "pointsAtY",
          "pointsAtZ",
          "specularExponent",
          "limitingConeAngle"
        ],
        defaults: {
          x: "0",
          y: "0",
          z: "0",
          pointsAtX: "0",
          pointsAtY: "0",
          pointsAtZ: "0",
          specularExponent: "1"
        },
        content: ["animate", "set"]
      },
      feTile: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: ["class", "style", "in"],
        content: ["animate", "set"]
      },
      feTurbulence: {
        attrsGroups: ["core", "presentation", "filterPrimitive"],
        attrs: [
          "class",
          "style",
          "baseFrequency",
          "numOctaves",
          "seed",
          "stitchTiles",
          "type"
        ],
        defaults: {
          baseFrequency: "0",
          numOctaves: "1",
          seed: "0",
          stitchTiles: "noStitch",
          type: "turbulence"
        },
        content: ["animate", "set"]
      },
      filter: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x",
          "y",
          "width",
          "height",
          "filterRes",
          "filterUnits",
          "primitiveUnits",
          "href",
          "xlink:href"
        ],
        defaults: {
          primitiveUnits: "userSpaceOnUse",
          x: "-10%",
          y: "-10%",
          width: "120%",
          height: "120%"
        },
        contentGroups: ["descriptive", "filterPrimitive"],
        content: ["animate", "set"]
      },
      font: {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "horiz-origin-x",
          "horiz-origin-y",
          "horiz-adv-x",
          "vert-origin-x",
          "vert-origin-y",
          "vert-adv-y"
        ],
        defaults: {
          "horiz-origin-x": "0",
          "horiz-origin-y": "0"
        },
        contentGroups: ["descriptive"],
        content: ["font-face", "glyph", "hkern", "missing-glyph", "vkern"]
      },
      "font-face": {
        attrsGroups: ["core"],
        attrs: [
          "font-family",
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "unicode-range",
          "units-per-em",
          "panose-1",
          "stemv",
          "stemh",
          "slope",
          "cap-height",
          "x-height",
          "accent-height",
          "ascent",
          "descent",
          "widths",
          "bbox",
          "ideographic",
          "alphabetic",
          "mathematical",
          "hanging",
          "v-ideographic",
          "v-alphabetic",
          "v-mathematical",
          "v-hanging",
          "underline-position",
          "underline-thickness",
          "strikethrough-position",
          "strikethrough-thickness",
          "overline-position",
          "overline-thickness"
        ],
        defaults: {
          "font-style": "all",
          "font-variant": "normal",
          "font-weight": "all",
          "font-stretch": "normal",
          "unicode-range": "U+0-10FFFF",
          "units-per-em": "1000",
          "panose-1": "0 0 0 0 0 0 0 0 0 0",
          slope: "0"
        },
        contentGroups: ["descriptive"],
        content: [
          // TODO: "at most one 'font-face-src' element"
          "font-face-src"
        ]
      },
      // TODO: empty content
      "font-face-format": {
        attrsGroups: ["core"],
        attrs: ["string"]
      },
      "font-face-name": {
        attrsGroups: ["core"],
        attrs: ["name"]
      },
      "font-face-src": {
        attrsGroups: ["core"],
        content: ["font-face-name", "font-face-uri"]
      },
      "font-face-uri": {
        attrsGroups: ["core", "xlink"],
        attrs: ["href", "xlink:href"],
        content: ["font-face-format"]
      },
      foreignObject: {
        attrsGroups: [
          "core",
          "conditionalProcessing",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "x",
          "y",
          "width",
          "height"
        ],
        defaults: {
          x: "0",
          y: "0"
        }
      },
      g: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: ["class", "style", "externalResourcesRequired", "transform"],
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      glyph: {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "d",
          "horiz-adv-x",
          "vert-origin-x",
          "vert-origin-y",
          "vert-adv-y",
          "unicode",
          "glyph-name",
          "orientation",
          "arabic-form",
          "lang"
        ],
        defaults: {
          "arabic-form": "initial"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      glyphRef: {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "d",
          "horiz-adv-x",
          "vert-origin-x",
          "vert-origin-y",
          "vert-adv-y"
        ],
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      hatch: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "x",
          "y",
          "pitch",
          "rotate",
          "hatchUnits",
          "hatchContentUnits",
          "transform"
        ],
        defaults: {
          hatchUnits: "objectBoundingBox",
          hatchContentUnits: "userSpaceOnUse",
          x: "0",
          y: "0",
          pitch: "0",
          rotate: "0"
        },
        contentGroups: ["animation", "descriptive"],
        content: ["hatchPath"]
      },
      hatchPath: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: ["class", "style", "d", "offset"],
        defaults: {
          offset: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      hkern: {
        attrsGroups: ["core"],
        attrs: ["u1", "g1", "u2", "g2", "k"]
      },
      image: {
        attrsGroups: [
          "core",
          "conditionalProcessing",
          "graphicalEvent",
          "xlink",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "preserveAspectRatio",
          "transform",
          "x",
          "y",
          "width",
          "height",
          "href",
          "xlink:href"
        ],
        defaults: {
          x: "0",
          y: "0",
          preserveAspectRatio: "xMidYMid meet"
        },
        contentGroups: ["animation", "descriptive"]
      },
      line: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "x1",
          "y1",
          "x2",
          "y2"
        ],
        defaults: {
          x1: "0",
          y1: "0",
          x2: "0",
          y2: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      linearGradient: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x1",
          "y1",
          "x2",
          "y2",
          "gradientUnits",
          "gradientTransform",
          "spreadMethod",
          "href",
          "xlink:href"
        ],
        defaults: {
          x1: "0",
          y1: "0",
          x2: "100%",
          y2: "0",
          spreadMethod: "pad"
        },
        contentGroups: ["descriptive"],
        content: ["animate", "animateTransform", "set", "stop"]
      },
      marker: {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "viewBox",
          "preserveAspectRatio",
          "refX",
          "refY",
          "markerUnits",
          "markerWidth",
          "markerHeight",
          "orient"
        ],
        defaults: {
          markerUnits: "strokeWidth",
          refX: "0",
          refY: "0",
          markerWidth: "3",
          markerHeight: "3"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      mask: {
        attrsGroups: ["conditionalProcessing", "core", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x",
          "y",
          "width",
          "height",
          "mask-type",
          "maskUnits",
          "maskContentUnits"
        ],
        defaults: {
          maskUnits: "objectBoundingBox",
          maskContentUnits: "userSpaceOnUse",
          x: "-10%",
          y: "-10%",
          width: "120%",
          height: "120%"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      metadata: {
        attrsGroups: ["core"]
      },
      "missing-glyph": {
        attrsGroups: ["core", "presentation"],
        attrs: [
          "class",
          "style",
          "d",
          "horiz-adv-x",
          "vert-origin-x",
          "vert-origin-y",
          "vert-adv-y"
        ],
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      mpath: {
        attrsGroups: ["core", "xlink"],
        attrs: ["externalResourcesRequired", "href", "xlink:href"],
        contentGroups: ["descriptive"]
      },
      path: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "d",
          "pathLength"
        ],
        contentGroups: ["animation", "descriptive"]
      },
      pattern: {
        attrsGroups: ["conditionalProcessing", "core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "viewBox",
          "preserveAspectRatio",
          "x",
          "y",
          "width",
          "height",
          "patternUnits",
          "patternContentUnits",
          "patternTransform",
          "href",
          "xlink:href"
        ],
        defaults: {
          patternUnits: "objectBoundingBox",
          patternContentUnits: "userSpaceOnUse",
          x: "0",
          y: "0",
          width: "0",
          height: "0",
          preserveAspectRatio: "xMidYMid meet"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      polygon: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "points"
        ],
        contentGroups: ["animation", "descriptive"]
      },
      polyline: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "points"
        ],
        contentGroups: ["animation", "descriptive"]
      },
      radialGradient: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "cx",
          "cy",
          "r",
          "fx",
          "fy",
          "fr",
          "gradientUnits",
          "gradientTransform",
          "spreadMethod",
          "href",
          "xlink:href"
        ],
        defaults: {
          gradientUnits: "objectBoundingBox",
          cx: "50%",
          cy: "50%",
          r: "50%"
        },
        contentGroups: ["descriptive"],
        content: ["animate", "animateTransform", "set", "stop"]
      },
      meshGradient: {
        attrsGroups: ["core", "presentation", "xlink"],
        attrs: ["class", "style", "x", "y", "gradientUnits", "transform"],
        contentGroups: ["descriptive", "paintServer", "animation"],
        content: ["meshRow"]
      },
      meshRow: {
        attrsGroups: ["core", "presentation"],
        attrs: ["class", "style"],
        contentGroups: ["descriptive"],
        content: ["meshPatch"]
      },
      meshPatch: {
        attrsGroups: ["core", "presentation"],
        attrs: ["class", "style"],
        contentGroups: ["descriptive"],
        content: ["stop"]
      },
      rect: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "x",
          "y",
          "width",
          "height",
          "rx",
          "ry"
        ],
        defaults: {
          x: "0",
          y: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      script: {
        attrsGroups: ["core", "xlink"],
        attrs: ["externalResourcesRequired", "type", "href", "xlink:href"]
      },
      set: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "animation",
          "xlink",
          "animationAttributeTarget",
          "animationTiming"
        ],
        attrs: ["externalResourcesRequired", "to"],
        contentGroups: ["descriptive"]
      },
      solidColor: {
        attrsGroups: ["core", "presentation"],
        attrs: ["class", "style"],
        contentGroups: ["paintServer"]
      },
      stop: {
        attrsGroups: ["core", "presentation"],
        attrs: ["class", "style", "offset", "path"],
        content: ["animate", "animateColor", "set"]
      },
      style: {
        attrsGroups: ["core"],
        attrs: ["type", "media", "title"],
        defaults: {
          type: "text/css"
        }
      },
      svg: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "documentEvent",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "x",
          "y",
          "width",
          "height",
          "viewBox",
          "preserveAspectRatio",
          "zoomAndPan",
          "version",
          "baseProfile",
          "contentScriptType",
          "contentStyleType"
        ],
        defaults: {
          x: "0",
          y: "0",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid meet",
          zoomAndPan: "magnify",
          version: "1.1",
          baseProfile: "none",
          contentScriptType: "application/ecmascript",
          contentStyleType: "text/css"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      switch: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: ["class", "style", "externalResourcesRequired", "transform"],
        contentGroups: ["animation", "descriptive", "shape"],
        content: [
          "a",
          "foreignObject",
          "g",
          "image",
          "svg",
          "switch",
          "text",
          "use"
        ]
      },
      symbol: {
        attrsGroups: ["core", "graphicalEvent", "presentation"],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "preserveAspectRatio",
          "viewBox",
          "refX",
          "refY"
        ],
        defaults: {
          refX: "0",
          refY: "0"
        },
        contentGroups: [
          "animation",
          "descriptive",
          "shape",
          "structural",
          "paintServer"
        ],
        content: [
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font",
          "font-face",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ]
      },
      text: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "lengthAdjust",
          "x",
          "y",
          "dx",
          "dy",
          "rotate",
          "textLength"
        ],
        defaults: {
          x: "0",
          y: "0",
          lengthAdjust: "spacing"
        },
        contentGroups: ["animation", "descriptive", "textContentChild"],
        content: ["a"]
      },
      textPath: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "href",
          "xlink:href",
          "startOffset",
          "method",
          "spacing",
          "d"
        ],
        defaults: {
          startOffset: "0",
          method: "align",
          spacing: "exact"
        },
        contentGroups: ["descriptive"],
        content: [
          "a",
          "altGlyph",
          "animate",
          "animateColor",
          "set",
          "tref",
          "tspan"
        ]
      },
      title: {
        attrsGroups: ["core"],
        attrs: ["class", "style"]
      },
      tref: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "href",
          "xlink:href"
        ],
        contentGroups: ["descriptive"],
        content: ["animate", "animateColor", "set"]
      },
      tspan: {
        attrsGroups: [
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "x",
          "y",
          "dx",
          "dy",
          "rotate",
          "textLength",
          "lengthAdjust"
        ],
        contentGroups: ["descriptive"],
        content: [
          "a",
          "altGlyph",
          "animate",
          "animateColor",
          "set",
          "tref",
          "tspan"
        ]
      },
      use: {
        attrsGroups: [
          "core",
          "conditionalProcessing",
          "graphicalEvent",
          "presentation",
          "xlink"
        ],
        attrs: [
          "class",
          "style",
          "externalResourcesRequired",
          "transform",
          "x",
          "y",
          "width",
          "height",
          "href",
          "xlink:href"
        ],
        defaults: {
          x: "0",
          y: "0"
        },
        contentGroups: ["animation", "descriptive"]
      },
      view: {
        attrsGroups: ["core"],
        attrs: [
          "externalResourcesRequired",
          "viewBox",
          "preserveAspectRatio",
          "zoomAndPan",
          "viewTarget"
        ],
        contentGroups: ["descriptive"]
      },
      vkern: {
        attrsGroups: ["core"],
        attrs: ["u1", "g1", "u2", "g2", "k"]
      }
    };
    exports2.editorNamespaces = [
      "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
      "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd",
      "http://www.inkscape.org/namespaces/inkscape",
      "http://www.bohemiancoding.com/sketch/ns",
      "http://ns.adobe.com/AdobeIllustrator/10.0/",
      "http://ns.adobe.com/Graphs/1.0/",
      "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/",
      "http://ns.adobe.com/Variables/1.0/",
      "http://ns.adobe.com/SaveForWeb/1.0/",
      "http://ns.adobe.com/Extensibility/1.0/",
      "http://ns.adobe.com/Flows/1.0/",
      "http://ns.adobe.com/ImageReplacement/1.0/",
      "http://ns.adobe.com/GenericCustomNamespace/1.0/",
      "http://ns.adobe.com/XPath/1.0/",
      "http://schemas.microsoft.com/visio/2003/SVGExtensions/",
      "http://taptrix.com/vectorillustrator/svg_extensions",
      "http://www.figma.com/figma/ns",
      "http://purl.org/dc/elements/1.1/",
      "http://creativecommons.org/ns#",
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
      "http://www.serif.com/",
      "http://www.vector.evaxdesign.sk"
    ];
    exports2.referencesProps = [
      "clip-path",
      "color-profile",
      "fill",
      "filter",
      "marker-start",
      "marker-mid",
      "marker-end",
      "mask",
      "stroke",
      "style"
    ];
    exports2.inheritableAttrs = [
      "clip-rule",
      "color",
      "color-interpolation",
      "color-interpolation-filters",
      "color-profile",
      "color-rendering",
      "cursor",
      "direction",
      "dominant-baseline",
      "fill",
      "fill-opacity",
      "fill-rule",
      "font",
      "font-family",
      "font-size",
      "font-size-adjust",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "image-rendering",
      "letter-spacing",
      "marker",
      "marker-end",
      "marker-mid",
      "marker-start",
      "paint-order",
      "pointer-events",
      "shape-rendering",
      "stroke",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "text-anchor",
      "text-rendering",
      "transform",
      "visibility",
      "word-spacing",
      "writing-mode"
    ];
    exports2.presentationNonInheritableGroupAttrs = [
      "display",
      "clip-path",
      "filter",
      "mask",
      "opacity",
      "text-decoration",
      "transform",
      "unicode-bidi"
    ];
    exports2.colorsNames = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#0ff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000",
      blanchedalmond: "#ffebcd",
      blue: "#00f",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#0ff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#f0f",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#789",
      lightslategrey: "#789",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#0f0",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#f0f",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#639",
      red: "#f00",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#fff",
      whitesmoke: "#f5f5f5",
      yellow: "#ff0",
      yellowgreen: "#9acd32"
    };
    exports2.colorsShortNames = {
      "#f0ffff": "azure",
      "#f5f5dc": "beige",
      "#ffe4c4": "bisque",
      "#a52a2a": "brown",
      "#ff7f50": "coral",
      "#ffd700": "gold",
      "#808080": "gray",
      "#008000": "green",
      "#4b0082": "indigo",
      "#fffff0": "ivory",
      "#f0e68c": "khaki",
      "#faf0e6": "linen",
      "#800000": "maroon",
      "#000080": "navy",
      "#808000": "olive",
      "#ffa500": "orange",
      "#da70d6": "orchid",
      "#cd853f": "peru",
      "#ffc0cb": "pink",
      "#dda0dd": "plum",
      "#800080": "purple",
      "#f00": "red",
      "#ff0000": "red",
      "#fa8072": "salmon",
      "#a0522d": "sienna",
      "#c0c0c0": "silver",
      "#fffafa": "snow",
      "#d2b48c": "tan",
      "#008080": "teal",
      "#ff6347": "tomato",
      "#ee82ee": "violet",
      "#f5deb3": "wheat"
    };
    exports2.colorsProps = [
      "color",
      "fill",
      "stroke",
      "stop-color",
      "flood-color",
      "lighting-color"
    ];
  }
});

// node_modules/svgo/plugins/removeEditorsNSData.js
var require_removeEditorsNSData = __commonJS({
  "node_modules/svgo/plugins/removeEditorsNSData.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { editorNamespaces } = require_collections();
    exports2.type = "visitor";
    exports2.name = "removeEditorsNSData";
    exports2.active = true;
    exports2.description = "removes editors namespaces, elements and attributes";
    exports2.fn = (_root, params) => {
      let namespaces = editorNamespaces;
      if (Array.isArray(params.additionalNamespaces)) {
        namespaces = [...editorNamespaces, ...params.additionalNamespaces];
      }
      const prefixes = [];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg") {
              for (const [name, value] of Object.entries(node.attributes)) {
                if (name.startsWith("xmlns:") && namespaces.includes(value)) {
                  prefixes.push(name.slice("xmlns:".length));
                  delete node.attributes[name];
                }
              }
            }
            for (const name of Object.keys(node.attributes)) {
              if (name.includes(":")) {
                const [prefix] = name.split(":");
                if (prefixes.includes(prefix)) {
                  delete node.attributes[name];
                }
              }
            }
            if (node.name.includes(":")) {
              const [prefix] = node.name.split(":");
              if (prefixes.includes(prefix)) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupAttrs.js
var require_cleanupAttrs = __commonJS({
  "node_modules/svgo/plugins/cleanupAttrs.js"(exports2) {
    "use strict";
    exports2.name = "cleanupAttrs";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "cleanups attributes from newlines, trailing and repeating spaces";
    var regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
    var regNewlines = /\r?\n/g;
    var regSpaces = /\s{2,}/g;
    exports2.fn = (root, params) => {
      const { newlines = true, trim = true, spaces = true } = params;
      return {
        element: {
          enter: (node) => {
            for (const name of Object.keys(node.attributes)) {
              if (newlines) {
                node.attributes[name] = node.attributes[name].replace(
                  regNewlinesNeedSpace,
                  (match, p1, p2) => p1 + " " + p2
                );
                node.attributes[name] = node.attributes[name].replace(
                  regNewlines,
                  ""
                );
              }
              if (trim) {
                node.attributes[name] = node.attributes[name].trim();
              }
              if (spaces) {
                node.attributes[name] = node.attributes[name].replace(
                  regSpaces,
                  " "
                );
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/lib/svgo/css-class-list.js
var require_css_class_list = __commonJS({
  "node_modules/svgo/lib/svgo/css-class-list.js"(exports2, module2) {
    "use strict";
    var CSSClassList = function(node) {
      this.parentNode = node;
      this.classNames = /* @__PURE__ */ new Set();
      const value = node.attributes.class;
      if (value != null) {
        this.addClassValueHandler();
        this.setClassValue(value);
      }
    };
    CSSClassList.prototype.addClassValueHandler = function() {
      Object.defineProperty(this.parentNode.attributes, "class", {
        get: this.getClassValue.bind(this),
        set: this.setClassValue.bind(this),
        enumerable: true,
        configurable: true
      });
    };
    CSSClassList.prototype.getClassValue = function() {
      var arrClassNames = Array.from(this.classNames);
      return arrClassNames.join(" ");
    };
    CSSClassList.prototype.setClassValue = function(newValue) {
      if (typeof newValue === "undefined") {
        this.classNames.clear();
        return;
      }
      var arrClassNames = newValue.split(" ");
      this.classNames = new Set(arrClassNames);
    };
    CSSClassList.prototype.add = function() {
      this.addClassValueHandler();
      Object.values(arguments).forEach(this._addSingle.bind(this));
    };
    CSSClassList.prototype._addSingle = function(className) {
      this.classNames.add(className);
    };
    CSSClassList.prototype.remove = function() {
      this.addClassValueHandler();
      Object.values(arguments).forEach(this._removeSingle.bind(this));
    };
    CSSClassList.prototype._removeSingle = function(className) {
      this.classNames.delete(className);
    };
    CSSClassList.prototype.item = function(index) {
      var arrClassNames = Array.from(this.classNames);
      return arrClassNames[index];
    };
    CSSClassList.prototype.toggle = function(className, force) {
      if (this.contains(className) || force === false) {
        this.classNames.delete(className);
      }
      this.classNames.add(className);
    };
    CSSClassList.prototype.contains = function(className) {
      return this.classNames.has(className);
    };
    module2.exports = CSSClassList;
  }
});

// node_modules/css-tree/lib/common/List.js
var require_List = __commonJS({
  "node_modules/css-tree/lib/common/List.js"(exports2, module2) {
    function createItem(data) {
      return {
        prev: null,
        next: null,
        data
      };
    }
    function allocateCursor(node, prev, next) {
      var cursor;
      if (cursors !== null) {
        cursor = cursors;
        cursors = cursors.cursor;
        cursor.prev = prev;
        cursor.next = next;
        cursor.cursor = node.cursor;
      } else {
        cursor = {
          prev,
          next,
          cursor: node.cursor
        };
      }
      node.cursor = cursor;
      return cursor;
    }
    function releaseCursor(node) {
      var cursor = node.cursor;
      node.cursor = cursor.cursor;
      cursor.prev = null;
      cursor.next = null;
      cursor.cursor = cursors;
      cursors = cursor;
    }
    var cursors = null;
    var List = function() {
      this.cursor = null;
      this.head = null;
      this.tail = null;
    };
    List.createItem = createItem;
    List.prototype.createItem = createItem;
    List.prototype.updateCursors = function(prevOld, prevNew, nextOld, nextNew) {
      var cursor = this.cursor;
      while (cursor !== null) {
        if (cursor.prev === prevOld) {
          cursor.prev = prevNew;
        }
        if (cursor.next === nextOld) {
          cursor.next = nextNew;
        }
        cursor = cursor.cursor;
      }
    };
    List.prototype.getSize = function() {
      var size = 0;
      var cursor = this.head;
      while (cursor) {
        size++;
        cursor = cursor.next;
      }
      return size;
    };
    List.prototype.fromArray = function(array) {
      var cursor = null;
      this.head = null;
      for (var i = 0; i < array.length; i++) {
        var item = createItem(array[i]);
        if (cursor !== null) {
          cursor.next = item;
        } else {
          this.head = item;
        }
        item.prev = cursor;
        cursor = item;
      }
      this.tail = cursor;
      return this;
    };
    List.prototype.toArray = function() {
      var cursor = this.head;
      var result = [];
      while (cursor) {
        result.push(cursor.data);
        cursor = cursor.next;
      }
      return result;
    };
    List.prototype.toJSON = List.prototype.toArray;
    List.prototype.isEmpty = function() {
      return this.head === null;
    };
    List.prototype.first = function() {
      return this.head && this.head.data;
    };
    List.prototype.last = function() {
      return this.tail && this.tail.data;
    };
    List.prototype.each = function(fn, context) {
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, null, this.head);
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        fn.call(context, item.data, item, this);
      }
      releaseCursor(this);
    };
    List.prototype.forEach = List.prototype.each;
    List.prototype.eachRight = function(fn, context) {
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, this.tail, null);
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        fn.call(context, item.data, item, this);
      }
      releaseCursor(this);
    };
    List.prototype.forEachRight = List.prototype.eachRight;
    List.prototype.reduce = function(fn, initialValue, context) {
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, null, this.head);
      var acc = initialValue;
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        acc = fn.call(context, acc, item.data, item, this);
      }
      releaseCursor(this);
      return acc;
    };
    List.prototype.reduceRight = function(fn, initialValue, context) {
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, this.tail, null);
      var acc = initialValue;
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        acc = fn.call(context, acc, item.data, item, this);
      }
      releaseCursor(this);
      return acc;
    };
    List.prototype.nextUntil = function(start, fn, context) {
      if (start === null) {
        return;
      }
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, null, start);
      while (cursor.next !== null) {
        item = cursor.next;
        cursor.next = item.next;
        if (fn.call(context, item.data, item, this)) {
          break;
        }
      }
      releaseCursor(this);
    };
    List.prototype.prevUntil = function(start, fn, context) {
      if (start === null) {
        return;
      }
      var item;
      if (context === void 0) {
        context = this;
      }
      var cursor = allocateCursor(this, start, null);
      while (cursor.prev !== null) {
        item = cursor.prev;
        cursor.prev = item.prev;
        if (fn.call(context, item.data, item, this)) {
          break;
        }
      }
      releaseCursor(this);
    };
    List.prototype.some = function(fn, context) {
      var cursor = this.head;
      if (context === void 0) {
        context = this;
      }
      while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
          return true;
        }
        cursor = cursor.next;
      }
      return false;
    };
    List.prototype.map = function(fn, context) {
      var result = new List();
      var cursor = this.head;
      if (context === void 0) {
        context = this;
      }
      while (cursor !== null) {
        result.appendData(fn.call(context, cursor.data, cursor, this));
        cursor = cursor.next;
      }
      return result;
    };
    List.prototype.filter = function(fn, context) {
      var result = new List();
      var cursor = this.head;
      if (context === void 0) {
        context = this;
      }
      while (cursor !== null) {
        if (fn.call(context, cursor.data, cursor, this)) {
          result.appendData(cursor.data);
        }
        cursor = cursor.next;
      }
      return result;
    };
    List.prototype.clear = function() {
      this.head = null;
      this.tail = null;
    };
    List.prototype.copy = function() {
      var result = new List();
      var cursor = this.head;
      while (cursor !== null) {
        result.insert(createItem(cursor.data));
        cursor = cursor.next;
      }
      return result;
    };
    List.prototype.prepend = function(item) {
      this.updateCursors(null, item, this.head, item);
      if (this.head !== null) {
        this.head.prev = item;
        item.next = this.head;
      } else {
        this.tail = item;
      }
      this.head = item;
      return this;
    };
    List.prototype.prependData = function(data) {
      return this.prepend(createItem(data));
    };
    List.prototype.append = function(item) {
      return this.insert(item);
    };
    List.prototype.appendData = function(data) {
      return this.insert(createItem(data));
    };
    List.prototype.insert = function(item, before) {
      if (before !== void 0 && before !== null) {
        this.updateCursors(before.prev, item, before, item);
        if (before.prev === null) {
          if (this.head !== before) {
            throw new Error("before doesn't belong to list");
          }
          this.head = item;
          before.prev = item;
          item.next = before;
          this.updateCursors(null, item);
        } else {
          before.prev.next = item;
          item.prev = before.prev;
          before.prev = item;
          item.next = before;
        }
      } else {
        this.updateCursors(this.tail, item, null, item);
        if (this.tail !== null) {
          this.tail.next = item;
          item.prev = this.tail;
        } else {
          this.head = item;
        }
        this.tail = item;
      }
      return this;
    };
    List.prototype.insertData = function(data, before) {
      return this.insert(createItem(data), before);
    };
    List.prototype.remove = function(item) {
      this.updateCursors(item, item.prev, item, item.next);
      if (item.prev !== null) {
        item.prev.next = item.next;
      } else {
        if (this.head !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.head = item.next;
      }
      if (item.next !== null) {
        item.next.prev = item.prev;
      } else {
        if (this.tail !== item) {
          throw new Error("item doesn't belong to list");
        }
        this.tail = item.prev;
      }
      item.prev = null;
      item.next = null;
      return item;
    };
    List.prototype.push = function(data) {
      this.insert(createItem(data));
    };
    List.prototype.pop = function() {
      if (this.tail !== null) {
        return this.remove(this.tail);
      }
    };
    List.prototype.unshift = function(data) {
      this.prepend(createItem(data));
    };
    List.prototype.shift = function() {
      if (this.head !== null) {
        return this.remove(this.head);
      }
    };
    List.prototype.prependList = function(list) {
      return this.insertList(list, this.head);
    };
    List.prototype.appendList = function(list) {
      return this.insertList(list);
    };
    List.prototype.insertList = function(list, before) {
      if (list.head === null) {
        return this;
      }
      if (before !== void 0 && before !== null) {
        this.updateCursors(before.prev, list.tail, before, list.head);
        if (before.prev !== null) {
          before.prev.next = list.head;
          list.head.prev = before.prev;
        } else {
          this.head = list.head;
        }
        before.prev = list.tail;
        list.tail.next = before;
      } else {
        this.updateCursors(this.tail, list.tail, null, list.head);
        if (this.tail !== null) {
          this.tail.next = list.head;
          list.head.prev = this.tail;
        } else {
          this.head = list.head;
        }
        this.tail = list.tail;
      }
      list.head = null;
      list.tail = null;
      return this;
    };
    List.prototype.replace = function(oldItem, newItemOrList) {
      if ("head" in newItemOrList) {
        this.insertList(newItemOrList, oldItem);
      } else {
        this.insert(newItemOrList, oldItem);
      }
      this.remove(oldItem);
    };
    module2.exports = List;
  }
});

// node_modules/css-tree/lib/utils/createCustomError.js
var require_createCustomError = __commonJS({
  "node_modules/css-tree/lib/utils/createCustomError.js"(exports2, module2) {
    module2.exports = function createCustomError(name, message) {
      var error = Object.create(SyntaxError.prototype);
      var errorStack = new Error();
      error.name = name;
      error.message = message;
      Object.defineProperty(error, "stack", {
        get: function() {
          return (errorStack.stack || "").replace(/^(.+\n){1,3}/, name + ": " + message + "\n");
        }
      });
      return error;
    };
  }
});

// node_modules/css-tree/lib/common/SyntaxError.js
var require_SyntaxError = __commonJS({
  "node_modules/css-tree/lib/common/SyntaxError.js"(exports2, module2) {
    var createCustomError = require_createCustomError();
    var MAX_LINE_LENGTH = 100;
    var OFFSET_CORRECTION = 60;
    var TAB_REPLACEMENT = "    ";
    function sourceFragment(error, extraLines) {
      function processLines(start, end) {
        return lines.slice(start, end).map(function(line2, idx) {
          var num = String(start + idx + 1);
          while (num.length < maxNumLength) {
            num = " " + num;
          }
          return num + " |" + line2;
        }).join("\n");
      }
      var lines = error.source.split(/\r\n?|\n|\f/);
      var line = error.line;
      var column = error.column;
      var startLine = Math.max(1, line - extraLines) - 1;
      var endLine = Math.min(line + extraLines, lines.length + 1);
      var maxNumLength = Math.max(4, String(endLine).length) + 1;
      var cutLeft = 0;
      column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
      if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
      }
      for (var i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
          lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
          lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
        }
      }
      return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join("-") + "^",
        processLines(line, endLine)
      ].filter(Boolean).join("\n");
    }
    var SyntaxError2 = function(message, source, offset, line, column) {
      var error = createCustomError("SyntaxError", message);
      error.source = source;
      error.offset = offset;
      error.line = line;
      error.column = column;
      error.sourceFragment = function(extraLines) {
        return sourceFragment(error, isNaN(extraLines) ? 0 : extraLines);
      };
      Object.defineProperty(error, "formattedMessage", {
        get: function() {
          return "Parse error: " + error.message + "\n" + sourceFragment(error, 2);
        }
      });
      error.parseError = {
        offset,
        line,
        column
      };
      return error;
    };
    module2.exports = SyntaxError2;
  }
});

// node_modules/css-tree/lib/tokenizer/const.js
var require_const = __commonJS({
  "node_modules/css-tree/lib/tokenizer/const.js"(exports2, module2) {
    var TYPE = {
      EOF: 0,
      // <EOF-token>
      Ident: 1,
      // <ident-token>
      Function: 2,
      // <function-token>
      AtKeyword: 3,
      // <at-keyword-token>
      Hash: 4,
      // <hash-token>
      String: 5,
      // <string-token>
      BadString: 6,
      // <bad-string-token>
      Url: 7,
      // <url-token>
      BadUrl: 8,
      // <bad-url-token>
      Delim: 9,
      // <delim-token>
      Number: 10,
      // <number-token>
      Percentage: 11,
      // <percentage-token>
      Dimension: 12,
      // <dimension-token>
      WhiteSpace: 13,
      // <whitespace-token>
      CDO: 14,
      // <CDO-token>
      CDC: 15,
      // <CDC-token>
      Colon: 16,
      // <colon-token>     :
      Semicolon: 17,
      // <semicolon-token> ;
      Comma: 18,
      // <comma-token>     ,
      LeftSquareBracket: 19,
      // <[-token>
      RightSquareBracket: 20,
      // <]-token>
      LeftParenthesis: 21,
      // <(-token>
      RightParenthesis: 22,
      // <)-token>
      LeftCurlyBracket: 23,
      // <{-token>
      RightCurlyBracket: 24,
      // <}-token>
      Comment: 25
    };
    var NAME = Object.keys(TYPE).reduce(function(result, key) {
      result[TYPE[key]] = key;
      return result;
    }, {});
    module2.exports = {
      TYPE,
      NAME
    };
  }
});

// node_modules/css-tree/lib/tokenizer/char-code-definitions.js
var require_char_code_definitions = __commonJS({
  "node_modules/css-tree/lib/tokenizer/char-code-definitions.js"(exports2, module2) {
    var EOF = 0;
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isHexDigit(code) {
      return isDigit(code) || // 0 .. 9
      code >= 65 && code <= 70 || // A .. F
      code >= 97 && code <= 102;
    }
    function isUppercaseLetter(code) {
      return code >= 65 && code <= 90;
    }
    function isLowercaseLetter(code) {
      return code >= 97 && code <= 122;
    }
    function isLetter(code) {
      return isUppercaseLetter(code) || isLowercaseLetter(code);
    }
    function isNonAscii(code) {
      return code >= 128;
    }
    function isNameStart(code) {
      return isLetter(code) || isNonAscii(code) || code === 95;
    }
    function isName(code) {
      return isNameStart(code) || isDigit(code) || code === 45;
    }
    function isNonPrintable(code) {
      return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
    }
    function isNewline(code) {
      return code === 10 || code === 13 || code === 12;
    }
    function isWhiteSpace(code) {
      return isNewline(code) || code === 32 || code === 9;
    }
    function isValidEscape(first, second) {
      if (first !== 92) {
        return false;
      }
      if (isNewline(second) || second === EOF) {
        return false;
      }
      return true;
    }
    function isIdentifierStart(first, second, third) {
      if (first === 45) {
        return isNameStart(second) || second === 45 || isValidEscape(second, third);
      }
      if (isNameStart(first)) {
        return true;
      }
      if (first === 92) {
        return isValidEscape(first, second);
      }
      return false;
    }
    function isNumberStart(first, second, third) {
      if (first === 43 || first === 45) {
        if (isDigit(second)) {
          return 2;
        }
        return second === 46 && isDigit(third) ? 3 : 0;
      }
      if (first === 46) {
        return isDigit(second) ? 2 : 0;
      }
      if (isDigit(first)) {
        return 1;
      }
      return 0;
    }
    function isBOM(code) {
      if (code === 65279) {
        return 1;
      }
      if (code === 65534) {
        return 1;
      }
      return 0;
    }
    var CATEGORY = new Array(128);
    charCodeCategory.Eof = 128;
    charCodeCategory.WhiteSpace = 130;
    charCodeCategory.Digit = 131;
    charCodeCategory.NameStart = 132;
    charCodeCategory.NonPrintable = 133;
    for (i = 0; i < CATEGORY.length; i++) {
      switch (true) {
        case isWhiteSpace(i):
          CATEGORY[i] = charCodeCategory.WhiteSpace;
          break;
        case isDigit(i):
          CATEGORY[i] = charCodeCategory.Digit;
          break;
        case isNameStart(i):
          CATEGORY[i] = charCodeCategory.NameStart;
          break;
        case isNonPrintable(i):
          CATEGORY[i] = charCodeCategory.NonPrintable;
          break;
        default:
          CATEGORY[i] = i || charCodeCategory.Eof;
      }
    }
    var i;
    function charCodeCategory(code) {
      return code < 128 ? CATEGORY[code] : charCodeCategory.NameStart;
    }
    module2.exports = {
      isDigit,
      isHexDigit,
      isUppercaseLetter,
      isLowercaseLetter,
      isLetter,
      isNonAscii,
      isNameStart,
      isName,
      isNonPrintable,
      isNewline,
      isWhiteSpace,
      isValidEscape,
      isIdentifierStart,
      isNumberStart,
      isBOM,
      charCodeCategory
    };
  }
});

// node_modules/css-tree/lib/tokenizer/utils.js
var require_utils = __commonJS({
  "node_modules/css-tree/lib/tokenizer/utils.js"(exports2, module2) {
    var charCodeDef = require_char_code_definitions();
    var isDigit = charCodeDef.isDigit;
    var isHexDigit = charCodeDef.isHexDigit;
    var isUppercaseLetter = charCodeDef.isUppercaseLetter;
    var isName = charCodeDef.isName;
    var isWhiteSpace = charCodeDef.isWhiteSpace;
    var isValidEscape = charCodeDef.isValidEscape;
    function getCharCode(source, offset) {
      return offset < source.length ? source.charCodeAt(offset) : 0;
    }
    function getNewlineLength(source, offset, code) {
      if (code === 13 && getCharCode(source, offset + 1) === 10) {
        return 2;
      }
      return 1;
    }
    function cmpChar(testStr, offset, referenceCode) {
      var code = testStr.charCodeAt(offset);
      if (isUppercaseLetter(code)) {
        code = code | 32;
      }
      return code === referenceCode;
    }
    function cmpStr(testStr, start, end, referenceStr) {
      if (end - start !== referenceStr.length) {
        return false;
      }
      if (start < 0 || end > testStr.length) {
        return false;
      }
      for (var i = start; i < end; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i - start);
        if (isUppercaseLetter(testCode)) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function findWhiteSpaceStart(source, offset) {
      for (; offset >= 0; offset--) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset + 1;
    }
    function findWhiteSpaceEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function findDecimalNumberEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!isDigit(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function consumeEscaped(source, offset) {
      offset += 2;
      if (isHexDigit(getCharCode(source, offset - 1))) {
        for (var maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
          if (!isHexDigit(getCharCode(source, offset))) {
            break;
          }
        }
        var code = getCharCode(source, offset);
        if (isWhiteSpace(code)) {
          offset += getNewlineLength(source, offset, code);
        }
      }
      return offset;
    }
    function consumeName(source, offset) {
      for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);
        if (isName(code)) {
          continue;
        }
        if (isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset) - 1;
          continue;
        }
        break;
      }
      return offset;
    }
    function consumeNumber(source, offset) {
      var code = source.charCodeAt(offset);
      if (code === 43 || code === 45) {
        code = source.charCodeAt(offset += 1);
      }
      if (isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
      }
      if (code === 46 && isDigit(source.charCodeAt(offset + 1))) {
        code = source.charCodeAt(offset += 2);
        offset = findDecimalNumberEnd(source, offset);
      }
      if (cmpChar(
        source,
        offset,
        101
        /* e */
      )) {
        var sign = 0;
        code = source.charCodeAt(offset + 1);
        if (code === 45 || code === 43) {
          sign = 1;
          code = source.charCodeAt(offset + 2);
        }
        if (isDigit(code)) {
          offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
      }
      return offset;
    }
    function consumeBadUrlRemnants(source, offset) {
      for (; offset < source.length; offset++) {
        var code = source.charCodeAt(offset);
        if (code === 41) {
          offset++;
          break;
        }
        if (isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset);
        }
      }
      return offset;
    }
    module2.exports = {
      consumeEscaped,
      consumeName,
      consumeNumber,
      consumeBadUrlRemnants,
      cmpChar,
      cmpStr,
      getNewlineLength,
      findWhiteSpaceStart,
      findWhiteSpaceEnd
    };
  }
});

// node_modules/css-tree/lib/common/TokenStream.js
var require_TokenStream = __commonJS({
  "node_modules/css-tree/lib/common/TokenStream.js"(exports2, module2) {
    var constants = require_const();
    var TYPE = constants.TYPE;
    var NAME = constants.NAME;
    var utils = require_utils();
    var cmpStr = utils.cmpStr;
    var EOF = TYPE.EOF;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var OFFSET_MASK = 16777215;
    var TYPE_SHIFT = 24;
    var TokenStream = function() {
      this.offsetAndType = null;
      this.balance = null;
      this.reset();
    };
    TokenStream.prototype = {
      reset: function() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
      },
      lookupType: function(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset] >> TYPE_SHIFT;
        }
        return EOF;
      },
      lookupOffset: function(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }
        return this.source.length;
      },
      lookupValue: function(offset, referenceStr) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return cmpStr(
            this.source,
            this.offsetAndType[offset - 1] & OFFSET_MASK,
            this.offsetAndType[offset] & OFFSET_MASK,
            referenceStr
          );
        }
        return false;
      },
      getTokenStart: function(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
          return this.tokenStart;
        }
        if (tokenIndex > 0) {
          return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }
        return this.firstCharOffset;
      },
      // TODO: -> skipUntilBalanced
      getRawLength: function(startToken, mode) {
        var cursor = startToken;
        var balanceEnd;
        var offset = this.offsetAndType[Math.max(cursor - 1, 0)] & OFFSET_MASK;
        var type;
        loop:
          for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];
            if (balanceEnd < startToken) {
              break loop;
            }
            type = this.offsetAndType[cursor] >> TYPE_SHIFT;
            switch (mode(type, this.source, offset)) {
              case 1:
                break loop;
              case 2:
                cursor++;
                break loop;
              default:
                if (this.balance[balanceEnd] === cursor) {
                  cursor = balanceEnd;
                }
                offset = this.offsetAndType[cursor] & OFFSET_MASK;
            }
          }
        return cursor - this.tokenIndex;
      },
      isBalanceEdge: function(pos) {
        return this.balance[this.tokenIndex] < pos;
      },
      isDelim: function(code, offset) {
        if (offset) {
          return this.lookupType(offset) === TYPE.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
        }
        return this.tokenType === TYPE.Delim && this.source.charCodeAt(this.tokenStart) === code;
      },
      getTokenValue: function() {
        return this.source.substring(this.tokenStart, this.tokenEnd);
      },
      getTokenLength: function() {
        return this.tokenEnd - this.tokenStart;
      },
      substrToCursor: function(start) {
        return this.source.substring(start, this.tokenStart);
      },
      skipWS: function() {
        for (var i = this.tokenIndex, skipTokenCount = 0; i < this.tokenCount; i++, skipTokenCount++) {
          if (this.offsetAndType[i] >> TYPE_SHIFT !== WHITESPACE) {
            break;
          }
        }
        if (skipTokenCount > 0) {
          this.skip(skipTokenCount);
        }
      },
      skipSC: function() {
        while (this.tokenType === WHITESPACE || this.tokenType === COMMENT) {
          this.next();
        }
      },
      skip: function(tokenCount) {
        var next = this.tokenIndex + tokenCount;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.tokenIndex = this.tokenCount;
          this.next();
        }
      },
      next: function() {
        var next = this.tokenIndex + 1;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.tokenEnd;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.tokenIndex = this.tokenCount;
          this.eof = true;
          this.tokenType = EOF;
          this.tokenStart = this.tokenEnd = this.source.length;
        }
      },
      forEachToken(fn) {
        for (var i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
          var start = offset;
          var item = this.offsetAndType[i];
          var end = item & OFFSET_MASK;
          var type = item >> TYPE_SHIFT;
          offset = end;
          fn(type, start, end, i);
        }
      },
      dump() {
        var tokens = new Array(this.tokenCount);
        this.forEachToken((type, start, end, index) => {
          tokens[index] = {
            idx: index,
            type: NAME[type],
            chunk: this.source.substring(start, end),
            balance: this.balance[index]
          };
        });
        return tokens;
      }
    };
    module2.exports = TokenStream;
  }
});

// node_modules/css-tree/lib/definition-syntax/generate.js
var require_generate = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/generate.js"(exports2, module2) {
    function noop(value) {
      return value;
    }
    function generateMultiplier(multiplier) {
      if (multiplier.min === 0 && multiplier.max === 0) {
        return "*";
      }
      if (multiplier.min === 0 && multiplier.max === 1) {
        return "?";
      }
      if (multiplier.min === 1 && multiplier.max === 0) {
        return multiplier.comma ? "#" : "+";
      }
      if (multiplier.min === 1 && multiplier.max === 1) {
        return "";
      }
      return (multiplier.comma ? "#" : "") + (multiplier.min === multiplier.max ? "{" + multiplier.min + "}" : "{" + multiplier.min + "," + (multiplier.max !== 0 ? multiplier.max : "") + "}");
    }
    function generateTypeOpts(node) {
      switch (node.type) {
        case "Range":
          return " [" + (node.min === null ? "-\u221E" : node.min) + "," + (node.max === null ? "\u221E" : node.max) + "]";
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
    }
    function generateSequence(node, decorate, forceBraces, compact) {
      var combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
      var result = node.terms.map(function(term) {
        return generate(term, decorate, forceBraces, compact);
      }).join(combinator);
      if (node.explicit || forceBraces) {
        result = (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
      }
      return result;
    }
    function generate(node, decorate, forceBraces, compact) {
      var result;
      switch (node.type) {
        case "Group":
          result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
          break;
        case "Multiplier":
          return generate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
        case "Type":
          result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
          break;
        case "Property":
          result = "<'" + node.name + "'>";
          break;
        case "Keyword":
          result = node.name;
          break;
        case "AtKeyword":
          result = "@" + node.name;
          break;
        case "Function":
          result = node.name + "(";
          break;
        case "String":
        case "Token":
          result = node.value;
          break;
        case "Comma":
          result = ",";
          break;
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
      return decorate(result, node);
    }
    module2.exports = function(node, options) {
      var decorate = noop;
      var forceBraces = false;
      var compact = false;
      if (typeof options === "function") {
        decorate = options;
      } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === "function") {
          decorate = options.decorate;
        }
      }
      return generate(node, decorate, forceBraces, compact);
    };
  }
});

// node_modules/css-tree/lib/lexer/error.js
var require_error = __commonJS({
  "node_modules/css-tree/lib/lexer/error.js"(exports2, module2) {
    var createCustomError = require_createCustomError();
    var generate = require_generate();
    var defaultLoc = { offset: 0, line: 1, column: 1 };
    function locateMismatch(matchResult, node) {
      const tokens = matchResult.tokens;
      const longestMatch = matchResult.longestMatch;
      const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
      const badNode = mismatchNode !== node ? mismatchNode : null;
      let mismatchOffset = 0;
      let mismatchLength = 0;
      let entries = 0;
      let css = "";
      let start;
      let end;
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;
        if (i === longestMatch) {
          mismatchLength = token.length;
          mismatchOffset = css.length;
        }
        if (badNode !== null && tokens[i].node === badNode) {
          if (i <= longestMatch) {
            entries++;
          } else {
            entries = 0;
          }
        }
        css += token;
      }
      if (longestMatch === tokens.length || entries > 1) {
        start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
        end = buildLoc(start);
      } else {
        start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
      }
      return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      };
    }
    function fromLoc(node, point) {
      const value = node && node.loc && node.loc[point];
      if (value) {
        return "line" in value ? buildLoc(value) : value;
      }
      return null;
    }
    function buildLoc({ offset, line, column }, extra) {
      const loc = {
        offset,
        line,
        column
      };
      if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);
        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
      }
      return loc;
    }
    var SyntaxReferenceError = function(type, referenceName) {
      const error = createCustomError(
        "SyntaxReferenceError",
        type + (referenceName ? " `" + referenceName + "`" : "")
      );
      error.reference = referenceName;
      return error;
    };
    var SyntaxMatchError = function(message, syntax, node, matchResult) {
      const error = createCustomError("SyntaxMatchError", message);
      const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      } = locateMismatch(matchResult, node);
      error.rawMessage = message;
      error.syntax = syntax ? generate(syntax) : "<generic>";
      error.css = css;
      error.mismatchOffset = mismatchOffset;
      error.mismatchLength = mismatchLength;
      error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
      Object.assign(error, start);
      error.loc = {
        source: node && node.loc && node.loc.source || "<unknown>",
        start,
        end
      };
      return error;
    };
    module2.exports = {
      SyntaxReferenceError,
      SyntaxMatchError
    };
  }
});

// node_modules/css-tree/lib/utils/names.js
var require_names = __commonJS({
  "node_modules/css-tree/lib/utils/names.js"(exports2, module2) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var keywords = /* @__PURE__ */ Object.create(null);
    var properties = /* @__PURE__ */ Object.create(null);
    var HYPHENMINUS = 45;
    function isCustomProperty(str, offset) {
      offset = offset || 0;
      return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
    }
    function getVendorPrefix(str, offset) {
      offset = offset || 0;
      if (str.length - offset >= 3) {
        if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
          var secondDashIndex = str.indexOf("-", offset + 2);
          if (secondDashIndex !== -1) {
            return str.substring(offset, secondDashIndex + 1);
          }
        }
      }
      return "";
    }
    function getKeywordDescriptor(keyword) {
      if (hasOwnProperty2.call(keywords, keyword)) {
        return keywords[keyword];
      }
      var name = keyword.toLowerCase();
      if (hasOwnProperty2.call(keywords, name)) {
        return keywords[keyword] = keywords[name];
      }
      var custom = isCustomProperty(name, 0);
      var vendor = !custom ? getVendorPrefix(name, 0) : "";
      return keywords[keyword] = Object.freeze({
        basename: name.substr(vendor.length),
        name,
        vendor,
        prefix: vendor,
        custom
      });
    }
    function getPropertyDescriptor(property) {
      if (hasOwnProperty2.call(properties, property)) {
        return properties[property];
      }
      var name = property;
      var hack = property[0];
      if (hack === "/") {
        hack = property[1] === "/" ? "//" : "/";
      } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
        hack = "";
      }
      var custom = isCustomProperty(name, hack.length);
      if (!custom) {
        name = name.toLowerCase();
        if (hasOwnProperty2.call(properties, name)) {
          return properties[property] = properties[name];
        }
      }
      var vendor = !custom ? getVendorPrefix(name, hack.length) : "";
      var prefix = name.substr(0, hack.length + vendor.length);
      return properties[property] = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack,
        vendor,
        prefix,
        custom
      });
    }
    module2.exports = {
      keyword: getKeywordDescriptor,
      property: getPropertyDescriptor,
      isCustomProperty,
      vendorPrefix: getVendorPrefix
    };
  }
});

// node_modules/css-tree/lib/common/adopt-buffer.js
var require_adopt_buffer = __commonJS({
  "node_modules/css-tree/lib/common/adopt-buffer.js"(exports2, module2) {
    var MIN_SIZE = 16 * 1024;
    var SafeUint32Array = typeof Uint32Array !== "undefined" ? Uint32Array : Array;
    module2.exports = function adoptBuffer(buffer, size) {
      if (buffer === null || buffer.length < size) {
        return new SafeUint32Array(Math.max(size + 1024, MIN_SIZE));
      }
      return buffer;
    };
  }
});

// node_modules/css-tree/lib/tokenizer/index.js
var require_tokenizer = __commonJS({
  "node_modules/css-tree/lib/tokenizer/index.js"(exports2, module2) {
    var TokenStream = require_TokenStream();
    var adoptBuffer = require_adopt_buffer();
    var constants = require_const();
    var TYPE = constants.TYPE;
    var charCodeDefinitions = require_char_code_definitions();
    var isNewline = charCodeDefinitions.isNewline;
    var isName = charCodeDefinitions.isName;
    var isValidEscape = charCodeDefinitions.isValidEscape;
    var isNumberStart = charCodeDefinitions.isNumberStart;
    var isIdentifierStart = charCodeDefinitions.isIdentifierStart;
    var charCodeCategory = charCodeDefinitions.charCodeCategory;
    var isBOM = charCodeDefinitions.isBOM;
    var utils = require_utils();
    var cmpStr = utils.cmpStr;
    var getNewlineLength = utils.getNewlineLength;
    var findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
    var consumeEscaped = utils.consumeEscaped;
    var consumeName = utils.consumeName;
    var consumeNumber = utils.consumeNumber;
    var consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
    var OFFSET_MASK = 16777215;
    var TYPE_SHIFT = 24;
    function tokenize(source, stream) {
      function getCharCode(offset2) {
        return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
      }
      function consumeNumericToken() {
        offset = consumeNumber(source, offset);
        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
          type = TYPE.Dimension;
          offset = consumeName(source, offset);
          return;
        }
        if (getCharCode(offset) === 37) {
          type = TYPE.Percentage;
          offset++;
          return;
        }
        type = TYPE.Number;
      }
      function consumeIdentLikeToken() {
        const nameStartOffset = offset;
        offset = consumeName(source, offset);
        if (cmpStr(source, nameStartOffset, offset, "url") && getCharCode(offset) === 40) {
          offset = findWhiteSpaceEnd(source, offset + 1);
          if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
            type = TYPE.Function;
            offset = nameStartOffset + 4;
            return;
          }
          consumeUrlToken();
          return;
        }
        if (getCharCode(offset) === 40) {
          type = TYPE.Function;
          offset++;
          return;
        }
        type = TYPE.Ident;
      }
      function consumeStringToken(endingCodePoint) {
        if (!endingCodePoint) {
          endingCodePoint = getCharCode(offset++);
        }
        type = TYPE.String;
        for (; offset < source.length; offset++) {
          var code2 = source.charCodeAt(offset);
          switch (charCodeCategory(code2)) {
            case endingCodePoint:
              offset++;
              return;
            case charCodeCategory.Eof:
              return;
            case charCodeCategory.WhiteSpace:
              if (isNewline(code2)) {
                offset += getNewlineLength(source, offset, code2);
                type = TYPE.BadString;
                return;
              }
              break;
            case 92:
              if (offset === source.length - 1) {
                break;
              }
              var nextCode = getCharCode(offset + 1);
              if (isNewline(nextCode)) {
                offset += getNewlineLength(source, offset + 1, nextCode);
              } else if (isValidEscape(code2, nextCode)) {
                offset = consumeEscaped(source, offset) - 1;
              }
              break;
          }
        }
      }
      function consumeUrlToken() {
        type = TYPE.Url;
        offset = findWhiteSpaceEnd(source, offset);
        for (; offset < source.length; offset++) {
          var code2 = source.charCodeAt(offset);
          switch (charCodeCategory(code2)) {
            case 41:
              offset++;
              return;
            case charCodeCategory.Eof:
              return;
            case charCodeCategory.WhiteSpace:
              offset = findWhiteSpaceEnd(source, offset);
              if (getCharCode(offset) === 41 || offset >= source.length) {
                if (offset < source.length) {
                  offset++;
                }
                return;
              }
              offset = consumeBadUrlRemnants(source, offset);
              type = TYPE.BadUrl;
              return;
            case 34:
            case 39:
            case 40:
            case charCodeCategory.NonPrintable:
              offset = consumeBadUrlRemnants(source, offset);
              type = TYPE.BadUrl;
              return;
            case 92:
              if (isValidEscape(code2, getCharCode(offset + 1))) {
                offset = consumeEscaped(source, offset) - 1;
                break;
              }
              offset = consumeBadUrlRemnants(source, offset);
              type = TYPE.BadUrl;
              return;
          }
        }
      }
      if (!stream) {
        stream = new TokenStream();
      }
      source = String(source || "");
      var sourceLength = source.length;
      var offsetAndType = adoptBuffer(stream.offsetAndType, sourceLength + 1);
      var balance = adoptBuffer(stream.balance, sourceLength + 1);
      var tokenCount = 0;
      var start = isBOM(getCharCode(0));
      var offset = start;
      var balanceCloseType = 0;
      var balanceStart = 0;
      var balancePrev = 0;
      while (offset < sourceLength) {
        var code = source.charCodeAt(offset);
        var type = 0;
        balance[tokenCount] = sourceLength;
        switch (charCodeCategory(code)) {
          case charCodeCategory.WhiteSpace:
            type = TYPE.WhiteSpace;
            offset = findWhiteSpaceEnd(source, offset + 1);
            break;
          case 34:
            consumeStringToken();
            break;
          case 35:
            if (isName(getCharCode(offset + 1)) || isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
              type = TYPE.Hash;
              offset = consumeName(source, offset + 1);
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 39:
            consumeStringToken();
            break;
          case 40:
            type = TYPE.LeftParenthesis;
            offset++;
            break;
          case 41:
            type = TYPE.RightParenthesis;
            offset++;
            break;
          case 43:
            if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 44:
            type = TYPE.Comma;
            offset++;
            break;
          case 45:
            if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              if (getCharCode(offset + 1) === 45 && getCharCode(offset + 2) === 62) {
                type = TYPE.CDC;
                offset = offset + 3;
              } else {
                if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                  consumeIdentLikeToken();
                } else {
                  type = TYPE.Delim;
                  offset++;
                }
              }
            }
            break;
          case 46:
            if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 47:
            if (getCharCode(offset + 1) === 42) {
              type = TYPE.Comment;
              offset = source.indexOf("*/", offset + 2) + 2;
              if (offset === 1) {
                offset = source.length;
              }
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 58:
            type = TYPE.Colon;
            offset++;
            break;
          case 59:
            type = TYPE.Semicolon;
            offset++;
            break;
          case 60:
            if (getCharCode(offset + 1) === 33 && getCharCode(offset + 2) === 45 && getCharCode(offset + 3) === 45) {
              type = TYPE.CDO;
              offset = offset + 4;
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 64:
            if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
              type = TYPE.AtKeyword;
              offset = consumeName(source, offset + 1);
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 91:
            type = TYPE.LeftSquareBracket;
            offset++;
            break;
          case 92:
            if (isValidEscape(code, getCharCode(offset + 1))) {
              consumeIdentLikeToken();
            } else {
              type = TYPE.Delim;
              offset++;
            }
            break;
          case 93:
            type = TYPE.RightSquareBracket;
            offset++;
            break;
          case 123:
            type = TYPE.LeftCurlyBracket;
            offset++;
            break;
          case 125:
            type = TYPE.RightCurlyBracket;
            offset++;
            break;
          case charCodeCategory.Digit:
            consumeNumericToken();
            break;
          case charCodeCategory.NameStart:
            consumeIdentLikeToken();
            break;
          case charCodeCategory.Eof:
            break;
          default:
            type = TYPE.Delim;
            offset++;
        }
        switch (type) {
          case balanceCloseType:
            balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balanceCloseType = balanceStart >> TYPE_SHIFT;
            balance[tokenCount] = balancePrev;
            balance[balancePrev++] = tokenCount;
            for (; balancePrev < tokenCount; balancePrev++) {
              if (balance[balancePrev] === sourceLength) {
                balance[balancePrev] = tokenCount;
              }
            }
            break;
          case TYPE.LeftParenthesis:
          case TYPE.Function:
            balance[tokenCount] = balanceStart;
            balanceCloseType = TYPE.RightParenthesis;
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
          case TYPE.LeftSquareBracket:
            balance[tokenCount] = balanceStart;
            balanceCloseType = TYPE.RightSquareBracket;
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
          case TYPE.LeftCurlyBracket:
            balance[tokenCount] = balanceStart;
            balanceCloseType = TYPE.RightCurlyBracket;
            balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
            break;
        }
        offsetAndType[tokenCount++] = type << TYPE_SHIFT | offset;
      }
      offsetAndType[tokenCount] = TYPE.EOF << TYPE_SHIFT | offset;
      balance[tokenCount] = sourceLength;
      balance[sourceLength] = sourceLength;
      while (balanceStart !== 0) {
        balancePrev = balanceStart & OFFSET_MASK;
        balanceStart = balance[balancePrev];
        balance[balancePrev] = sourceLength;
      }
      stream.source = source;
      stream.firstCharOffset = start;
      stream.offsetAndType = offsetAndType;
      stream.tokenCount = tokenCount;
      stream.balance = balance;
      stream.reset();
      stream.next();
      return stream;
    }
    Object.keys(constants).forEach(function(key) {
      tokenize[key] = constants[key];
    });
    Object.keys(charCodeDefinitions).forEach(function(key) {
      tokenize[key] = charCodeDefinitions[key];
    });
    Object.keys(utils).forEach(function(key) {
      tokenize[key] = utils[key];
    });
    module2.exports = tokenize;
  }
});

// node_modules/css-tree/lib/lexer/generic-an-plus-b.js
var require_generic_an_plus_b = __commonJS({
  "node_modules/css-tree/lib/lexer/generic-an-plus-b.js"(exports2, module2) {
    var isDigit = require_tokenizer().isDigit;
    var cmpChar = require_tokenizer().cmpChar;
    var TYPE = require_tokenizer().TYPE;
    var DELIM = TYPE.Delim;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function isDelim(token, code) {
      return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
    }
    function skipSC(token, offset, getNextToken) {
      while (token !== null && (token.type === WHITESPACE || token.type === COMMENT)) {
        token = getNextToken(++offset);
      }
      return offset;
    }
    function checkInteger(token, valueOffset, disallowSign, offset) {
      if (!token) {
        return 0;
      }
      var code = token.value.charCodeAt(valueOffset);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          return 0;
        }
        valueOffset++;
      }
      for (; valueOffset < token.value.length; valueOffset++) {
        if (!isDigit(token.value.charCodeAt(valueOffset))) {
          return 0;
        }
      }
      return offset + 1;
    }
    function consumeB(token, offset_, getNextToken) {
      var sign = false;
      var offset = skipSC(token, offset_, getNextToken);
      token = getNextToken(offset);
      if (token === null) {
        return offset_;
      }
      if (token.type !== NUMBER) {
        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
          sign = true;
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          if (token === null && token.type !== NUMBER) {
            return 0;
          }
        } else {
          return offset_;
        }
      }
      if (!sign) {
        var code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN && code !== HYPHENMINUS) {
          return 0;
        }
      }
      return checkInteger(token, sign ? 0 : 1, sign, offset);
    }
    module2.exports = function anPlusB(token, getNextToken) {
      var offset = 0;
      if (!token) {
        return 0;
      }
      if (token.type === NUMBER) {
        return checkInteger(token, 0, ALLOW_SIGN, offset);
      } else if (token.type === IDENT && token.value.charCodeAt(0) === HYPHENMINUS) {
        if (!cmpChar(token.value, 1, N)) {
          return 0;
        }
        switch (token.value.length) {
          case 2:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          case 3:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          default:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 3, DISALLOW_SIGN, offset);
        }
      } else if (token.type === IDENT || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === IDENT) {
        if (token.type !== IDENT) {
          token = getNextToken(++offset);
        }
        if (token === null || !cmpChar(token.value, 0, N)) {
          return 0;
        }
        switch (token.value.length) {
          case 1:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          case 2:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          default:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 2, DISALLOW_SIGN, offset);
        }
      } else if (token.type === DIMENSION) {
        var code = token.value.charCodeAt(0);
        var sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
        for (var i = sign; i < token.value.length; i++) {
          if (!isDigit(token.value.charCodeAt(i))) {
            break;
          }
        }
        if (i === sign) {
          return 0;
        }
        if (!cmpChar(token.value, i, N)) {
          return 0;
        }
        if (i + 1 === token.value.length) {
          return consumeB(getNextToken(++offset), offset, getNextToken);
        } else {
          if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
            return 0;
          }
          if (i + 2 === token.value.length) {
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          } else {
            return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
          }
        }
      }
      return 0;
    };
  }
});

// node_modules/css-tree/lib/lexer/generic-urange.js
var require_generic_urange = __commonJS({
  "node_modules/css-tree/lib/lexer/generic-urange.js"(exports2, module2) {
    var isHexDigit = require_tokenizer().isHexDigit;
    var cmpChar = require_tokenizer().cmpChar;
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var DELIM = TYPE.Delim;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    var U = 117;
    function isDelim(token, code) {
      return token !== null && token.type === DELIM && token.value.charCodeAt(0) === code;
    }
    function startsWith(token, code) {
      return token.value.charCodeAt(0) === code;
    }
    function hexSequence(token, offset, allowDash) {
      for (var pos = offset, hexlen = 0; pos < token.value.length; pos++) {
        var code = token.value.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
          if (hexSequence(token, offset + hexlen + 1, false) > 0) {
            return 6;
          }
          return 0;
        }
        if (!isHexDigit(code)) {
          return 0;
        }
        if (++hexlen > 6) {
          return 0;
        }
        ;
      }
      return hexlen;
    }
    function withQuestionMarkSequence(consumed, length, getNextToken) {
      if (!consumed) {
        return 0;
      }
      while (isDelim(getNextToken(length), QUESTIONMARK)) {
        if (++consumed > 6) {
          return 0;
        }
        length++;
      }
      return length;
    }
    module2.exports = function urange(token, getNextToken) {
      var length = 0;
      if (token === null || token.type !== IDENT || !cmpChar(token.value, 0, U)) {
        return 0;
      }
      token = getNextToken(++length);
      if (token === null) {
        return 0;
      }
      if (isDelim(token, PLUSSIGN)) {
        token = getNextToken(++length);
        if (token === null) {
          return 0;
        }
        if (token.type === IDENT) {
          return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }
        if (isDelim(token, QUESTIONMARK)) {
          return withQuestionMarkSequence(1, ++length, getNextToken);
        }
        return 0;
      }
      if (token.type === NUMBER) {
        if (!startsWith(token, PLUSSIGN)) {
          return 0;
        }
        var consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
          return 0;
        }
        token = getNextToken(++length);
        if (token === null) {
          return length;
        }
        if (token.type === DIMENSION || token.type === NUMBER) {
          if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
            return 0;
          }
          return length + 1;
        }
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
      }
      if (token.type === DIMENSION) {
        if (!startsWith(token, PLUSSIGN)) {
          return 0;
        }
        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
      }
      return 0;
    };
  }
});

// node_modules/css-tree/lib/lexer/generic.js
var require_generic = __commonJS({
  "node_modules/css-tree/lib/lexer/generic.js"(exports2, module2) {
    var tokenizer = require_tokenizer();
    var isIdentifierStart = tokenizer.isIdentifierStart;
    var isHexDigit = tokenizer.isHexDigit;
    var isDigit = tokenizer.isDigit;
    var cmpStr = tokenizer.cmpStr;
    var consumeNumber = tokenizer.consumeNumber;
    var TYPE = tokenizer.TYPE;
    var anPlusB = require_generic_an_plus_b();
    var urange = require_generic_urange();
    var cssWideKeywords = ["unset", "initial", "inherit"];
    var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
    var LENGTH = {
      // absolute length units
      "px": true,
      "mm": true,
      "cm": true,
      "in": true,
      "pt": true,
      "pc": true,
      "q": true,
      // relative length units
      "em": true,
      "ex": true,
      "ch": true,
      "rem": true,
      // viewport-percentage lengths
      "vh": true,
      "vw": true,
      "vmin": true,
      "vmax": true,
      "vm": true
    };
    var ANGLE = {
      "deg": true,
      "grad": true,
      "rad": true,
      "turn": true
    };
    var TIME = {
      "s": true,
      "ms": true
    };
    var FREQUENCY = {
      "hz": true,
      "khz": true
    };
    var RESOLUTION = {
      "dpi": true,
      "dpcm": true,
      "dppx": true,
      "x": true
      // https://github.com/w3c/csswg-drafts/issues/461
    };
    var FLEX = {
      "fr": true
    };
    var DECIBEL = {
      "db": true
    };
    var SEMITONES = {
      "st": true
    };
    function charCode(str, index) {
      return index < str.length ? str.charCodeAt(index) : 0;
    }
    function eqStr(actual, expected) {
      return cmpStr(actual, 0, actual.length, expected);
    }
    function eqStrAny(actual, expected) {
      for (var i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
          return true;
        }
      }
      return false;
    }
    function isPostfixIeHack(str, offset) {
      if (offset !== str.length - 2) {
        return false;
      }
      return str.charCodeAt(offset) === 92 && // U+005C REVERSE SOLIDUS (\)
      isDigit(str.charCodeAt(offset + 1));
    }
    function outOfRange(opts, value, numEnd) {
      if (opts && opts.type === "Range") {
        var num = Number(
          numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
        );
        if (isNaN(num)) {
          return true;
        }
        if (opts.min !== null && num < opts.min) {
          return true;
        }
        if (opts.max !== null && num > opts.max) {
          return true;
        }
      }
      return false;
    }
    function consumeFunction(token, getNextToken) {
      var startIdx = token.index;
      var length = 0;
      do {
        length++;
        if (token.balance <= startIdx) {
          break;
        }
      } while (token = getNextToken(length));
      return length;
    }
    function calc(next) {
      return function(token, getNextToken, opts) {
        if (token === null) {
          return 0;
        }
        if (token.type === TYPE.Function && eqStrAny(token.value, calcFunctionNames)) {
          return consumeFunction(token, getNextToken);
        }
        return next(token, getNextToken, opts);
      };
    }
    function tokenType(expectedTokenType) {
      return function(token) {
        if (token === null || token.type !== expectedTokenType) {
          return 0;
        }
        return 1;
      };
    }
    function func(name) {
      name = name + "(";
      return function(token, getNextToken) {
        if (token !== null && eqStr(token.value, name)) {
          return consumeFunction(token, getNextToken);
        }
        return 0;
      };
    }
    function customIdent(token) {
      if (token === null || token.type !== TYPE.Ident) {
        return 0;
      }
      var name = token.value.toLowerCase();
      if (eqStrAny(name, cssWideKeywords)) {
        return 0;
      }
      if (eqStr(name, "default")) {
        return 0;
      }
      return 1;
    }
    function customPropertyName(token) {
      if (token === null || token.type !== TYPE.Ident) {
        return 0;
      }
      if (charCode(token.value, 0) !== 45 || charCode(token.value, 1) !== 45) {
        return 0;
      }
      return 1;
    }
    function hexColor(token) {
      if (token === null || token.type !== TYPE.Hash) {
        return 0;
      }
      var length = token.value.length;
      if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
      }
      for (var i = 1; i < length; i++) {
        if (!isHexDigit(token.value.charCodeAt(i))) {
          return 0;
        }
      }
      return 1;
    }
    function idSelector(token) {
      if (token === null || token.type !== TYPE.Hash) {
        return 0;
      }
      if (!isIdentifierStart(charCode(token.value, 1), charCode(token.value, 2), charCode(token.value, 3))) {
        return 0;
      }
      return 1;
    }
    function declarationValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      var length = 0;
      var level = 0;
      var startIdx = token.index;
      scan:
        do {
          switch (token.type) {
            case TYPE.BadString:
            case TYPE.BadUrl:
              break scan;
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
              if (token.balance > token.index || token.balance < startIdx) {
                break scan;
              }
              level--;
              break;
            case TYPE.Semicolon:
              if (level === 0) {
                break scan;
              }
              break;
            case TYPE.Delim:
              if (token.value === "!" && level === 0) {
                break scan;
              }
              break;
            case TYPE.Function:
            case TYPE.LeftParenthesis:
            case TYPE.LeftSquareBracket:
            case TYPE.LeftCurlyBracket:
              level++;
              break;
          }
          length++;
          if (token.balance <= startIdx) {
            break;
          }
        } while (token = getNextToken(length));
      return length;
    }
    function anyValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      var startIdx = token.index;
      var length = 0;
      scan:
        do {
          switch (token.type) {
            case TYPE.BadString:
            case TYPE.BadUrl:
              break scan;
            case TYPE.RightCurlyBracket:
            case TYPE.RightParenthesis:
            case TYPE.RightSquareBracket:
              if (token.balance > token.index || token.balance < startIdx) {
                break scan;
              }
              break;
          }
          length++;
          if (token.balance <= startIdx) {
            break;
          }
        } while (token = getNextToken(length));
      return length;
    }
    function dimension(type) {
      return function(token, getNextToken, opts) {
        if (token === null || token.type !== TYPE.Dimension) {
          return 0;
        }
        var numberEnd = consumeNumber(token.value, 0);
        if (type !== null) {
          var reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
          var unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
          if (type.hasOwnProperty(unit.toLowerCase()) === false) {
            return 0;
          }
        }
        if (outOfRange(opts, token.value, numberEnd)) {
          return 0;
        }
        return 1;
      };
    }
    function percentage(token, getNextToken, opts) {
      if (token === null || token.type !== TYPE.Percentage) {
        return 0;
      }
      if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
      }
      return 1;
    }
    function zero(next) {
      if (typeof next !== "function") {
        next = function() {
          return 0;
        };
      }
      return function(token, getNextToken, opts) {
        if (token !== null && token.type === TYPE.Number) {
          if (Number(token.value) === 0) {
            return 1;
          }
        }
        return next(token, getNextToken, opts);
      };
    }
    function number(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      var numberEnd = consumeNumber(token.value, 0);
      var isNumber = numberEnd === token.value.length;
      if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    }
    function integer(token, getNextToken, opts) {
      if (token === null || token.type !== TYPE.Number) {
        return 0;
      }
      var i = token.value.charCodeAt(0) === 43 || // U+002B PLUS SIGN (+)
      token.value.charCodeAt(0) === 45 ? 1 : 0;
      for (; i < token.value.length; i++) {
        if (!isDigit(token.value.charCodeAt(i))) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, i)) {
        return 0;
      }
      return 1;
    }
    module2.exports = {
      // token types
      "ident-token": tokenType(TYPE.Ident),
      "function-token": tokenType(TYPE.Function),
      "at-keyword-token": tokenType(TYPE.AtKeyword),
      "hash-token": tokenType(TYPE.Hash),
      "string-token": tokenType(TYPE.String),
      "bad-string-token": tokenType(TYPE.BadString),
      "url-token": tokenType(TYPE.Url),
      "bad-url-token": tokenType(TYPE.BadUrl),
      "delim-token": tokenType(TYPE.Delim),
      "number-token": tokenType(TYPE.Number),
      "percentage-token": tokenType(TYPE.Percentage),
      "dimension-token": tokenType(TYPE.Dimension),
      "whitespace-token": tokenType(TYPE.WhiteSpace),
      "CDO-token": tokenType(TYPE.CDO),
      "CDC-token": tokenType(TYPE.CDC),
      "colon-token": tokenType(TYPE.Colon),
      "semicolon-token": tokenType(TYPE.Semicolon),
      "comma-token": tokenType(TYPE.Comma),
      "[-token": tokenType(TYPE.LeftSquareBracket),
      "]-token": tokenType(TYPE.RightSquareBracket),
      "(-token": tokenType(TYPE.LeftParenthesis),
      ")-token": tokenType(TYPE.RightParenthesis),
      "{-token": tokenType(TYPE.LeftCurlyBracket),
      "}-token": tokenType(TYPE.RightCurlyBracket),
      // token type aliases
      "string": tokenType(TYPE.String),
      "ident": tokenType(TYPE.Ident),
      // complex types
      "custom-ident": customIdent,
      "custom-property-name": customPropertyName,
      "hex-color": hexColor,
      "id-selector": idSelector,
      // element( <id-selector> )
      "an-plus-b": anPlusB,
      "urange": urange,
      "declaration-value": declarationValue,
      "any-value": anyValue,
      // dimensions
      "dimension": calc(dimension(null)),
      "angle": calc(dimension(ANGLE)),
      "decibel": calc(dimension(DECIBEL)),
      "frequency": calc(dimension(FREQUENCY)),
      "flex": calc(dimension(FLEX)),
      "length": calc(zero(dimension(LENGTH))),
      "resolution": calc(dimension(RESOLUTION)),
      "semitones": calc(dimension(SEMITONES)),
      "time": calc(dimension(TIME)),
      // percentage
      "percentage": calc(percentage),
      // numeric
      "zero": zero(),
      "number": calc(number),
      "integer": calc(integer),
      // old IE stuff
      "-ms-legacy-expression": func("expression")
    };
  }
});

// node_modules/css-tree/lib/definition-syntax/SyntaxError.js
var require_SyntaxError2 = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/SyntaxError.js"(exports2, module2) {
    var createCustomError = require_createCustomError();
    module2.exports = function SyntaxError2(message, input, offset) {
      var error = createCustomError("SyntaxError", message);
      error.input = input;
      error.offset = offset;
      error.rawMessage = message;
      error.message = error.rawMessage + "\n  " + error.input + "\n--" + new Array((error.offset || error.input.length) + 1).join("-") + "^";
      return error;
    };
  }
});

// node_modules/css-tree/lib/definition-syntax/tokenizer.js
var require_tokenizer2 = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/tokenizer.js"(exports2, module2) {
    var SyntaxError2 = require_SyntaxError2();
    var TAB = 9;
    var N = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var Tokenizer = function(str) {
      this.str = str;
      this.pos = 0;
    };
    Tokenizer.prototype = {
      charCodeAt: function(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
      },
      charCode: function() {
        return this.charCodeAt(this.pos);
      },
      nextCharCode: function() {
        return this.charCodeAt(this.pos + 1);
      },
      nextNonWsCode: function(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
      },
      findWsEnd: function(pos) {
        for (; pos < this.str.length; pos++) {
          var code = this.str.charCodeAt(pos);
          if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
            break;
          }
        }
        return pos;
      },
      substringToPos: function(end) {
        return this.str.substring(this.pos, this.pos = end);
      },
      eat: function(code) {
        if (this.charCode() !== code) {
          this.error("Expect `" + String.fromCharCode(code) + "`");
        }
        this.pos++;
      },
      peek: function() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
      },
      error: function(message) {
        throw new SyntaxError2(message, this.str, this.pos);
      }
    };
    module2.exports = Tokenizer;
  }
});

// node_modules/css-tree/lib/definition-syntax/parse.js
var require_parse3 = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/parse.js"(exports2, module2) {
    var Tokenizer = require_tokenizer2();
    var TAB = 9;
    var N = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var AMPERSAND = 38;
    var APOSTROPHE = 39;
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var COMMA = 44;
    var HYPERMINUS = 45;
    var LESSTHANSIGN = 60;
    var GREATERTHANSIGN = 62;
    var QUESTIONMARK = 63;
    var COMMERCIALAT = 64;
    var LEFTSQUAREBRACKET = 91;
    var RIGHTSQUAREBRACKET = 93;
    var LEFTCURLYBRACKET = 123;
    var VERTICALLINE = 124;
    var RIGHTCURLYBRACKET = 125;
    var INFINITY = 8734;
    var NAME_CHAR = createCharMap(function(ch) {
      return /[a-zA-Z0-9\-]/.test(ch);
    });
    var COMBINATOR_PRECEDENCE = {
      " ": 1,
      "&&": 2,
      "||": 3,
      "|": 4
    };
    function createCharMap(fn) {
      var array = typeof Uint32Array === "function" ? new Uint32Array(128) : new Array(128);
      for (var i = 0; i < 128; i++) {
        array[i] = fn(String.fromCharCode(i)) ? 1 : 0;
      }
      return array;
    }
    function scanSpaces(tokenizer) {
      return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos)
      );
    }
    function scanWord(tokenizer) {
      var end = tokenizer.pos;
      for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
          break;
        }
      }
      if (tokenizer.pos === end) {
        tokenizer.error("Expect a keyword");
      }
      return tokenizer.substringToPos(end);
    }
    function scanNumber(tokenizer) {
      var end = tokenizer.pos;
      for (; end < tokenizer.str.length; end++) {
        var code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
          break;
        }
      }
      if (tokenizer.pos === end) {
        tokenizer.error("Expect a number");
      }
      return tokenizer.substringToPos(end);
    }
    function scanString(tokenizer) {
      var end = tokenizer.str.indexOf("'", tokenizer.pos + 1);
      if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error("Expect an apostrophe");
      }
      return tokenizer.substringToPos(end + 1);
    }
    function readMultiplierRange(tokenizer) {
      var min = null;
      var max = null;
      tokenizer.eat(LEFTCURLYBRACKET);
      min = scanNumber(tokenizer);
      if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
          max = scanNumber(tokenizer);
        }
      } else {
        max = min;
      }
      tokenizer.eat(RIGHTCURLYBRACKET);
      return {
        min: Number(min),
        max: max ? Number(max) : 0
      };
    }
    function readMultiplier(tokenizer) {
      var range = null;
      var comma = false;
      switch (tokenizer.charCode()) {
        case ASTERISK:
          tokenizer.pos++;
          range = {
            min: 0,
            max: 0
          };
          break;
        case PLUSSIGN:
          tokenizer.pos++;
          range = {
            min: 1,
            max: 0
          };
          break;
        case QUESTIONMARK:
          tokenizer.pos++;
          range = {
            min: 0,
            max: 1
          };
          break;
        case NUMBERSIGN:
          tokenizer.pos++;
          comma = true;
          if (tokenizer.charCode() === LEFTCURLYBRACKET) {
            range = readMultiplierRange(tokenizer);
          } else {
            range = {
              min: 1,
              max: 0
            };
          }
          break;
        case LEFTCURLYBRACKET:
          range = readMultiplierRange(tokenizer);
          break;
        default:
          return null;
      }
      return {
        type: "Multiplier",
        comma,
        min: range.min,
        max: range.max,
        term: null
      };
    }
    function maybeMultiplied(tokenizer, node) {
      var multiplier = readMultiplier(tokenizer);
      if (multiplier !== null) {
        multiplier.term = node;
        return multiplier;
      }
      return node;
    }
    function maybeToken(tokenizer) {
      var ch = tokenizer.peek();
      if (ch === "") {
        return null;
      }
      return {
        type: "Token",
        value: ch
      };
    }
    function readProperty(tokenizer) {
      var name;
      tokenizer.eat(LESSTHANSIGN);
      tokenizer.eat(APOSTROPHE);
      name = scanWord(tokenizer);
      tokenizer.eat(APOSTROPHE);
      tokenizer.eat(GREATERTHANSIGN);
      return maybeMultiplied(tokenizer, {
        type: "Property",
        name
      });
    }
    function readTypeRange(tokenizer) {
      var min = null;
      var max = null;
      var sign = 1;
      tokenizer.eat(LEFTSQUAREBRACKET);
      if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
      }
      if (sign == -1 && tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
      } else {
        min = sign * Number(scanNumber(tokenizer));
      }
      scanSpaces(tokenizer);
      tokenizer.eat(COMMA);
      scanSpaces(tokenizer);
      if (tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
      } else {
        sign = 1;
        if (tokenizer.charCode() === HYPERMINUS) {
          tokenizer.peek();
          sign = -1;
        }
        max = sign * Number(scanNumber(tokenizer));
      }
      tokenizer.eat(RIGHTSQUAREBRACKET);
      if (min === null && max === null) {
        return null;
      }
      return {
        type: "Range",
        min,
        max
      };
    }
    function readType(tokenizer) {
      var name;
      var opts = null;
      tokenizer.eat(LESSTHANSIGN);
      name = scanWord(tokenizer);
      if (tokenizer.charCode() === LEFTPARENTHESIS && tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer.pos += 2;
        name += "()";
      }
      if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
        scanSpaces(tokenizer);
        opts = readTypeRange(tokenizer);
      }
      tokenizer.eat(GREATERTHANSIGN);
      return maybeMultiplied(tokenizer, {
        type: "Type",
        name,
        opts
      });
    }
    function readKeywordOrFunction(tokenizer) {
      var name;
      name = scanWord(tokenizer);
      if (tokenizer.charCode() === LEFTPARENTHESIS) {
        tokenizer.pos++;
        return {
          type: "Function",
          name
        };
      }
      return maybeMultiplied(tokenizer, {
        type: "Keyword",
        name
      });
    }
    function regroupTerms(terms, combinators) {
      function createGroup(terms2, combinator2) {
        return {
          type: "Group",
          terms: terms2,
          combinator: combinator2,
          disallowEmpty: false,
          explicit: false
        };
      }
      combinators = Object.keys(combinators).sort(function(a, b) {
        return COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b];
      });
      while (combinators.length > 0) {
        var combinator = combinators.shift();
        for (var i = 0, subgroupStart = 0; i < terms.length; i++) {
          var term = terms[i];
          if (term.type === "Combinator") {
            if (term.value === combinator) {
              if (subgroupStart === -1) {
                subgroupStart = i - 1;
              }
              terms.splice(i, 1);
              i--;
            } else {
              if (subgroupStart !== -1 && i - subgroupStart > 1) {
                terms.splice(
                  subgroupStart,
                  i - subgroupStart,
                  createGroup(terms.slice(subgroupStart, i), combinator)
                );
                i = subgroupStart + 1;
              }
              subgroupStart = -1;
            }
          }
        }
        if (subgroupStart !== -1 && combinators.length) {
          terms.splice(
            subgroupStart,
            i - subgroupStart,
            createGroup(terms.slice(subgroupStart, i), combinator)
          );
        }
      }
      return combinator;
    }
    function readImplicitGroup(tokenizer) {
      var terms = [];
      var combinators = {};
      var token;
      var prevToken = null;
      var prevTokenPos = tokenizer.pos;
      while (token = peek(tokenizer)) {
        if (token.type !== "Spaces") {
          if (token.type === "Combinator") {
            if (prevToken === null || prevToken.type === "Combinator") {
              tokenizer.pos = prevTokenPos;
              tokenizer.error("Unexpected combinator");
            }
            combinators[token.value] = true;
          } else if (prevToken !== null && prevToken.type !== "Combinator") {
            combinators[" "] = true;
            terms.push({
              type: "Combinator",
              value: " "
            });
          }
          terms.push(token);
          prevToken = token;
          prevTokenPos = tokenizer.pos;
        }
      }
      if (prevToken !== null && prevToken.type === "Combinator") {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error("Unexpected combinator");
      }
      return {
        type: "Group",
        terms,
        combinator: regroupTerms(terms, combinators) || " ",
        disallowEmpty: false,
        explicit: false
      };
    }
    function readGroup(tokenizer) {
      var result;
      tokenizer.eat(LEFTSQUAREBRACKET);
      result = readImplicitGroup(tokenizer);
      tokenizer.eat(RIGHTSQUAREBRACKET);
      result.explicit = true;
      if (tokenizer.charCode() === EXCLAMATIONMARK) {
        tokenizer.pos++;
        result.disallowEmpty = true;
      }
      return result;
    }
    function peek(tokenizer) {
      var code = tokenizer.charCode();
      if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
      }
      switch (code) {
        case RIGHTSQUAREBRACKET:
          break;
        case LEFTSQUAREBRACKET:
          return maybeMultiplied(tokenizer, readGroup(tokenizer));
        case LESSTHANSIGN:
          return tokenizer.nextCharCode() === APOSTROPHE ? readProperty(tokenizer) : readType(tokenizer);
        case VERTICALLINE:
          return {
            type: "Combinator",
            value: tokenizer.substringToPos(
              tokenizer.nextCharCode() === VERTICALLINE ? tokenizer.pos + 2 : tokenizer.pos + 1
            )
          };
        case AMPERSAND:
          tokenizer.pos++;
          tokenizer.eat(AMPERSAND);
          return {
            type: "Combinator",
            value: "&&"
          };
        case COMMA:
          tokenizer.pos++;
          return {
            type: "Comma"
          };
        case APOSTROPHE:
          return maybeMultiplied(tokenizer, {
            type: "String",
            value: scanString(tokenizer)
          });
        case SPACE:
        case TAB:
        case N:
        case R:
        case F:
          return {
            type: "Spaces",
            value: scanSpaces(tokenizer)
          };
        case COMMERCIALAT:
          code = tokenizer.nextCharCode();
          if (code < 128 && NAME_CHAR[code] === 1) {
            tokenizer.pos++;
            return {
              type: "AtKeyword",
              name: scanWord(tokenizer)
            };
          }
          return maybeToken(tokenizer);
        case ASTERISK:
        case PLUSSIGN:
        case QUESTIONMARK:
        case NUMBERSIGN:
        case EXCLAMATIONMARK:
          break;
        case LEFTCURLYBRACKET:
          code = tokenizer.nextCharCode();
          if (code < 48 || code > 57) {
            return maybeToken(tokenizer);
          }
          break;
        default:
          return maybeToken(tokenizer);
      }
    }
    function parse(source) {
      var tokenizer = new Tokenizer(source);
      var result = readImplicitGroup(tokenizer);
      if (tokenizer.pos !== source.length) {
        tokenizer.error("Unexpected input");
      }
      if (result.terms.length === 1 && result.terms[0].type === "Group") {
        result = result.terms[0];
      }
      return result;
    }
    parse("[a&&<b>#|<'c'>*||e() f{2} /,(% g#{1,2} h{2,})]!");
    module2.exports = parse;
  }
});

// node_modules/css-tree/lib/definition-syntax/walk.js
var require_walk = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/walk.js"(exports2, module2) {
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    module2.exports = function(node, options, context) {
      function walk(node2) {
        enter.call(context, node2);
        switch (node2.type) {
          case "Group":
            node2.terms.forEach(walk);
            break;
          case "Multiplier":
            walk(node2.term);
            break;
          case "Type":
          case "Property":
          case "Keyword":
          case "AtKeyword":
          case "Function":
          case "String":
          case "Token":
          case "Comma":
            break;
          default:
            throw new Error("Unknown type: " + node2.type);
        }
        leave.call(context, node2);
      }
      var enter = noop;
      var leave = noop;
      if (typeof options === "function") {
        enter = options;
      } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
      }
      if (enter === noop && leave === noop) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walk(node, context);
    };
  }
});

// node_modules/css-tree/lib/lexer/prepare-tokens.js
var require_prepare_tokens = __commonJS({
  "node_modules/css-tree/lib/lexer/prepare-tokens.js"(exports2, module2) {
    var tokenize = require_tokenizer();
    var TokenStream = require_TokenStream();
    var tokenStream = new TokenStream();
    var astToTokens = {
      decorator: function(handlers) {
        var curNode = null;
        var prev = { len: 0, node: null };
        var nodes = [prev];
        var buffer = "";
        return {
          children: handlers.children,
          node: function(node) {
            var tmp = curNode;
            curNode = node;
            handlers.node.call(this, node);
            curNode = tmp;
          },
          chunk: function(chunk) {
            buffer += chunk;
            if (prev.node !== curNode) {
              nodes.push({
                len: chunk.length,
                node: curNode
              });
            } else {
              prev.len += chunk.length;
            }
          },
          result: function() {
            return prepareTokens(buffer, nodes);
          }
        };
      }
    };
    function prepareTokens(str, nodes) {
      var tokens = [];
      var nodesOffset = 0;
      var nodesIndex = 0;
      var currentNode = nodes ? nodes[nodesIndex].node : null;
      tokenize(str, tokenStream);
      while (!tokenStream.eof) {
        if (nodes) {
          while (nodesIndex < nodes.length && nodesOffset + nodes[nodesIndex].len <= tokenStream.tokenStart) {
            nodesOffset += nodes[nodesIndex++].len;
            currentNode = nodes[nodesIndex].node;
          }
        }
        tokens.push({
          type: tokenStream.tokenType,
          value: tokenStream.getTokenValue(),
          index: tokenStream.tokenIndex,
          // TODO: remove it, temporary solution
          balance: tokenStream.balance[tokenStream.tokenIndex],
          // TODO: remove it, temporary solution
          node: currentNode
        });
        tokenStream.next();
      }
      return tokens;
    }
    module2.exports = function(value, syntax) {
      if (typeof value === "string") {
        return prepareTokens(value, null);
      }
      return syntax.generate(value, astToTokens);
    };
  }
});

// node_modules/css-tree/lib/lexer/match-graph.js
var require_match_graph = __commonJS({
  "node_modules/css-tree/lib/lexer/match-graph.js"(exports2, module2) {
    var parse = require_parse3();
    var MATCH = { type: "Match" };
    var MISMATCH = { type: "Mismatch" };
    var DISALLOW_EMPTY = { type: "DisallowEmpty" };
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    function createCondition(match, thenBranch, elseBranch) {
      if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
      }
      if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
      }
      if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
      }
      return {
        type: "If",
        match,
        then: thenBranch,
        else: elseBranch
      };
    }
    function isFunctionType(name) {
      return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
    }
    function isEnumCapatible(term) {
      return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
    }
    function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
      switch (combinator) {
        case " ":
          var result = MATCH;
          for (var i = terms.length - 1; i >= 0; i--) {
            var term = terms[i];
            result = createCondition(
              term,
              result,
              MISMATCH
            );
          }
          ;
          return result;
        case "|":
          var result = MISMATCH;
          var map = null;
          for (var i = terms.length - 1; i >= 0; i--) {
            var term = terms[i];
            if (isEnumCapatible(term)) {
              if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                map = /* @__PURE__ */ Object.create(null);
                result = createCondition(
                  {
                    type: "Enum",
                    map
                  },
                  MATCH,
                  result
                );
              }
              if (map !== null) {
                var key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                if (key in map === false) {
                  map[key] = term;
                  continue;
                }
              }
            }
            map = null;
            result = createCondition(
              term,
              MATCH,
              result
            );
          }
          ;
          return result;
        case "&&":
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: true
            };
          }
          var result = MISMATCH;
          for (var i = terms.length - 1; i >= 0; i--) {
            var term = terms[i];
            var thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                false
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          ;
          return result;
        case "||":
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: false
            };
          }
          var result = atLeastOneTermMatched ? MATCH : MISMATCH;
          for (var i = terms.length - 1; i >= 0; i--) {
            var term = terms[i];
            var thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                true
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          ;
          return result;
      }
    }
    function buildMultiplierMatchGraph(node) {
      var result = MATCH;
      var matchTerm = buildMatchGraph(node.term);
      if (node.max === 0) {
        matchTerm = createCondition(
          matchTerm,
          DISALLOW_EMPTY,
          MISMATCH
        );
        result = createCondition(
          matchTerm,
          null,
          // will be a loop
          MISMATCH
        );
        result.then = createCondition(
          MATCH,
          MATCH,
          result
          // make a loop
        );
        if (node.comma) {
          result.then.else = createCondition(
            { type: "Comma", syntax: node },
            result,
            MISMATCH
          );
        }
      } else {
        for (var i = node.min || 1; i <= node.max; i++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            createCondition(
              MATCH,
              MATCH,
              result
            ),
            MISMATCH
          );
        }
      }
      if (node.min === 0) {
        result = createCondition(
          MATCH,
          MATCH,
          result
        );
      } else {
        for (var i = 0; i < node.min - 1; i++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            result,
            MISMATCH
          );
        }
      }
      return result;
    }
    function buildMatchGraph(node) {
      if (typeof node === "function") {
        return {
          type: "Generic",
          fn: node
        };
      }
      switch (node.type) {
        case "Group":
          var result = buildGroupMatchGraph(
            node.combinator,
            node.terms.map(buildMatchGraph),
            false
          );
          if (node.disallowEmpty) {
            result = createCondition(
              result,
              DISALLOW_EMPTY,
              MISMATCH
            );
          }
          return result;
        case "Multiplier":
          return buildMultiplierMatchGraph(node);
        case "Type":
        case "Property":
          return {
            type: node.type,
            name: node.name,
            syntax: node
          };
        case "Keyword":
          return {
            type: node.type,
            name: node.name.toLowerCase(),
            syntax: node
          };
        case "AtKeyword":
          return {
            type: node.type,
            name: "@" + node.name.toLowerCase(),
            syntax: node
          };
        case "Function":
          return {
            type: node.type,
            name: node.name.toLowerCase() + "(",
            syntax: node
          };
        case "String":
          if (node.value.length === 3) {
            return {
              type: "Token",
              value: node.value.charAt(1),
              syntax: node
            };
          }
          return {
            type: node.type,
            value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
            syntax: node
          };
        case "Token":
          return {
            type: node.type,
            value: node.value,
            syntax: node
          };
        case "Comma":
          return {
            type: node.type,
            syntax: node
          };
        default:
          throw new Error("Unknown node type:", node.type);
      }
    }
    module2.exports = {
      MATCH,
      MISMATCH,
      DISALLOW_EMPTY,
      buildMatchGraph: function(syntaxTree, ref) {
        if (typeof syntaxTree === "string") {
          syntaxTree = parse(syntaxTree);
        }
        return {
          type: "MatchGraph",
          match: buildMatchGraph(syntaxTree),
          syntax: ref || null,
          source: syntaxTree
        };
      }
    };
  }
});

// node_modules/css-tree/lib/lexer/match.js
var require_match = __commonJS({
  "node_modules/css-tree/lib/lexer/match.js"(exports2, module2) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var matchGraph = require_match_graph();
    var MATCH = matchGraph.MATCH;
    var MISMATCH = matchGraph.MISMATCH;
    var DISALLOW_EMPTY = matchGraph.DISALLOW_EMPTY;
    var TYPE = require_const().TYPE;
    var STUB = 0;
    var TOKEN = 1;
    var OPEN_SYNTAX = 2;
    var CLOSE_SYNTAX = 3;
    var EXIT_REASON_MATCH = "Match";
    var EXIT_REASON_MISMATCH = "Mismatch";
    var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
    var ITERATION_LIMIT = 15e3;
    var totalIterationCount = 0;
    function reverseList(list) {
      var prev = null;
      var next = null;
      var item = list;
      while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
      }
      return prev;
    }
    function areStringsEqualCaseInsensitive(testStr, referenceStr) {
      if (testStr.length !== referenceStr.length) {
        return false;
      }
      for (var i = 0; i < testStr.length; i++) {
        var testCode = testStr.charCodeAt(i);
        var referenceCode = referenceStr.charCodeAt(i);
        if (testCode >= 65 && testCode <= 90) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function isContextEdgeDelim(token) {
      if (token.type !== TYPE.Delim) {
        return false;
      }
      return token.value !== "?";
    }
    function isCommaContextStart(token) {
      if (token === null) {
        return true;
      }
      return token.type === TYPE.Comma || token.type === TYPE.Function || token.type === TYPE.LeftParenthesis || token.type === TYPE.LeftSquareBracket || token.type === TYPE.LeftCurlyBracket || isContextEdgeDelim(token);
    }
    function isCommaContextEnd(token) {
      if (token === null) {
        return true;
      }
      return token.type === TYPE.RightParenthesis || token.type === TYPE.RightSquareBracket || token.type === TYPE.RightCurlyBracket || token.type === TYPE.Delim;
    }
    function internalMatch(tokens, state, syntaxes) {
      function moveToNextToken() {
        do {
          tokenIndex++;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === TYPE.WhiteSpace || token.type === TYPE.Comment));
      }
      function getNextToken(offset) {
        var nextIndex = tokenIndex + offset;
        return nextIndex < tokens.length ? tokens[nextIndex] : null;
      }
      function stateSnapshotFromSyntax(nextState, prev) {
        return {
          nextState,
          matchStack,
          syntaxStack,
          thenStack,
          tokenIndex,
          prev
        };
      }
      function pushThenStack(nextState) {
        thenStack = {
          nextState,
          matchStack,
          syntaxStack,
          prev: thenStack
        };
      }
      function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
      }
      function addTokenToMatch() {
        matchStack = {
          type: TOKEN,
          syntax: state.syntax,
          token,
          prev: matchStack
        };
        moveToNextToken();
        syntaxStash = null;
        if (tokenIndex > longestMatch) {
          longestMatch = tokenIndex;
        }
      }
      function openSyntax() {
        syntaxStack = {
          syntax: state.syntax,
          opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
          prev: syntaxStack
        };
        matchStack = {
          type: OPEN_SYNTAX,
          syntax: state.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
          matchStack = matchStack.prev;
        } else {
          matchStack = {
            type: CLOSE_SYNTAX,
            syntax: syntaxStack.syntax,
            token: matchStack.token,
            prev: matchStack
          };
        }
        syntaxStack = syntaxStack.prev;
      }
      var syntaxStack = null;
      var thenStack = null;
      var elseStack = null;
      var syntaxStash = null;
      var iterationCount = 0;
      var exitReason = null;
      var token = null;
      var tokenIndex = -1;
      var longestMatch = 0;
      var matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
      };
      moveToNextToken();
      while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        switch (state.type) {
          case "Match":
            if (thenStack === null) {
              if (token !== null) {
                if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                  state = MISMATCH;
                  break;
                }
              }
              exitReason = EXIT_REASON_MATCH;
              break;
            }
            state = thenStack.nextState;
            if (state === DISALLOW_EMPTY) {
              if (thenStack.matchStack === matchStack) {
                state = MISMATCH;
                break;
              } else {
                state = MATCH;
              }
            }
            while (thenStack.syntaxStack !== syntaxStack) {
              closeSyntax();
            }
            thenStack = thenStack.prev;
            break;
          case "Mismatch":
            if (syntaxStash !== null && syntaxStash !== false) {
              if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                elseStack = syntaxStash;
                syntaxStash = false;
              }
            } else if (elseStack === null) {
              exitReason = EXIT_REASON_MISMATCH;
              break;
            }
            state = elseStack.nextState;
            thenStack = elseStack.thenStack;
            syntaxStack = elseStack.syntaxStack;
            matchStack = elseStack.matchStack;
            tokenIndex = elseStack.tokenIndex;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
            elseStack = elseStack.prev;
            break;
          case "MatchGraph":
            state = state.match;
            break;
          case "If":
            if (state.else !== MISMATCH) {
              pushElseStack(state.else);
            }
            if (state.then !== MATCH) {
              pushThenStack(state.then);
            }
            state = state.match;
            break;
          case "MatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state,
              index: 0,
              mask: 0
            };
            break;
          case "MatchOnceBuffer":
            var terms = state.syntax.terms;
            if (state.index === terms.length) {
              if (state.mask === 0 || state.syntax.all) {
                state = MISMATCH;
                break;
              }
              state = MATCH;
              break;
            }
            if (state.mask === (1 << terms.length) - 1) {
              state = MATCH;
              break;
            }
            for (; state.index < terms.length; state.index++) {
              var matchFlag = 1 << state.index;
              if ((state.mask & matchFlag) === 0) {
                pushElseStack(state);
                pushThenStack({
                  type: "AddMatchOnce",
                  syntax: state.syntax,
                  mask: state.mask | matchFlag
                });
                state = terms[state.index++];
                break;
              }
            }
            break;
          case "AddMatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state.syntax,
              index: 0,
              mask: state.mask
            };
            break;
          case "Enum":
            if (token !== null) {
              var name = token.value.toLowerCase();
              if (name.indexOf("\\") !== -1) {
                name = name.replace(/\\[09].*$/, "");
              }
              if (hasOwnProperty2.call(state.map, name)) {
                state = state.map[name];
                break;
              }
            }
            state = MISMATCH;
            break;
          case "Generic":
            var opts = syntaxStack !== null ? syntaxStack.opts : null;
            var lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
            if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
              while (tokenIndex < lastTokenIndex) {
                addTokenToMatch();
              }
              state = MATCH;
            } else {
              state = MISMATCH;
            }
            break;
          case "Type":
          case "Property":
            var syntaxDict = state.type === "Type" ? "types" : "properties";
            var dictSyntax = hasOwnProperty2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
            if (!dictSyntax || !dictSyntax.match) {
              throw new Error(
                "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
              );
            }
            if (syntaxStash !== false && token !== null && state.type === "Type") {
              var lowPriorityMatching = (
                // https://drafts.csswg.org/css-values-4/#custom-idents
                // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                // can only claim the keyword if no other unfulfilled production can claim it.
                state.name === "custom-ident" && token.type === TYPE.Ident || // https://drafts.csswg.org/css-values-4/#lengths
                // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                // it must parse as a <number>
                state.name === "length" && token.value === "0"
              );
              if (lowPriorityMatching) {
                if (syntaxStash === null) {
                  syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                }
                state = MISMATCH;
                break;
              }
            }
            openSyntax();
            state = dictSyntax.match;
            break;
          case "Keyword":
            var name = state.name;
            if (token !== null) {
              var keywordName = token.value;
              if (keywordName.indexOf("\\") !== -1) {
                keywordName = keywordName.replace(/\\[09].*$/, "");
              }
              if (areStringsEqualCaseInsensitive(keywordName, name)) {
                addTokenToMatch();
                state = MATCH;
                break;
              }
            }
            state = MISMATCH;
            break;
          case "AtKeyword":
          case "Function":
            if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
              addTokenToMatch();
              state = MATCH;
              break;
            }
            state = MISMATCH;
            break;
          case "Token":
            if (token !== null && token.value === state.value) {
              addTokenToMatch();
              state = MATCH;
              break;
            }
            state = MISMATCH;
            break;
          case "Comma":
            if (token !== null && token.type === TYPE.Comma) {
              if (isCommaContextStart(matchStack.token)) {
                state = MISMATCH;
              } else {
                addTokenToMatch();
                state = isCommaContextEnd(token) ? MISMATCH : MATCH;
              }
            } else {
              state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
            }
            break;
          case "String":
            var string = "";
            for (var lastTokenIndex = tokenIndex; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
              string += tokens[lastTokenIndex].value;
            }
            if (areStringsEqualCaseInsensitive(string, state.value)) {
              while (tokenIndex < lastTokenIndex) {
                addTokenToMatch();
              }
              state = MATCH;
            } else {
              state = MISMATCH;
            }
            break;
          default:
            throw new Error("Unknown node type: " + state.type);
        }
      }
      totalIterationCount += iterationCount;
      switch (exitReason) {
        case null:
          console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
          exitReason = EXIT_REASON_ITERATION_LIMIT;
          matchStack = null;
          break;
        case EXIT_REASON_MATCH:
          while (syntaxStack !== null) {
            closeSyntax();
          }
          break;
        default:
          matchStack = null;
      }
      return {
        tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch
      };
    }
    function matchAsList(tokens, matchGraph2, syntaxes) {
      var matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match !== null) {
        var item = reverseList(matchResult.match).prev;
        matchResult.match = [];
        while (item !== null) {
          switch (item.type) {
            case STUB:
              break;
            case OPEN_SYNTAX:
            case CLOSE_SYNTAX:
              matchResult.match.push({
                type: item.type,
                syntax: item.syntax
              });
              break;
            default:
              matchResult.match.push({
                token: item.token.value,
                node: item.token.node
              });
              break;
          }
          item = item.prev;
        }
      }
      return matchResult;
    }
    function matchAsTree(tokens, matchGraph2, syntaxes) {
      var matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match === null) {
        return matchResult;
      }
      var item = matchResult.match;
      var host = matchResult.match = {
        syntax: matchGraph2.syntax || null,
        match: []
      };
      var hostStack = [host];
      item = reverseList(item).prev;
      while (item !== null) {
        switch (item.type) {
          case OPEN_SYNTAX:
            host.match.push(host = {
              syntax: item.syntax,
              match: []
            });
            hostStack.push(host);
            break;
          case CLOSE_SYNTAX:
            hostStack.pop();
            host = hostStack[hostStack.length - 1];
            break;
          default:
            host.match.push({
              syntax: item.syntax || null,
              token: item.token.value,
              node: item.token.node
            });
        }
        item = item.prev;
      }
      return matchResult;
    }
    module2.exports = {
      matchAsList,
      matchAsTree,
      getTotalIterationCount: function() {
        return totalIterationCount;
      }
    };
  }
});

// node_modules/css-tree/lib/lexer/trace.js
var require_trace = __commonJS({
  "node_modules/css-tree/lib/lexer/trace.js"(exports2, module2) {
    function getTrace(node) {
      function shouldPutToTrace(syntax) {
        if (syntax === null) {
          return false;
        }
        return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
      }
      function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
          for (var i = 0; i < matchNode.match.length; i++) {
            if (hasMatch(matchNode.match[i])) {
              if (shouldPutToTrace(matchNode.syntax)) {
                result.unshift(matchNode.syntax);
              }
              return true;
            }
          }
        } else if (matchNode.node === node) {
          result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
          return true;
        }
        return false;
      }
      var result = null;
      if (this.matched !== null) {
        hasMatch(this.matched);
      }
      return result;
    }
    function testNode(match, node, fn) {
      var trace = getTrace.call(match, node);
      if (trace === null) {
        return false;
      }
      return trace.some(fn);
    }
    function isType(node, type) {
      return testNode(this, node, function(matchNode) {
        return matchNode.type === "Type" && matchNode.name === type;
      });
    }
    function isProperty(node, property) {
      return testNode(this, node, function(matchNode) {
        return matchNode.type === "Property" && matchNode.name === property;
      });
    }
    function isKeyword(node) {
      return testNode(this, node, function(matchNode) {
        return matchNode.type === "Keyword";
      });
    }
    module2.exports = {
      getTrace,
      isType,
      isProperty,
      isKeyword
    };
  }
});

// node_modules/css-tree/lib/lexer/search.js
var require_search = __commonJS({
  "node_modules/css-tree/lib/lexer/search.js"(exports2, module2) {
    var List = require_List();
    function getFirstMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getFirstMatchNode(matchNode.match[0]);
    }
    function getLastMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
    }
    function matchFragments(lexer, ast, match, type, name) {
      function findFragments(matchNode) {
        if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
          var start = getFirstMatchNode(matchNode);
          var end = getLastMatchNode(matchNode);
          lexer.syntax.walk(ast, function(node, item, list) {
            if (node === start) {
              var nodes = new List();
              do {
                nodes.appendData(item.data);
                if (item.data === end) {
                  break;
                }
                item = item.next;
              } while (item !== null);
              fragments.push({
                parent: list,
                nodes
              });
            }
          });
        }
        if (Array.isArray(matchNode.match)) {
          matchNode.match.forEach(findFragments);
        }
      }
      var fragments = [];
      if (match.matched !== null) {
        findFragments(match.matched);
      }
      return fragments;
    }
    module2.exports = {
      matchFragments
    };
  }
});

// node_modules/css-tree/lib/lexer/structure.js
var require_structure = __commonJS({
  "node_modules/css-tree/lib/lexer/structure.js"(exports2, module2) {
    var List = require_List();
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function isValidNumber(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
    }
    function isValidLocation(loc) {
      return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
    }
    function createNodeStructureChecker(type, fields) {
      return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
          return warn(node, "Type of node should be an Object");
        }
        for (var key in node) {
          var valid = true;
          if (hasOwnProperty2.call(node, key) === false) {
            continue;
          }
          if (key === "type") {
            if (node.type !== type) {
              warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
            }
          } else if (key === "loc") {
            if (node.loc === null) {
              continue;
            } else if (node.loc && node.loc.constructor === Object) {
              if (typeof node.loc.source !== "string") {
                key += ".source";
              } else if (!isValidLocation(node.loc.start)) {
                key += ".start";
              } else if (!isValidLocation(node.loc.end)) {
                key += ".end";
              } else {
                continue;
              }
            }
            valid = false;
          } else if (fields.hasOwnProperty(key)) {
            for (var i = 0, valid = false; !valid && i < fields[key].length; i++) {
              var fieldType = fields[key][i];
              switch (fieldType) {
                case String:
                  valid = typeof node[key] === "string";
                  break;
                case Boolean:
                  valid = typeof node[key] === "boolean";
                  break;
                case null:
                  valid = node[key] === null;
                  break;
                default:
                  if (typeof fieldType === "string") {
                    valid = node[key] && node[key].type === fieldType;
                  } else if (Array.isArray(fieldType)) {
                    valid = node[key] instanceof List;
                  }
              }
            }
          } else {
            warn(node, "Unknown field `" + key + "` for " + type + " node type");
          }
          if (!valid) {
            warn(node, "Bad value for `" + type + "." + key + "`");
          }
        }
        for (var key in fields) {
          if (hasOwnProperty2.call(fields, key) && hasOwnProperty2.call(node, key) === false) {
            warn(node, "Field `" + type + "." + key + "` is missed");
          }
        }
      };
    }
    function processStructure(name, nodeType) {
      var structure = nodeType.structure;
      var fields = {
        type: String,
        loc: true
      };
      var docs = {
        type: '"' + name + '"'
      };
      for (var key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        var docsTypes = [];
        var fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];
        for (var i = 0; i < fieldTypes.length; i++) {
          var fieldType = fieldTypes[i];
          if (fieldType === String || fieldType === Boolean) {
            docsTypes.push(fieldType.name);
          } else if (fieldType === null) {
            docsTypes.push("null");
          } else if (typeof fieldType === "string") {
            docsTypes.push("<" + fieldType + ">");
          } else if (Array.isArray(fieldType)) {
            docsTypes.push("List");
          } else {
            throw new Error("Wrong value `" + fieldType + "` in `" + name + "." + key + "` structure definition");
          }
        }
        docs[key] = docsTypes.join(" | ");
      }
      return {
        docs,
        check: createNodeStructureChecker(name, fields)
      };
    }
    module2.exports = {
      getStructureFromConfig: function(config) {
        var structure = {};
        if (config.node) {
          for (var name in config.node) {
            if (hasOwnProperty2.call(config.node, name)) {
              var nodeType = config.node[name];
              if (nodeType.structure) {
                structure[name] = processStructure(name, nodeType);
              } else {
                throw new Error("Missed `structure` field in `" + name + "` node type definition");
              }
            }
          }
        }
        return structure;
      }
    };
  }
});

// node_modules/css-tree/lib/lexer/Lexer.js
var require_Lexer = __commonJS({
  "node_modules/css-tree/lib/lexer/Lexer.js"(exports2, module2) {
    var SyntaxReferenceError = require_error().SyntaxReferenceError;
    var SyntaxMatchError = require_error().SyntaxMatchError;
    var names = require_names();
    var generic = require_generic();
    var parse = require_parse3();
    var generate = require_generate();
    var walk = require_walk();
    var prepareTokens = require_prepare_tokens();
    var buildMatchGraph = require_match_graph().buildMatchGraph;
    var matchAsTree = require_match().matchAsTree;
    var trace = require_trace();
    var search = require_search();
    var getStructureFromConfig = require_structure().getStructureFromConfig;
    var cssWideKeywords = buildMatchGraph("inherit | initial | unset");
    var cssWideKeywordsWithExpression = buildMatchGraph("inherit | initial | unset | <-ms-legacy-expression>");
    function dumpMapSyntax(map, compact, syntaxAsAst) {
      var result = {};
      for (var name in map) {
        if (map[name].syntax) {
          result[name] = syntaxAsAst ? map[name].syntax : generate(map[name].syntax, { compact });
        }
      }
      return result;
    }
    function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
      const result = {};
      for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
          prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate(atrule.prelude.syntax, { compact })),
          descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
      }
      return result;
    }
    function valueHasVar(tokens) {
      for (var i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === "var(") {
          return true;
        }
      }
      return false;
    }
    function buildMatchResult(match, error, iterations) {
      return {
        matched: match,
        iterations,
        error,
        getTrace: trace.getTrace,
        isType: trace.isType,
        isProperty: trace.isProperty,
        isKeyword: trace.isKeyword
      };
    }
    function matchSyntax(lexer, syntax, value, useCommon) {
      var tokens = prepareTokens(value, lexer.syntax);
      var result;
      if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
      }
      if (useCommon) {
        result = matchAsTree(tokens, lexer.valueCommonSyntax, lexer);
      }
      if (!useCommon || !result.match) {
        result = matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
          return buildMatchResult(
            null,
            new SyntaxMatchError(result.reason, syntax.syntax, value, result),
            result.iterations
          );
        }
      }
      return buildMatchResult(result.match, null, result.iterations);
    }
    var Lexer = function(config, syntax, structure) {
      this.valueCommonSyntax = cssWideKeywords;
      this.syntax = syntax;
      this.generic = false;
      this.atrules = {};
      this.properties = {};
      this.types = {};
      this.structure = structure || getStructureFromConfig(config);
      if (config) {
        if (config.types) {
          for (var name in config.types) {
            this.addType_(name, config.types[name]);
          }
        }
        if (config.generic) {
          this.generic = true;
          for (var name in generic) {
            this.addType_(name, generic[name]);
          }
        }
        if (config.atrules) {
          for (var name in config.atrules) {
            this.addAtrule_(name, config.atrules[name]);
          }
        }
        if (config.properties) {
          for (var name in config.properties) {
            this.addProperty_(name, config.properties[name]);
          }
        }
      }
    };
    Lexer.prototype = {
      structure: {},
      checkStructure: function(ast) {
        function collectWarning(node, message) {
          warns.push({
            node,
            message
          });
        }
        var structure = this.structure;
        var warns = [];
        this.syntax.walk(ast, function(node) {
          if (structure.hasOwnProperty(node.type)) {
            structure[node.type].check(node, collectWarning);
          } else {
            collectWarning(node, "Unknown node type `" + node.type + "`");
          }
        });
        return warns.length ? warns : false;
      },
      createDescriptor: function(syntax, type, name, parent = null) {
        var ref = {
          type,
          name
        };
        var descriptor = {
          type,
          name,
          parent,
          syntax: null,
          match: null
        };
        if (typeof syntax === "function") {
          descriptor.match = buildMatchGraph(syntax, ref);
        } else {
          if (typeof syntax === "string") {
            Object.defineProperty(descriptor, "syntax", {
              get: function() {
                Object.defineProperty(descriptor, "syntax", {
                  value: parse(syntax)
                });
                return descriptor.syntax;
              }
            });
          } else {
            descriptor.syntax = syntax;
          }
          Object.defineProperty(descriptor, "match", {
            get: function() {
              Object.defineProperty(descriptor, "match", {
                value: buildMatchGraph(descriptor.syntax, ref)
              });
              return descriptor.match;
            }
          });
        }
        return descriptor;
      },
      addAtrule_: function(name, syntax) {
        if (!syntax) {
          return;
        }
        this.atrules[name] = {
          type: "Atrule",
          name,
          prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name) : null,
          descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce((res, descName) => {
            res[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name);
            return res;
          }, {}) : null
        };
      },
      addProperty_: function(name, syntax) {
        if (!syntax) {
          return;
        }
        this.properties[name] = this.createDescriptor(syntax, "Property", name);
      },
      addType_: function(name, syntax) {
        if (!syntax) {
          return;
        }
        this.types[name] = this.createDescriptor(syntax, "Type", name);
        if (syntax === generic["-ms-legacy-expression"]) {
          this.valueCommonSyntax = cssWideKeywordsWithExpression;
        }
      },
      checkAtruleName: function(atruleName) {
        if (!this.getAtrule(atruleName)) {
          return new SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
        }
      },
      checkAtrulePrelude: function(atruleName, prelude) {
        let error = this.checkAtruleName(atruleName);
        if (error) {
          return error;
        }
        var atrule = this.getAtrule(atruleName);
        if (!atrule.prelude && prelude) {
          return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
        }
        if (atrule.prelude && !prelude) {
          return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
        }
      },
      checkAtruleDescriptorName: function(atruleName, descriptorName) {
        let error = this.checkAtruleName(atruleName);
        if (error) {
          return error;
        }
        var atrule = this.getAtrule(atruleName);
        var descriptor = names.keyword(descriptorName);
        if (!atrule.descriptors) {
          return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
        }
        if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
          return new SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
        }
      },
      checkPropertyName: function(propertyName) {
        var property = names.property(propertyName);
        if (property.custom) {
          return new Error("Lexer matching doesn't applicable for custom properties");
        }
        if (!this.getProperty(propertyName)) {
          return new SyntaxReferenceError("Unknown property", propertyName);
        }
      },
      matchAtrulePrelude: function(atruleName, prelude) {
        var error = this.checkAtrulePrelude(atruleName, prelude);
        if (error) {
          return buildMatchResult(null, error);
        }
        if (!prelude) {
          return buildMatchResult(null, null);
        }
        return matchSyntax(this, this.getAtrule(atruleName).prelude, prelude, false);
      },
      matchAtruleDescriptor: function(atruleName, descriptorName, value) {
        var error = this.checkAtruleDescriptorName(atruleName, descriptorName);
        if (error) {
          return buildMatchResult(null, error);
        }
        var atrule = this.getAtrule(atruleName);
        var descriptor = names.keyword(descriptorName);
        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
      },
      matchDeclaration: function(node) {
        if (node.type !== "Declaration") {
          return buildMatchResult(null, new Error("Not a Declaration node"));
        }
        return this.matchProperty(node.property, node.value);
      },
      matchProperty: function(propertyName, value) {
        var error = this.checkPropertyName(propertyName);
        if (error) {
          return buildMatchResult(null, error);
        }
        return matchSyntax(this, this.getProperty(propertyName), value, true);
      },
      matchType: function(typeName, value) {
        var typeSyntax = this.getType(typeName);
        if (!typeSyntax) {
          return buildMatchResult(null, new SyntaxReferenceError("Unknown type", typeName));
        }
        return matchSyntax(this, typeSyntax, value, false);
      },
      match: function(syntax, value) {
        if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
          return buildMatchResult(null, new SyntaxReferenceError("Bad syntax"));
        }
        if (typeof syntax === "string" || !syntax.match) {
          syntax = this.createDescriptor(syntax, "Type", "anonymous");
        }
        return matchSyntax(this, syntax, value, false);
      },
      findValueFragments: function(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
      },
      findDeclarationValueFragments: function(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
      },
      findAllFragments: function(ast, type, name) {
        var result = [];
        this.syntax.walk(ast, {
          visit: "Declaration",
          enter: function(declaration) {
            result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
          }.bind(this)
        });
        return result;
      },
      getAtrule: function(atruleName, fallbackBasename = true) {
        var atrule = names.keyword(atruleName);
        var atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
        return atruleEntry || null;
      },
      getAtrulePrelude: function(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);
        return atrule && atrule.prelude || null;
      },
      getAtruleDescriptor: function(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
      },
      getProperty: function(propertyName, fallbackBasename = true) {
        var property = names.property(propertyName);
        var propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
        return propertyEntry || null;
      },
      getType: function(name) {
        return this.types.hasOwnProperty(name) ? this.types[name] : null;
      },
      validate: function() {
        function validate(syntax, name, broken, descriptor) {
          if (broken.hasOwnProperty(name)) {
            return broken[name];
          }
          broken[name] = false;
          if (descriptor.syntax !== null) {
            walk(descriptor.syntax, function(node) {
              if (node.type !== "Type" && node.type !== "Property") {
                return;
              }
              var map = node.type === "Type" ? syntax.types : syntax.properties;
              var brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
              if (!map.hasOwnProperty(node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                broken[name] = true;
              }
            }, this);
          }
        }
        var brokenTypes = {};
        var brokenProperties = {};
        for (var key in this.types) {
          validate(this, key, brokenTypes, this.types[key]);
        }
        for (var key in this.properties) {
          validate(this, key, brokenProperties, this.properties[key]);
        }
        brokenTypes = Object.keys(brokenTypes).filter(function(name) {
          return brokenTypes[name];
        });
        brokenProperties = Object.keys(brokenProperties).filter(function(name) {
          return brokenProperties[name];
        });
        if (brokenTypes.length || brokenProperties.length) {
          return {
            types: brokenTypes,
            properties: brokenProperties
          };
        }
        return null;
      },
      dump: function(syntaxAsAst, pretty) {
        return {
          generic: this.generic,
          types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
          properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
          atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
      },
      toString: function() {
        return JSON.stringify(this.dump());
      }
    };
    module2.exports = Lexer;
  }
});

// node_modules/css-tree/lib/definition-syntax/index.js
var require_definition_syntax = __commonJS({
  "node_modules/css-tree/lib/definition-syntax/index.js"(exports2, module2) {
    module2.exports = {
      SyntaxError: require_SyntaxError2(),
      parse: require_parse3(),
      generate: require_generate(),
      walk: require_walk()
    };
  }
});

// node_modules/css-tree/lib/common/OffsetToLocation.js
var require_OffsetToLocation = __commonJS({
  "node_modules/css-tree/lib/common/OffsetToLocation.js"(exports2, module2) {
    var adoptBuffer = require_adopt_buffer();
    var isBOM = require_tokenizer().isBOM;
    var N = 10;
    var F = 12;
    var R = 13;
    function computeLinesAndColumns(host, source) {
      var sourceLength = source.length;
      var lines = adoptBuffer(host.lines, sourceLength);
      var line = host.startLine;
      var columns = adoptBuffer(host.columns, sourceLength);
      var column = host.startColumn;
      var startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
      for (var i = startOffset; i < sourceLength; i++) {
        var code = source.charCodeAt(i);
        lines[i] = line;
        columns[i] = column++;
        if (code === N || code === R || code === F) {
          if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
            i++;
            lines[i] = line;
            columns[i] = column;
          }
          line++;
          column = 1;
        }
      }
      lines[i] = line;
      columns[i] = column;
      host.lines = lines;
      host.columns = columns;
    }
    var OffsetToLocation = function() {
      this.lines = null;
      this.columns = null;
      this.linesAndColumnsComputed = false;
    };
    OffsetToLocation.prototype = {
      setSource: function(source, startOffset, startLine, startColumn) {
        this.source = source;
        this.startOffset = typeof startOffset === "undefined" ? 0 : startOffset;
        this.startLine = typeof startLine === "undefined" ? 1 : startLine;
        this.startColumn = typeof startColumn === "undefined" ? 1 : startColumn;
        this.linesAndColumnsComputed = false;
      },
      ensureLinesAndColumnsComputed: function() {
        if (!this.linesAndColumnsComputed) {
          computeLinesAndColumns(this, this.source);
          this.linesAndColumnsComputed = true;
        }
      },
      getLocation: function(offset, filename) {
        this.ensureLinesAndColumnsComputed();
        return {
          source: filename,
          offset: this.startOffset + offset,
          line: this.lines[offset],
          column: this.columns[offset]
        };
      },
      getLocationRange: function(start, end, filename) {
        this.ensureLinesAndColumnsComputed();
        return {
          source: filename,
          start: {
            offset: this.startOffset + start,
            line: this.lines[start],
            column: this.columns[start]
          },
          end: {
            offset: this.startOffset + end,
            line: this.lines[end],
            column: this.columns[end]
          }
        };
      }
    };
    module2.exports = OffsetToLocation;
  }
});

// node_modules/css-tree/lib/parser/sequence.js
var require_sequence = __commonJS({
  "node_modules/css-tree/lib/parser/sequence.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    module2.exports = function readSequence(recognizer) {
      var children = this.createList();
      var child = null;
      var context = {
        recognizer,
        space: null,
        ignoreWS: false,
        ignoreWSAfter: false
      };
      this.scanner.skipSC();
      while (!this.scanner.eof) {
        switch (this.scanner.tokenType) {
          case COMMENT:
            this.scanner.next();
            continue;
          case WHITESPACE:
            if (context.ignoreWS) {
              this.scanner.next();
            } else {
              context.space = this.WhiteSpace();
            }
            continue;
        }
        child = recognizer.getNode.call(this, context);
        if (child === void 0) {
          break;
        }
        if (context.space !== null) {
          children.push(context.space);
          context.space = null;
        }
        children.push(child);
        if (context.ignoreWSAfter) {
          context.ignoreWSAfter = false;
          context.ignoreWS = true;
        } else {
          context.ignoreWS = false;
        }
      }
      return children;
    };
  }
});

// node_modules/css-tree/lib/parser/create.js
var require_create = __commonJS({
  "node_modules/css-tree/lib/parser/create.js"(exports2, module2) {
    var OffsetToLocation = require_OffsetToLocation();
    var SyntaxError2 = require_SyntaxError();
    var TokenStream = require_TokenStream();
    var List = require_List();
    var tokenize = require_tokenizer();
    var constants = require_const();
    var { findWhiteSpaceStart, cmpStr } = require_utils();
    var sequence = require_sequence();
    var noop = function() {
    };
    var TYPE = constants.TYPE;
    var NAME = constants.NAME;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var FUNCTION = TYPE.Function;
    var URL = TYPE.Url;
    var HASH = TYPE.Hash;
    var PERCENTAGE = TYPE.Percentage;
    var NUMBER = TYPE.Number;
    var NUMBERSIGN = 35;
    var NULL = 0;
    function createParseContext(name) {
      return function() {
        return this[name]();
      };
    }
    function processConfig(config) {
      var parserConfig = {
        context: {},
        scope: {},
        atrule: {},
        pseudo: {}
      };
      if (config.parseContext) {
        for (var name in config.parseContext) {
          switch (typeof config.parseContext[name]) {
            case "function":
              parserConfig.context[name] = config.parseContext[name];
              break;
            case "string":
              parserConfig.context[name] = createParseContext(config.parseContext[name]);
              break;
          }
        }
      }
      if (config.scope) {
        for (var name in config.scope) {
          parserConfig.scope[name] = config.scope[name];
        }
      }
      if (config.atrule) {
        for (var name in config.atrule) {
          var atrule = config.atrule[name];
          if (atrule.parse) {
            parserConfig.atrule[name] = atrule.parse;
          }
        }
      }
      if (config.pseudo) {
        for (var name in config.pseudo) {
          var pseudo = config.pseudo[name];
          if (pseudo.parse) {
            parserConfig.pseudo[name] = pseudo.parse;
          }
        }
      }
      if (config.node) {
        for (var name in config.node) {
          parserConfig[name] = config.node[name].parse;
        }
      }
      return parserConfig;
    }
    module2.exports = function createParser(config) {
      var parser = {
        scanner: new TokenStream(),
        locationMap: new OffsetToLocation(),
        filename: "<unknown>",
        needPositions: false,
        onParseError: noop,
        onParseErrorThrow: false,
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,
        readSequence: sequence,
        createList: function() {
          return new List();
        },
        createSingleNodeList: function(node) {
          return new List().appendData(node);
        },
        getFirstListNode: function(list) {
          return list && list.first();
        },
        getLastListNode: function(list) {
          return list.last();
        },
        parseWithFallback: function(consumer, fallback) {
          var startToken = this.scanner.tokenIndex;
          try {
            return consumer.call(this);
          } catch (e) {
            if (this.onParseErrorThrow) {
              throw e;
            }
            var fallbackNode = fallback.call(this, startToken);
            this.onParseErrorThrow = true;
            this.onParseError(e, fallbackNode);
            this.onParseErrorThrow = false;
            return fallbackNode;
          }
        },
        lookupNonWSType: function(offset) {
          do {
            var type = this.scanner.lookupType(offset++);
            if (type !== WHITESPACE) {
              return type;
            }
          } while (type !== NULL);
          return NULL;
        },
        eat: function(tokenType) {
          if (this.scanner.tokenType !== tokenType) {
            var offset = this.scanner.tokenStart;
            var message = NAME[tokenType] + " is expected";
            switch (tokenType) {
              case IDENT:
                if (this.scanner.tokenType === FUNCTION || this.scanner.tokenType === URL) {
                  offset = this.scanner.tokenEnd - 1;
                  message = "Identifier is expected but function found";
                } else {
                  message = "Identifier is expected";
                }
                break;
              case HASH:
                if (this.scanner.isDelim(NUMBERSIGN)) {
                  this.scanner.next();
                  offset++;
                  message = "Name is expected";
                }
                break;
              case PERCENTAGE:
                if (this.scanner.tokenType === NUMBER) {
                  offset = this.scanner.tokenEnd;
                  message = "Percent sign is expected";
                }
                break;
              default:
                if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === tokenType) {
                  offset = offset + 1;
                }
            }
            this.error(message, offset);
          }
          this.scanner.next();
        },
        consume: function(tokenType) {
          var value = this.scanner.getTokenValue();
          this.eat(tokenType);
          return value;
        },
        consumeFunctionName: function() {
          var name = this.scanner.source.substring(this.scanner.tokenStart, this.scanner.tokenEnd - 1);
          this.eat(FUNCTION);
          return name;
        },
        getLocation: function(start, end) {
          if (this.needPositions) {
            return this.locationMap.getLocationRange(
              start,
              end,
              this.filename
            );
          }
          return null;
        },
        getLocationFromList: function(list) {
          if (this.needPositions) {
            var head = this.getFirstListNode(list);
            var tail = this.getLastListNode(list);
            return this.locationMap.getLocationRange(
              head !== null ? head.loc.start.offset - this.locationMap.startOffset : this.scanner.tokenStart,
              tail !== null ? tail.loc.end.offset - this.locationMap.startOffset : this.scanner.tokenStart,
              this.filename
            );
          }
          return null;
        },
        error: function(message, offset) {
          var location = typeof offset !== "undefined" && offset < this.scanner.source.length ? this.locationMap.getLocation(offset) : this.scanner.eof ? this.locationMap.getLocation(findWhiteSpaceStart(this.scanner.source, this.scanner.source.length - 1)) : this.locationMap.getLocation(this.scanner.tokenStart);
          throw new SyntaxError2(
            message || "Unexpected input",
            this.scanner.source,
            location.offset,
            location.line,
            location.column
          );
        }
      };
      config = processConfig(config || {});
      for (var key in config) {
        parser[key] = config[key];
      }
      return function(source, options) {
        options = options || {};
        var context = options.context || "default";
        var onComment = options.onComment;
        var ast;
        tokenize(source, parser.scanner);
        parser.locationMap.setSource(
          source,
          options.offset,
          options.line,
          options.column
        );
        parser.filename = options.filename || "<unknown>";
        parser.needPositions = Boolean(options.positions);
        parser.onParseError = typeof options.onParseError === "function" ? options.onParseError : noop;
        parser.onParseErrorThrow = false;
        parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
        if (!parser.context.hasOwnProperty(context)) {
          throw new Error("Unknown context `" + context + "`");
        }
        if (typeof onComment === "function") {
          parser.scanner.forEachToken((type, start, end) => {
            if (type === COMMENT) {
              const loc = parser.getLocation(start, end);
              const value = cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
              onComment(value, loc);
            }
          });
        }
        ast = parser.context[context].call(parser, options);
        if (!parser.scanner.eof) {
          parser.error();
        }
        return ast;
      };
    };
  }
});

// node_modules/source-map/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    function normalize(aPath) {
      var path = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path = url.path;
      }
      var isAbsolute = exports2.isAbsolute(path);
      var parts = path.split(/\/+/);
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path = parts.join("/");
      if (path === "") {
        path = isAbsolute ? "/" : ".";
      }
      if (url) {
        url.path = path;
        return urlGenerate(url);
      }
      return path;
    }
    exports2.normalize = normalize;
    function join(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative;
    var supportsNullProto = function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    }();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map/lib/array-set.js"(exports2) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/source-map/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map/lib/mapping-list.js"(exports2) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// node_modules/source-map/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator({
        file: aSourceMapConsumer.file,
        sourceRoot
      });
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        this._validateMapping(generated, original, source, name);
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        throw new Error(
          "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values."
        );
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        throw new Error("Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        }));
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/css-tree/lib/generator/sourceMap.js
var require_sourceMap = __commonJS({
  "node_modules/css-tree/lib/generator/sourceMap.js"(exports2, module2) {
    var SourceMapGenerator = require_source_map_generator().SourceMapGenerator;
    var trackNodes = {
      Atrule: true,
      Selector: true,
      Declaration: true
    };
    module2.exports = function generateSourceMap(handlers) {
      var map = new SourceMapGenerator();
      var line = 1;
      var column = 0;
      var generated = {
        line: 1,
        column: 0
      };
      var original = {
        line: 0,
        // should be zero to add first mapping
        column: 0
      };
      var sourceMappingActive = false;
      var activatedGenerated = {
        line: 1,
        column: 0
      };
      var activatedMapping = {
        generated: activatedGenerated
      };
      var handlersNode = handlers.node;
      handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.hasOwnProperty(node.type)) {
          var nodeLine = node.loc.start.line;
          var nodeColumn = node.loc.start.column - 1;
          if (original.line !== nodeLine || original.column !== nodeColumn) {
            original.line = nodeLine;
            original.column = nodeColumn;
            generated.line = line;
            generated.column = column;
            if (sourceMappingActive) {
              sourceMappingActive = false;
              if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
                map.addMapping(activatedMapping);
              }
            }
            sourceMappingActive = true;
            map.addMapping({
              source: node.loc.source,
              original,
              generated
            });
          }
        }
        handlersNode.call(this, node);
        if (sourceMappingActive && trackNodes.hasOwnProperty(node.type)) {
          activatedGenerated.line = line;
          activatedGenerated.column = column;
        }
      };
      var handlersChunk = handlers.chunk;
      handlers.chunk = function(chunk) {
        for (var i = 0; i < chunk.length; i++) {
          if (chunk.charCodeAt(i) === 10) {
            line++;
            column = 0;
          } else {
            column++;
          }
        }
        handlersChunk(chunk);
      };
      var handlersResult = handlers.result;
      handlers.result = function() {
        if (sourceMappingActive) {
          map.addMapping(activatedMapping);
        }
        return {
          css: handlersResult(),
          map
        };
      };
      return handlers;
    };
  }
});

// node_modules/css-tree/lib/generator/create.js
var require_create2 = __commonJS({
  "node_modules/css-tree/lib/generator/create.js"(exports2, module2) {
    var sourceMap = require_sourceMap();
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function processChildren(node, delimeter) {
      var list = node.children;
      var prev = null;
      if (typeof delimeter !== "function") {
        list.forEach(this.node, this);
      } else {
        list.forEach(function(node2) {
          if (prev !== null) {
            delimeter.call(this, prev);
          }
          this.node(node2);
          prev = node2;
        }, this);
      }
    }
    module2.exports = function createGenerator(config) {
      function processNode(node) {
        if (hasOwnProperty2.call(types, node.type)) {
          types[node.type].call(this, node);
        } else {
          throw new Error("Unknown node type: " + node.type);
        }
      }
      var types = {};
      if (config.node) {
        for (var name in config.node) {
          types[name] = config.node[name].generate;
        }
      }
      return function(node, options) {
        var buffer = "";
        var handlers = {
          children: processChildren,
          node: processNode,
          chunk: function(chunk) {
            buffer += chunk;
          },
          result: function() {
            return buffer;
          }
        };
        if (options) {
          if (typeof options.decorator === "function") {
            handlers = options.decorator(handlers);
          }
          if (options.sourceMap) {
            handlers = sourceMap(handlers);
          }
        }
        handlers.node(node);
        return handlers.result();
      };
    };
  }
});

// node_modules/css-tree/lib/convertor/create.js
var require_create3 = __commonJS({
  "node_modules/css-tree/lib/convertor/create.js"(exports2, module2) {
    var List = require_List();
    module2.exports = function createConvertors(walk) {
      return {
        fromPlainObject: function(ast) {
          walk(ast, {
            enter: function(node) {
              if (node.children && node.children instanceof List === false) {
                node.children = new List().fromArray(node.children);
              }
            }
          });
          return ast;
        },
        toPlainObject: function(ast) {
          walk(ast, {
            leave: function(node) {
              if (node.children && node.children instanceof List) {
                node.children = node.children.toArray();
              }
            }
          });
          return ast;
        }
      };
    };
  }
});

// node_modules/css-tree/lib/walker/create.js
var require_create4 = __commonJS({
  "node_modules/css-tree/lib/walker/create.js"(exports2, module2) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    function invokeForType(fn, type) {
      return function(node, item, list) {
        if (node.type === type) {
          fn.call(this, node, item, list);
        }
      };
    }
    function getWalkersFromStructure(name, nodeType) {
      var structure = nodeType.structure;
      var walkers = [];
      for (var key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        var fieldTypes = structure[key];
        var walker = {
          name: key,
          type: false,
          nullable: false
        };
        if (!Array.isArray(structure[key])) {
          fieldTypes = [structure[key]];
        }
        for (var i = 0; i < fieldTypes.length; i++) {
          var fieldType = fieldTypes[i];
          if (fieldType === null) {
            walker.nullable = true;
          } else if (typeof fieldType === "string") {
            walker.type = "node";
          } else if (Array.isArray(fieldType)) {
            walker.type = "list";
          }
        }
        if (walker.type) {
          walkers.push(walker);
        }
      }
      if (walkers.length) {
        return {
          context: nodeType.walkContext,
          fields: walkers
        };
      }
      return null;
    }
    function getTypesFromConfig(config) {
      var types = {};
      for (var name in config.node) {
        if (hasOwnProperty2.call(config.node, name)) {
          var nodeType = config.node[name];
          if (!nodeType.structure) {
            throw new Error("Missed `structure` field in `" + name + "` node type definition");
          }
          types[name] = getWalkersFromStructure(name, nodeType);
        }
      }
      return types;
    }
    function createTypeIterator(config, reverse) {
      var fields = config.fields.slice();
      var contextName = config.context;
      var useContext = typeof contextName === "string";
      if (reverse) {
        fields.reverse();
      }
      return function(node, context, walk, walkReducer) {
        var prevContextValue;
        if (useContext) {
          prevContextValue = context[contextName];
          context[contextName] = node;
        }
        for (var i = 0; i < fields.length; i++) {
          var field = fields[i];
          var ref = node[field.name];
          if (!field.nullable || ref) {
            if (field.type === "list") {
              var breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
              if (breakWalk) {
                return true;
              }
            } else if (walk(ref)) {
              return true;
            }
          }
        }
        if (useContext) {
          context[contextName] = prevContextValue;
        }
      };
    }
    function createFastTraveralMap(iterators) {
      return {
        Atrule: {
          StyleSheet: iterators.StyleSheet,
          Atrule: iterators.Atrule,
          Rule: iterators.Rule,
          Block: iterators.Block
        },
        Rule: {
          StyleSheet: iterators.StyleSheet,
          Atrule: iterators.Atrule,
          Rule: iterators.Rule,
          Block: iterators.Block
        },
        Declaration: {
          StyleSheet: iterators.StyleSheet,
          Atrule: iterators.Atrule,
          Rule: iterators.Rule,
          Block: iterators.Block,
          DeclarationList: iterators.DeclarationList
        }
      };
    }
    module2.exports = function createWalker(config) {
      var types = getTypesFromConfig(config);
      var iteratorsNatural = {};
      var iteratorsReverse = {};
      var breakWalk = Symbol("break-walk");
      var skipNode = Symbol("skip-node");
      for (var name in types) {
        if (hasOwnProperty2.call(types, name) && types[name] !== null) {
          iteratorsNatural[name] = createTypeIterator(types[name], false);
          iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
      }
      var fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
      var fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
      var walk = function(root, options) {
        function walkNode(node, item, list) {
          var enterRet = enter.call(context, node, item, list);
          if (enterRet === breakWalk) {
            debugger;
            return true;
          }
          if (enterRet === skipNode) {
            return false;
          }
          if (iterators.hasOwnProperty(node.type)) {
            if (iterators[node.type](node, context, walkNode, walkReducer)) {
              return true;
            }
          }
          if (leave.call(context, node, item, list) === breakWalk) {
            return true;
          }
          return false;
        }
        var walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        var enter = noop;
        var leave = noop;
        var iterators = iteratorsNatural;
        var context = {
          break: breakWalk,
          skip: skipNode,
          root,
          stylesheet: null,
          atrule: null,
          atrulePrelude: null,
          rule: null,
          selector: null,
          block: null,
          declaration: null,
          function: null
        };
        if (typeof options === "function") {
          enter = options;
        } else if (options) {
          enter = ensureFunction(options.enter);
          leave = ensureFunction(options.leave);
          if (options.reverse) {
            iterators = iteratorsReverse;
          }
          if (options.visit) {
            if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
              iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
            } else if (!types.hasOwnProperty(options.visit)) {
              throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).join(", ") + ")");
            }
            enter = invokeForType(enter, options.visit);
            leave = invokeForType(leave, options.visit);
          }
        }
        if (enter === noop && leave === noop) {
          throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
        }
        walkNode(root);
      };
      walk.break = breakWalk;
      walk.skip = skipNode;
      walk.find = function(ast, fn) {
        var found = null;
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found = node;
            return breakWalk;
          }
        });
        return found;
      };
      walk.findLast = function(ast, fn) {
        var found = null;
        walk(ast, {
          reverse: true,
          enter: function(node, item, list) {
            if (fn.call(this, node, item, list)) {
              found = node;
              return breakWalk;
            }
          }
        });
        return found;
      };
      walk.findAll = function(ast, fn) {
        var found = [];
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found.push(node);
          }
        });
        return found;
      };
      return walk;
    };
  }
});

// node_modules/css-tree/lib/utils/clone.js
var require_clone = __commonJS({
  "node_modules/css-tree/lib/utils/clone.js"(exports2, module2) {
    var List = require_List();
    module2.exports = function clone(node) {
      var result = {};
      for (var key in node) {
        var value = node[key];
        if (value) {
          if (Array.isArray(value) || value instanceof List) {
            value = value.map(clone);
          } else if (value.constructor === Object) {
            value = clone(value);
          }
        }
        result[key] = value;
      }
      return result;
    };
  }
});

// node_modules/css-tree/lib/syntax/config/mix.js
var require_mix = __commonJS({
  "node_modules/css-tree/lib/syntax/config/mix.js"(exports2, module2) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var shape = {
      generic: true,
      types: appendOrAssign,
      atrules: {
        prelude: appendOrAssignOrNull,
        descriptors: appendOrAssignOrNull
      },
      properties: appendOrAssign,
      parseContext: assign,
      scope: deepAssign,
      atrule: ["parse"],
      pseudo: ["parse"],
      node: ["name", "structure", "parse", "generate", "walkContext"]
    };
    function isObject(value) {
      return value && value.constructor === Object;
    }
    function copy(value) {
      return isObject(value) ? Object.assign({}, value) : value;
    }
    function assign(dest, src) {
      return Object.assign(dest, src);
    }
    function deepAssign(dest, src) {
      for (const key in src) {
        if (hasOwnProperty2.call(src, key)) {
          if (isObject(dest[key])) {
            deepAssign(dest[key], copy(src[key]));
          } else {
            dest[key] = copy(src[key]);
          }
        }
      }
      return dest;
    }
    function append(a, b) {
      if (typeof b === "string" && /^\s*\|/.test(b)) {
        return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
      }
      return b || null;
    }
    function appendOrAssign(a, b) {
      if (typeof b === "string") {
        return append(a, b);
      }
      const result = Object.assign({}, a);
      for (let key in b) {
        if (hasOwnProperty2.call(b, key)) {
          result[key] = append(hasOwnProperty2.call(a, key) ? a[key] : void 0, b[key]);
        }
      }
      return result;
    }
    function appendOrAssignOrNull(a, b) {
      const result = appendOrAssign(a, b);
      return !isObject(result) || Object.keys(result).length ? result : null;
    }
    function mix(dest, src, shape2) {
      for (const key in shape2) {
        if (hasOwnProperty2.call(shape2, key) === false) {
          continue;
        }
        if (shape2[key] === true) {
          if (key in src) {
            if (hasOwnProperty2.call(src, key)) {
              dest[key] = copy(src[key]);
            }
          }
        } else if (shape2[key]) {
          if (typeof shape2[key] === "function") {
            const fn = shape2[key];
            dest[key] = fn({}, dest[key]);
            dest[key] = fn(dest[key] || {}, src[key]);
          } else if (isObject(shape2[key])) {
            const result = {};
            for (let name in dest[key]) {
              result[name] = mix({}, dest[key][name], shape2[key]);
            }
            for (let name in src[key]) {
              result[name] = mix(result[name] || {}, src[key][name], shape2[key]);
            }
            dest[key] = result;
          } else if (Array.isArray(shape2[key])) {
            const res = {};
            const innerShape = shape2[key].reduce(function(s, k) {
              s[k] = true;
              return s;
            }, {});
            for (const [name, value] of Object.entries(dest[key] || {})) {
              res[name] = {};
              if (value) {
                mix(res[name], value, innerShape);
              }
            }
            for (const name in src[key]) {
              if (hasOwnProperty2.call(src[key], name)) {
                if (!res[name]) {
                  res[name] = {};
                }
                if (src[key] && src[key][name]) {
                  mix(res[name], src[key][name], innerShape);
                }
              }
            }
            dest[key] = res;
          }
        }
      }
      return dest;
    }
    module2.exports = (dest, src) => mix(dest, src, shape);
  }
});

// node_modules/css-tree/lib/syntax/create.js
var require_create5 = __commonJS({
  "node_modules/css-tree/lib/syntax/create.js"(exports2) {
    var List = require_List();
    var SyntaxError2 = require_SyntaxError();
    var TokenStream = require_TokenStream();
    var Lexer = require_Lexer();
    var definitionSyntax = require_definition_syntax();
    var tokenize = require_tokenizer();
    var createParser = require_create();
    var createGenerator = require_create2();
    var createConvertor = require_create3();
    var createWalker = require_create4();
    var clone = require_clone();
    var names = require_names();
    var mix = require_mix();
    function createSyntax(config) {
      var parse = createParser(config);
      var walk = createWalker(config);
      var generate = createGenerator(config);
      var convert = createConvertor(walk);
      var syntax = {
        List,
        SyntaxError: SyntaxError2,
        TokenStream,
        Lexer,
        vendorPrefix: names.vendorPrefix,
        keyword: names.keyword,
        property: names.property,
        isCustomProperty: names.isCustomProperty,
        definitionSyntax,
        lexer: null,
        createLexer: function(config2) {
          return new Lexer(config2, syntax, syntax.lexer.structure);
        },
        tokenize,
        parse,
        walk,
        generate,
        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,
        clone,
        fromPlainObject: convert.fromPlainObject,
        toPlainObject: convert.toPlainObject,
        createSyntax: function(config2) {
          return createSyntax(mix({}, config2));
        },
        fork: function(extension) {
          var base = mix({}, config);
          return createSyntax(
            typeof extension === "function" ? extension(base, Object.assign) : mix(base, extension)
          );
        }
      };
      syntax.lexer = new Lexer({
        generic: true,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
      }, syntax);
      return syntax;
    }
    exports2.create = function(config) {
      return createSyntax(mix({}, config));
    };
  }
});

// node_modules/mdn-data/css/at-rules.json
var require_at_rules = __commonJS({
  "node_modules/mdn-data/css/at-rules.json"(exports2, module2) {
    module2.exports = {
      "@charset": {
        syntax: '@charset "<charset>";',
        groups: [
          "CSS Charsets"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
      },
      "@counter-style": {
        syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
        interfaces: [
          "CSSCounterStyleRule"
        ],
        groups: [
          "CSS Counter Styles"
        ],
        descriptors: {
          "additive-symbols": {
            syntax: "[ <integer> && <symbol> ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          fallback: {
            syntax: "<counter-style-name>",
            media: "all",
            initial: "decimal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          negative: {
            syntax: "<symbol> <symbol>?",
            media: "all",
            initial: '"-" hyphen-minus',
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          pad: {
            syntax: "<integer> && <symbol>",
            media: "all",
            initial: '0 ""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          prefix: {
            syntax: "<symbol>",
            media: "all",
            initial: '""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          range: {
            syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "speak-as": {
            syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          suffix: {
            syntax: "<symbol>",
            media: "all",
            initial: '". "',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          symbols: {
            syntax: "<symbol>+",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          system: {
            syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
            media: "all",
            initial: "symbolic",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
      },
      "@document": {
        syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
      },
      "@font-face": {
        syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ]\n}",
        interfaces: [
          "CSSFontFaceRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        descriptors: {
          "font-display": {
            syntax: "[ auto | block | swap | fallback | optional ]",
            media: "visual",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "font-family": {
            syntax: "<family-name>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-feature-settings": {
            syntax: "normal | <feature-tag-value>#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-variation-settings": {
            syntax: "normal | [ <string> <number> ]#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-stretch": {
            syntax: "<font-stretch-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-style": {
            syntax: "normal | italic | oblique <angle>{0,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-weight": {
            syntax: "<font-weight-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-variant": {
            syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          src: {
            syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "unicode-range": {
            syntax: "<unicode-range>#",
            media: "all",
            initial: "U+0-10FFFF",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
      },
      "@font-feature-values": {
        syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
        interfaces: [
          "CSSFontFeatureValuesRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
      },
      "@import": {
        syntax: "@import [ <string> | <url> ] [ <media-query-list> ]?;",
        groups: [
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
      },
      "@keyframes": {
        syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
        interfaces: [
          "CSSKeyframeRule",
          "CSSKeyframesRule"
        ],
        groups: [
          "CSS Animations"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
      },
      "@media": {
        syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSMediaRule",
          "CSSCustomMediaRule"
        ],
        groups: [
          "CSS Conditional Rules",
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
      },
      "@namespace": {
        syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
        groups: [
          "CSS Namespaces"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
      },
      "@page": {
        syntax: "@page <page-selector-list> {\n  <page-body>\n}",
        interfaces: [
          "CSSPageRule"
        ],
        groups: [
          "CSS Pages"
        ],
        descriptors: {
          bleed: {
            syntax: "auto | <length>",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          marks: {
            syntax: "none | [ crop || cross ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "none",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          size: {
            syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecifiedRelativeToAbsoluteLengths",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
      },
      "@property": {
        syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
        interfaces: [
          "CSS",
          "CSSPropertyRule"
        ],
        groups: [
          "CSS Houdini"
        ],
        descriptors: {
          syntax: {
            syntax: "<string>",
            media: "all",
            percentages: "no",
            initial: "n/a (required)",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          inherits: {
            syntax: "true | false",
            media: "all",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "initial-value": {
            syntax: "<string>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          }
        },
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
      },
      "@supports": {
        syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSSupportsRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
      },
      "@viewport": {
        syntax: "@viewport {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSViewportRule"
        ],
        groups: [
          "CSS Device Adaptation"
        ],
        descriptors: {
          height: {
            syntax: "<viewport-length>{1,2}",
            media: [
              "visual",
              "continuous"
            ],
            initial: [
              "min-height",
              "max-height"
            ],
            percentages: [
              "min-height",
              "max-height"
            ],
            computed: [
              "min-height",
              "max-height"
            ],
            order: "orderOfAppearance",
            status: "standard"
          },
          "max-height": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToHeightOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "max-width": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToWidthOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "max-zoom": {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-height": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToHeightOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-width": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToWidthOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-zoom": {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          },
          orientation: {
            syntax: "auto | portrait | landscape",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToSizeOfBoundingBox",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "user-zoom": {
            syntax: "zoom | fixed",
            media: [
              "visual",
              "continuous"
            ],
            initial: "zoom",
            percentages: "referToSizeOfBoundingBox",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "viewport-fit": {
            syntax: "auto | contain | cover",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          width: {
            syntax: "<viewport-length>{1,2}",
            media: [
              "visual",
              "continuous"
            ],
            initial: [
              "min-width",
              "max-width"
            ],
            percentages: [
              "min-width",
              "max-width"
            ],
            computed: [
              "min-width",
              "max-width"
            ],
            order: "orderOfAppearance",
            status: "standard"
          },
          zoom: {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
      }
    };
  }
});

// node_modules/mdn-data/css/properties.json
var require_properties = __commonJS({
  "node_modules/mdn-data/css/properties.json"(exports2, module2) {
    module2.exports = {
      "--*": {
        syntax: "<declaration-value>",
        media: "all",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Variables"
        ],
        initial: "seeProse",
        appliesto: "allElements",
        computed: "asSpecifiedWithVarsSubstituted",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
      },
      "-ms-accelerator": {
        syntax: "false | true",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "false",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
      },
      "-ms-block-progression": {
        syntax: "tb | rl | bt | lr",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "tb",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
      },
      "-ms-content-zoom-chaining": {
        syntax: "none | chained",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
      },
      "-ms-content-zooming": {
        syntax: "none | zoom",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "zoomForTheTopLevelNoneForTheRest",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
      },
      "-ms-content-zoom-limit": {
        syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
      },
      "-ms-content-zoom-limit-max": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "maxZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "400%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
      },
      "-ms-content-zoom-limit-min": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "minZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "100%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
      },
      "-ms-content-zoom-snap": {
        syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
      },
      "-ms-content-zoom-snap-points": {
        syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0%, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
      },
      "-ms-content-zoom-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
      },
      "-ms-filter": {
        syntax: "<string>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: '""',
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
      },
      "-ms-flow-from": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
      },
      "-ms-flow-into": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "iframeElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
      },
      "-ms-grid-columns": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
      },
      "-ms-grid-rows": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
      },
      "-ms-high-contrast-adjust": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
      },
      "-ms-hyphenate-limit-chars": {
        syntax: "auto | <integer>{1,3}",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
      },
      "-ms-hyphenate-limit-lines": {
        syntax: "no-limit | <integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "no-limit",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
      },
      "-ms-hyphenate-limit-zone": {
        syntax: "<percentage> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "referToLineBoxWidth",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
      },
      "-ms-ime-align": {
        syntax: "auto | after",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
      },
      "-ms-overflow-style": {
        syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
      },
      "-ms-scrollbar-3dlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
      },
      "-ms-scrollbar-arrow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ButtonText",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
      },
      "-ms-scrollbar-base-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
      },
      "-ms-scrollbar-darkshadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
      },
      "-ms-scrollbar-face-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDFace",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
      },
      "-ms-scrollbar-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDHighlight",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
      },
      "-ms-scrollbar-shadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
      },
      "-ms-scrollbar-track-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "Scrollbar",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
      },
      "-ms-scroll-chaining": {
        syntax: "chained | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "chained",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
      },
      "-ms-scroll-limit": {
        syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
      },
      "-ms-scroll-limit-x-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
      },
      "-ms-scroll-limit-x-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
      },
      "-ms-scroll-limit-y-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
      },
      "-ms-scroll-limit-y-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
      },
      "-ms-scroll-rails": {
        syntax: "none | railed",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "railed",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
      },
      "-ms-scroll-snap-points-x": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
      },
      "-ms-scroll-snap-points-y": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
      },
      "-ms-scroll-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
      },
      "-ms-scroll-snap-x": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
      },
      "-ms-scroll-snap-y": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
      },
      "-ms-scroll-translation": {
        syntax: "none | vertical-to-horizontal",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
      },
      "-ms-text-autospace": {
        syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
      },
      "-ms-touch-select": {
        syntax: "grippers | none",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "grippers",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
      },
      "-ms-user-select": {
        syntax: "none | element | text",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "text",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
      },
      "-ms-wrap-flow": {
        syntax: "auto | both | start | end | maximum | clear",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
      },
      "-ms-wrap-margin": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "exclusionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
      },
      "-ms-wrap-through": {
        syntax: "wrap | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "wrap",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
      },
      "-moz-appearance": {
        syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-moz-binding": {
        syntax: "<url> | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
      },
      "-moz-border-bottom-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
      },
      "-moz-border-left-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
      },
      "-moz-border-right-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
      },
      "-moz-border-top-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
      },
      "-moz-context-properties": {
        syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsThatCanReferenceImages",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
      },
      "-moz-float-edge": {
        syntax: "border-box | content-box | margin-box | padding-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "content-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
      },
      "-moz-force-broken-image-icon": {
        syntax: "<integer [0,1]>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "images",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
      },
      "-moz-image-region": {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "xulImageElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
      },
      "-moz-orient": {
        syntax: "inline | block | horizontal | vertical",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "inline",
        appliesto: "anyElementEffectOnProgressAndMeter",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
      },
      "-moz-outline-radius": {
        syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        percentages: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        groups: [
          "Mozilla Extensions"
        ],
        initial: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        appliesto: "allElements",
        computed: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
      },
      "-moz-outline-radius-bottomleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
      },
      "-moz-outline-radius-bottomright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
      },
      "-moz-outline-radius-topleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
      },
      "-moz-outline-radius-topright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
      },
      "-moz-stack-sizing": {
        syntax: "ignore | stretch-to-fit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "stretch-to-fit",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
      },
      "-moz-text-blink": {
        syntax: "none | blink",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
      },
      "-moz-user-focus": {
        syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
      },
      "-moz-user-input": {
        syntax: "auto | none | enabled | disabled",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
      },
      "-moz-user-modify": {
        syntax: "read-only | read-write | write-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
      },
      "-moz-window-dragging": {
        syntax: "drag | no-drag",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "drag",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
      },
      "-moz-window-shadow": {
        syntax: "default | menu | tooltip | sheet | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "default",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
      },
      "-webkit-appearance": {
        syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-webkit-border-before": {
        syntax: "<'border-width'> || <'border-style'> || <'color'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: [
          "-webkit-border-before-width"
        ],
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "color"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
      },
      "-webkit-border-before-color": {
        syntax: "<'color'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "WebKit Extensions"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-box-reflect": {
        syntax: "[ above | below | right | left ]? <length>? <image>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
      },
      "-webkit-line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "WebKit Extensions",
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
      },
      "-webkit-mask": {
        syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "-webkit-mask-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
      },
      "-webkit-mask-clip": {
        syntax: "[ <box> | border | padding | content | text ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "border",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "-webkit-mask-composite": {
        syntax: "<composite-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "source-over",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
      },
      "-webkit-mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteURIOrNone",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "-webkit-mask-origin": {
        syntax: "[ <box> | border | padding | content ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "padding",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "-webkit-mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "-webkit-mask-position-x": {
        syntax: "[ <length-percentage> | left | center | right ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
      },
      "-webkit-mask-position-y": {
        syntax: "[ <length-percentage> | top | center | bottom ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
      },
      "-webkit-mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "-webkit-mask-repeat-x": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
      },
      "-webkit-mask-repeat-y": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
      },
      "-webkit-mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "-webkit-overflow-scrolling": {
        syntax: "auto | touch",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
      },
      "-webkit-tap-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "black",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
      },
      "-webkit-text-fill-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
      },
      "-webkit-text-stroke": {
        syntax: "<length> || <color>",
        media: "visual",
        inherited: true,
        animationType: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        order: "canonicalOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
      },
      "-webkit-text-stroke-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
      },
      "-webkit-text-stroke-width": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "absoluteLength",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
      },
      "-webkit-touch-callout": {
        syntax: "default | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "default",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
      },
      "-webkit-user-modify": {
        syntax: "read-only | read-write | read-write-plaintext-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "align-content": {
        syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multilineFlexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
      },
      "align-items": {
        syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
      },
      "align-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
        computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
      },
      "align-tracks": {
        syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
      },
      all: {
        syntax: "initial | inherit | unset | revert",
        media: "noPracticalMedia",
        inherited: false,
        animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "noPracticalInitialValue",
        appliesto: "allElements",
        computed: "asSpecifiedAppliesToEachProperty",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
      },
      animation: {
        syntax: "<single-animation>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-iteration-count",
          "animation-direction",
          "animation-fill-mode",
          "animation-play-state"
        ],
        appliesto: "allElementsAndPseudos",
        computed: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-direction",
          "animation-iteration-count",
          "animation-fill-mode",
          "animation-play-state"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
      },
      "animation-delay": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
      },
      "animation-direction": {
        syntax: "<single-animation-direction>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "normal",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
      },
      "animation-duration": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
      },
      "animation-fill-mode": {
        syntax: "<single-animation-fill-mode>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
      },
      "animation-iteration-count": {
        syntax: "<single-animation-iteration-count>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "1",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
      },
      "animation-name": {
        syntax: "[ none | <keyframes-name> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
      },
      "animation-play-state": {
        syntax: "<single-animation-play-state>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "running",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
      },
      "animation-timing-function": {
        syntax: "<timing-function>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
      },
      appearance: {
        syntax: "none | auto | textfield | menulist-button | <compat-auto>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "aspect-ratio": {
        syntax: "auto | <ratio>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
      },
      azimuth: {
        syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
        media: "aural",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Speech"
        ],
        initial: "center",
        appliesto: "allElements",
        computed: "normalizedAngle",
        order: "orderOfAppearance",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
      },
      "backdrop-filter": {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
      },
      "backface-visibility": {
        syntax: "visible | hidden",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "visible",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
      },
      background: {
        syntax: "[ <bg-layer> , ]* <final-bg-layer>",
        media: "visual",
        inherited: false,
        animationType: [
          "background-color",
          "background-image",
          "background-clip",
          "background-position",
          "background-size",
          "background-repeat",
          "background-attachment"
        ],
        percentages: [
          "background-position",
          "background-size"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        appliesto: "allElements",
        computed: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
      },
      "background-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
      },
      "background-blend-mode": {
        syntax: "<blend-mode>#",
        media: "none",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
      },
      "background-clip": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "border-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
      },
      "background-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "transparent",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
      },
      "background-image": {
        syntax: "<bg-image>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
      },
      "background-origin": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
      },
      "background-position": {
        syntax: "<bg-position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: "listEachItemTwoKeywordsOriginOffsets",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
      },
      "background-position-x": {
        syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "left",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
      },
      "background-position-y": {
        syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "top",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
      },
      "background-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "listEachItemHasTwoKeywordsOnePerDimension",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
      },
      "background-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
      },
      "block-overflow": {
        syntax: "clip | ellipsis | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "clip",
        appliesto: "blockContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "block-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
      },
      border: {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-color",
          "border-style",
          "border-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-width",
          "border-style",
          "border-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
      },
      "border-block": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
      },
      "border-block-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
      },
      "border-block-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
      },
      "border-block-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
      },
      "border-block-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
      },
      "border-block-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
      },
      "border-block-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
      },
      "border-block-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
      },
      "border-block-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-block-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
      },
      "border-block-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
      },
      "border-block-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
      },
      "border-block-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
      },
      "border-bottom": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-bottom-style",
          "border-bottom-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
      },
      "border-bottom-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
      },
      "border-bottom-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
      },
      "border-bottom-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
      },
      "border-bottom-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
      },
      "border-bottom-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
      },
      "border-collapse": {
        syntax: "collapse | separate",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "separate",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
      },
      "border-color": {
        syntax: "<color>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
      },
      "border-end-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
      },
      "border-end-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
      },
      "border-image": {
        syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "border-image-slice",
          "border-image-width"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-image-source",
          "border-image-slice",
          "border-image-width",
          "border-image-outset",
          "border-image-repeat"
        ],
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: [
          "border-image-outset",
          "border-image-repeat",
          "border-image-slice",
          "border-image-source",
          "border-image-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
      },
      "border-image-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
      },
      "border-image-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "stretch",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
      },
      "border-image-slice": {
        syntax: "<number-percentage>{1,4} && fill?",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSizeOfBorderImage",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "100%",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
        order: "percentagesOrLengthsFollowedByFill",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
      },
      "border-image-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "noneOrImageWithAbsoluteURI",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
      },
      "border-image-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToWidthOrHeightOfBorderImageArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "1",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
      },
      "border-inline": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
      },
      "border-inline-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-end-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
      },
      "border-inline-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
      },
      "border-inline-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
      },
      "border-inline-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
      },
      "border-inline-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
      },
      "border-inline-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
      },
      "border-inline-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
      },
      "border-inline-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <'color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
      },
      "border-inline-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
      },
      "border-inline-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
      },
      "border-inline-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
      },
      "border-left": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-left-color",
          "border-left-style",
          "border-left-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
      },
      "border-left-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
      },
      "border-left-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
      },
      "border-left-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
      },
      "border-radius": {
        syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: [
          "border-bottom-left-radius",
          "border-bottom-right-radius",
          "border-top-left-radius",
          "border-top-right-radius"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
      },
      "border-right": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-right-color",
          "border-right-style",
          "border-right-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
      },
      "border-right-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
      },
      "border-right-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
      },
      "border-right-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
      },
      "border-spacing": {
        syntax: "<length> <length>?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "0",
        appliesto: "tableElements",
        computed: "twoAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
      },
      "border-start-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
      },
      "border-start-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
      },
      "border-style": {
        syntax: "<line-style>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-style",
          "border-left-style",
          "border-right-style",
          "border-top-style"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
      },
      "border-top": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-color",
          "border-top-style",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
      },
      "border-top-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
      },
      "border-top-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
      },
      "border-top-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
      },
      "border-top-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
      },
      "border-top-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
      },
      "border-width": {
        syntax: "<line-width>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
      },
      bottom: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
      },
      "box-align": {
        syntax: "start | center | end | baseline | stretch",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "stretch",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
      },
      "box-decoration-break": {
        syntax: "slice | clone",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "slice",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
      },
      "box-direction": {
        syntax: "normal | reverse | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "normal",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
      },
      "box-flex": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
      },
      "box-flex-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "inFlowChildrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
      },
      "box-lines": {
        syntax: "single | multiple",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "single",
        appliesto: "boxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
      },
      "box-ordinal-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "childrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
      },
      "box-orient": {
        syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "inlineAxisHorizontalInXUL",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
      },
      "box-pack": {
        syntax: "start | center | end | justify",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "start",
        appliesto: "elementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
      },
      "box-shadow": {
        syntax: "none | <shadow>#",
        media: "visual",
        inherited: false,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteLengthsSpecifiedColorAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
      },
      "box-sizing": {
        syntax: "content-box | border-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "content-box",
        appliesto: "allElementsAcceptingWidthOrHeight",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
      },
      "break-after": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
      },
      "break-before": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
      },
      "break-inside": {
        syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
      },
      "caption-side": {
        syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "top",
        appliesto: "tableCaptionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
      },
      "caret-color": {
        syntax: "auto | <color>",
        media: "interactive",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asAutoOrColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
      },
      clear: {
        syntax: "none | left | right | both | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
      },
      clip: {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: false,
        animationType: "rectangle",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "absolutelyPositionedElements",
        computed: "autoOrRectangle",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
      },
      "clip-path": {
        syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
      },
      color: {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "variesFromBrowserToBrowser",
        appliesto: "allElements",
        computed: "translucentValuesRGBAOtherwiseRGB",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
      },
      "color-adjust": {
        syntax: "economy | exact",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "economy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-adjust"
      },
      "column-count": {
        syntax: "<integer> | auto",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
      },
      "column-fill": {
        syntax: "auto | balance | balance-all",
        media: "visualInContinuousMediaNoEffectInOverflowColumns",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "balance",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
      },
      "column-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "column-rule": {
        syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-rule-width",
          "column-rule-style",
          "column-rule-color"
        ],
        appliesto: "multicolElements",
        computed: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
      },
      "column-rule-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "currentcolor",
        appliesto: "multicolElements",
        computed: "computedColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
      },
      "column-rule-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
      },
      "column-rule-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "medium",
        appliesto: "multicolElements",
        computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
      },
      "column-span": {
        syntax: "none | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "inFlowBlockLevelElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
      },
      "column-width": {
        syntax: "<length> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "absoluteLengthZeroOrLarger",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
      },
      columns: {
        syntax: "<'column-width'> || <'column-count'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-width",
          "column-count"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-width",
          "column-count"
        ],
        appliesto: "blockContainersExceptTableWrappers",
        computed: [
          "column-width",
          "column-count"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
      },
      contain: {
        syntax: "none | strict | content | [ size || layout || style || paint ]",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
      },
      content: {
        syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ <string> ]?",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "normal",
        appliesto: "beforeAndAfterPseudos",
        computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
      },
      "counter-increment": {
        syntax: "[ <custom-ident> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
      },
      "counter-reset": {
        syntax: "[ <custom-ident> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
      },
      "counter-set": {
        syntax: "[ <custom-ident> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
      },
      cursor: {
        syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
      },
      direction: {
        syntax: "ltr | rtl",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "ltr",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
      },
      display: {
        syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Display"
        ],
        initial: "inline",
        appliesto: "allElements",
        computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
      },
      "empty-cells": {
        syntax: "show | hide",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "show",
        appliesto: "tableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
      },
      filter: {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
      },
      flex: {
        syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
        media: "visual",
        inherited: false,
        animationType: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        appliesto: "flexItemsAndInFlowPseudos",
        computed: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
      },
      "flex-basis": {
        syntax: "content | <'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToFlexContainersInnerMainSize",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "auto",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
      },
      "flex-direction": {
        syntax: "row | row-reverse | column | column-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "row",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
      },
      "flex-flow": {
        syntax: "<'flex-direction'> || <'flex-wrap'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-direction",
          "flex-wrap"
        ],
        appliesto: "flexContainers",
        computed: [
          "flex-direction",
          "flex-wrap"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
      },
      "flex-grow": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
      },
      "flex-shrink": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "1",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
      },
      "flex-wrap": {
        syntax: "nowrap | wrap | wrap-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "nowrap",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
      },
      float: {
        syntax: "left | right | none | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "allElementsNoEffectIfDisplayNone",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
      },
      font: {
        syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
        media: "visual",
        inherited: true,
        animationType: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        percentages: [
          "font-size",
          "line-height"
        ],
        groups: [
          "CSS Fonts"
        ],
        initial: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        appliesto: "allElements",
        computed: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
      },
      "font-family": {
        syntax: "[ <family-name> | <generic-family> ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
      },
      "font-feature-settings": {
        syntax: "normal | <feature-tag-value>#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
      },
      "font-kerning": {
        syntax: "auto | normal | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
      },
      "font-language-override": {
        syntax: "normal | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
      },
      "font-optical-sizing": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
      },
      "font-variation-settings": {
        syntax: "normal | [ <string> <number> ]#",
        media: "visual",
        inherited: true,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
      },
      "font-size": {
        syntax: "<absolute-size> | <relative-size> | <length-percentage>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToParentElementsFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
      },
      "font-size-adjust": {
        syntax: "none | <number>",
        media: "visual",
        inherited: true,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
      },
      "font-smooth": {
        syntax: "auto | never | always | <absolute-size> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
      },
      "font-stretch": {
        syntax: "<font-stretch-absolute>",
        media: "visual",
        inherited: true,
        animationType: "fontStretch",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
      },
      "font-style": {
        syntax: "normal | italic | oblique <angle>?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
      },
      "font-synthesis": {
        syntax: "none | [ weight || style ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "weight style",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
      },
      "font-variant": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
      },
      "font-variant-alternates": {
        syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
      },
      "font-variant-caps": {
        syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
      },
      "font-variant-east-asian": {
        syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
      },
      "font-variant-ligatures": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
      },
      "font-variant-numeric": {
        syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
      },
      "font-variant-position": {
        syntax: "normal | sub | super",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
      },
      "font-weight": {
        syntax: "<font-weight-absolute> | bolder | lighter",
        media: "visual",
        inherited: true,
        animationType: "fontWeight",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
      },
      gap: {
        syntax: "<'row-gap'> <'column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "row-gap",
          "column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "row-gap",
          "column-gap"
        ],
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: [
          "row-gap",
          "column-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      grid: {
        syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-auto-rows",
          "grid-auto-columns"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
      },
      "grid-area": {
        syntax: "<grid-line> [ / <grid-line> ]{0,3}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
      },
      "grid-auto-columns": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
      },
      "grid-auto-flow": {
        syntax: "[ row | column ] || dense",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "row",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
      },
      "grid-auto-rows": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
      },
      "grid-column": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-column-start",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-column-start",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
      },
      "grid-column-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
      },
      "grid-column-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "grid-column-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
      },
      "grid-gap": {
        syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      "grid-row": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-row-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-row-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
      },
      "grid-row-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
      },
      "grid-row-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "grid-row-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
      },
      "grid-template": {
        syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "grid-template-columns",
          "grid-template-rows"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
      },
      "grid-template-areas": {
        syntax: "none | <string>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
      },
      "grid-template-columns": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
      },
      "grid-template-rows": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
      },
      "hanging-punctuation": {
        syntax: "none | [ first || [ force-end | allow-end ] || last ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
      },
      height: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAutoOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
      },
      hyphens: {
        syntax: "none | manual | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "manual",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
      },
      "image-orientation": {
        syntax: "from-image | <angle> | [ <angle>? flip ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "from-image",
        appliesto: "allElements",
        computed: "angleRoundedToNextQuarter",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
      },
      "image-rendering": {
        syntax: "auto | crisp-edges | pixelated",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
      },
      "image-resolution": {
        syntax: "[ from-image || <resolution> ] && snap?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "1dppx",
        appliesto: "allElements",
        computed: "asSpecifiedWithExceptionOfResolution",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ime-mode": {
        syntax: "auto | normal | active | inactive | disabled",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "textFields",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
      },
      "initial-letter": {
        syntax: "normal | [ <number> <integer>? ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "normal",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
      },
      "initial-letter-align": {
        syntax: "[ auto | alphabetic | hanging | ideographic ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "auto",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
      },
      "inline-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
      },
      inset: {
        syntax: "<'top'>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
      },
      "inset-block": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
      },
      "inset-block-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
      },
      "inset-block-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
      },
      "inset-inline": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
      },
      "inset-inline-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
      },
      "inset-inline-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
      },
      isolation: {
        syntax: "auto | isolate",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
      },
      "justify-content": {
        syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
      },
      "justify-items": {
        syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "legacy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
      },
      "justify-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
      },
      "justify-tracks": {
        syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
      },
      left: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
      },
      "letter-spacing": {
        syntax: "normal | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "optimumValueOfAbsoluteLengthOrNormal",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
      },
      "line-break": {
        syntax: "auto | loose | normal | strict | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
      },
      "line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "line-height": {
        syntax: "normal | <number> | <length> | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "numberOrLength",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "absoluteLengthOrAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
      },
      "line-height-step": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "absoluteLength",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
      },
      "list-style": {
        syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: [
          "list-style-type",
          "list-style-position",
          "list-style-image"
        ],
        appliesto: "listItems",
        computed: [
          "list-style-image",
          "list-style-position",
          "list-style-type"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
      },
      "list-style-image": {
        syntax: "<url> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "none",
        appliesto: "listItems",
        computed: "noneOrImageWithAbsoluteURI",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
      },
      "list-style-position": {
        syntax: "inside | outside",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "outside",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
      },
      "list-style-type": {
        syntax: "<counter-style> | <string> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "disc",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
      },
      margin: {
        syntax: "[ <length> | <percentage> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
      },
      "margin-block": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
      },
      "margin-block-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
      },
      "margin-block-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
      },
      "margin-bottom": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
      },
      "margin-inline": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
      },
      "margin-inline-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
      },
      "margin-inline-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
      },
      "margin-left": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
      },
      "margin-right": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
      },
      "margin-top": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
      },
      "margin-trim": {
        syntax: "none | in-flow | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "blockContainersAndMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
      },
      mask: {
        syntax: "<mask-layer>#",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        percentages: [
          "mask-position"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "mask-border": {
        syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        percentages: [
          "mask-border-slice",
          "mask-border-width"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
      },
      "mask-border-mode": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "alpha",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
      },
      "mask-border-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
      },
      "mask-border-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "stretch",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
      },
      "mask-border-slice": {
        syntax: "<number-percentage>{1,4} fill?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfMaskBorderImage",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
      },
      "mask-border-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
      },
      "mask-border-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToMaskBorderImageArea",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
      },
      "mask-clip": {
        syntax: "[ <geometry-box> | no-clip ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "mask-composite": {
        syntax: "<compositing-operator>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "add",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
      },
      "mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "mask-mode": {
        syntax: "<masking-mode>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "match-source",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
      },
      "mask-origin": {
        syntax: "<geometry-box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToSizeOfMaskPaintingArea",
        groups: [
          "CSS Masking"
        ],
        initial: "center",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoKeywordsForOriginAndOffsets",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "no-repeat",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoDimensionKeywords",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "mask-type": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "luminance",
        appliesto: "maskElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
      },
      "masonry-auto-flow": {
        syntax: "[ pack | next ] || [ definite-first | ordered ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "pack",
        appliesto: "gridContainersWithMasonryLayout",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
      },
      "math-style": {
        syntax: "normal | compact",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "MathML"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
      },
      "max-block-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
      },
      "max-height": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
      },
      "max-inline-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
      },
      "max-lines": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "max-width": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
      },
      "min-block-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
      },
      "min-height": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
      },
      "min-inline-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
      },
      "min-width": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
      },
      "mix-blend-mode": {
        syntax: "<blend-mode>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
      },
      "object-fit": {
        syntax: "fill | contain | cover | none | scale-down",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "fill",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
      },
      "object-position": {
        syntax: "<position>",
        media: "visual",
        inherited: true,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToWidthAndHeightOfElement",
        groups: [
          "CSS Images"
        ],
        initial: "50% 50%",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
      },
      offset: {
        syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        percentages: [
          "offset-position",
          "offset-distance",
          "offset-anchor"
        ],
        groups: [
          "CSS Motion Path"
        ],
        initial: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        appliesto: "transformableElements",
        computed: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
      },
      "offset-anchor": {
        syntax: "auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "relativeToWidthAndHeight",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard"
      },
      "offset-distance": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToTotalPathLength",
        groups: [
          "CSS Motion Path"
        ],
        initial: "0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
      },
      "offset-path": {
        syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
        media: "visual",
        inherited: false,
        animationType: "angleOrBasicShapeOrPath",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
      },
      "offset-position": {
        syntax: "auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "referToSizeOfContainingBlock",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "experimental"
      },
      "offset-rotate": {
        syntax: "[ auto | reverse ] || <angle>",
        media: "visual",
        inherited: false,
        animationType: "angleOrBasicShapeOrPath",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
      },
      opacity: {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "1.0",
        appliesto: "allElements",
        computed: "specifiedValueClipped0To1",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
      },
      order: {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
      },
      orphans: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
      },
      outline: {
        syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: [
          "outline-color",
          "outline-width",
          "outline-style"
        ],
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: [
          "outline-color",
          "outline-style",
          "outline-width"
        ],
        appliesto: "allElements",
        computed: [
          "outline-color",
          "outline-width",
          "outline-style"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
      },
      "outline-color": {
        syntax: "<color> | invert",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "invertOrCurrentColor",
        appliesto: "allElements",
        computed: "invertForTranslucentColorRGBAOtherwiseRGB",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
      },
      "outline-offset": {
        syntax: "<length>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
      },
      "outline-style": {
        syntax: "auto | <'border-style'>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
      },
      "outline-width": {
        syntax: "<line-width>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLength0ForNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
      },
      overflow: {
        syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: [
          "overflow-x",
          "overflow-y"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
      },
      "overflow-anchor": {
        syntax: "auto | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Anchoring"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-block": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-clip-box": {
        syntax: "padding-box | content-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
      },
      "overflow-inline": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-wrap": {
        syntax: "normal | break-word | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "nonReplacedInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "overflow-x": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
      },
      "overflow-y": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
      },
      "overscroll-behavior": {
        syntax: "[ contain | none | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
      },
      "overscroll-behavior-block": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
      },
      "overscroll-behavior-inline": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
      },
      "overscroll-behavior-x": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
      },
      "overscroll-behavior-y": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
      },
      padding: {
        syntax: "[ <length> | <percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
      },
      "padding-block": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
      },
      "padding-block-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
      },
      "padding-block-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
      },
      "padding-bottom": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
      },
      "padding-inline": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
      },
      "padding-inline-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
      },
      "padding-inline-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
      },
      "padding-left": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
      },
      "padding-right": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
      },
      "padding-top": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
      },
      "page-break-after": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
      },
      "page-break-before": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
      },
      "page-break-inside": {
        syntax: "auto | avoid",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
      },
      "paint-order": {
        syntax: "normal | [ fill || stroke || markers ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
      },
      perspective: {
        syntax: "none | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "absoluteLengthOrNone",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
      },
      "perspective-origin": {
        syntax: "<position>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50%",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
      },
      "place-content": {
        syntax: "<'align-content'> <'justify-content'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multilineFlexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
      },
      "place-items": {
        syntax: "<'align-items'> <'justify-items'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-items",
          "justify-items"
        ],
        appliesto: "allElements",
        computed: [
          "align-items",
          "justify-items"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
      },
      "place-self": {
        syntax: "<'align-self'> <'justify-self'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-self",
          "justify-self"
        ],
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: [
          "align-self",
          "justify-self"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
      },
      "pointer-events": {
        syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Pointer Events"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
      },
      position: {
        syntax: "static | relative | absolute | sticky | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "static",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
      },
      quotes: {
        syntax: "none | auto | [ <string> <string> ]+",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
      },
      resize: {
        syntax: "none | both | horizontal | vertical | block | inline",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
      },
      right: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
      },
      rotate: {
        syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
      },
      "row-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "ruby-align": {
        syntax: "start | center | space-between | space-around",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "space-around",
        appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
      },
      "ruby-merge": {
        syntax: "separate | collapse | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "separate",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ruby-position": {
        syntax: "over | under | inter-character",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "over",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
      },
      scale: {
        syntax: "none | <number>{1,3}",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
      },
      "scrollbar-color": {
        syntax: "auto | dark | light | <color>{2}",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
      },
      "scrollbar-gutter": {
        syntax: "auto | [ stable | always ] && both? && force?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
      },
      "scrollbar-width": {
        syntax: "auto | thin | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
      },
      "scroll-behavior": {
        syntax: "auto | smooth",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSSOM View"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
      },
      "scroll-margin": {
        syntax: "<length>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
      },
      "scroll-margin-block": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
      },
      "scroll-margin-block-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
      },
      "scroll-margin-block-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
      },
      "scroll-margin-bottom": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
      },
      "scroll-margin-inline": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
      },
      "scroll-margin-inline-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
      },
      "scroll-margin-inline-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
      },
      "scroll-margin-left": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
      },
      "scroll-margin-right": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
      },
      "scroll-margin-top": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
      },
      "scroll-padding": {
        syntax: "[ auto | <length-percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
      },
      "scroll-padding-block": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
      },
      "scroll-padding-block-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
      },
      "scroll-padding-block-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
      },
      "scroll-padding-bottom": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
      },
      "scroll-padding-inline": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
      },
      "scroll-padding-inline-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
      },
      "scroll-padding-inline-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
      },
      "scroll-padding-left": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
      },
      "scroll-padding-right": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
      },
      "scroll-padding-top": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
      },
      "scroll-snap-align": {
        syntax: "[ none | start | end | center ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
      },
      "scroll-snap-coordinate": {
        syntax: "none | <position>#",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "referToBorderBox",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
      },
      "scroll-snap-destination": {
        syntax: "<position>",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0px 0px",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
      },
      "scroll-snap-points-x": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
      },
      "scroll-snap-points-y": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
      },
      "scroll-snap-stop": {
        syntax: "normal | always",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
      },
      "scroll-snap-type": {
        syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
      },
      "scroll-snap-type-x": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
      },
      "scroll-snap-type-y": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
      },
      "shape-image-threshold": {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "0.0",
        appliesto: "floats",
        computed: "specifiedValueNumberClipped0To1",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
      },
      "shape-margin": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Shapes"
        ],
        initial: "0",
        appliesto: "floats",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
      },
      "shape-outside": {
        syntax: "none | <shape-box> || <basic-shape> | <image>",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "none",
        appliesto: "floats",
        computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
      },
      "tab-size": {
        syntax: "<integer> | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "8",
        appliesto: "blockContainers",
        computed: "specifiedIntegerOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
      },
      "table-layout": {
        syntax: "auto | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "auto",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
      },
      "text-align": {
        syntax: "start | end | left | right | center | justify | match-parent",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "startOrNamelessValueIfLTRRightIfRTL",
        appliesto: "blockContainers",
        computed: "asSpecifiedExceptMatchParent",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
      },
      "text-align-last": {
        syntax: "auto | start | end | left | right | center | justify",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "blockContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
      },
      "text-combine-upright": {
        syntax: "none | all | [ digits <integer>? ]",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "none",
        appliesto: "nonReplacedInlineElements",
        computed: "keywordPlusIntegerIfDigits",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
      },
      "text-decoration": {
        syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
        media: "visual",
        inherited: false,
        animationType: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line",
          "text-decoration-thickness"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line"
        ],
        appliesto: "allElements",
        computed: [
          "text-decoration-line",
          "text-decoration-style",
          "text-decoration-color",
          "text-decoration-thickness"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
      },
      "text-decoration-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
      },
      "text-decoration-line": {
        syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
      },
      "text-decoration-skip": {
        syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "objects",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
      },
      "text-decoration-skip-ink": {
        syntax: "auto | all | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
      },
      "text-decoration-style": {
        syntax: "solid | double | dotted | dashed | wavy",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "solid",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
      },
      "text-decoration-thickness": {
        syntax: "auto | from-font | <length> | <percentage> ",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
      },
      "text-emphasis": {
        syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "text-emphasis-color",
          "text-emphasis-style"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        appliesto: "allElements",
        computed: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
      },
      "text-emphasis-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
      },
      "text-emphasis-position": {
        syntax: "[ over | under ] && [ right | left ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "over right",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
      },
      "text-emphasis-style": {
        syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
      },
      "text-indent": {
        syntax: "<length-percentage> && hanging? && each-line?",
        media: "visual",
        inherited: true,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Text"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "percentageOrAbsoluteLengthPlusKeywords",
        order: "lengthOrPercentageBeforeKeywords",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
      },
      "text-justify": {
        syntax: "auto | inter-character | inter-word | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
      },
      "text-orientation": {
        syntax: "mixed | upright | sideways",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "mixed",
        appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
      },
      "text-overflow": {
        syntax: "[ clip | ellipsis | <string> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "clip",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
      },
      "text-rendering": {
        syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "auto",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
      },
      "text-shadow": {
        syntax: "none | <shadow-t>#",
        media: "visual",
        inherited: true,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "colorPlusThreeAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
      },
      "text-size-adjust": {
        syntax: "none | auto | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "referToSizeOfFont",
        groups: [
          "CSS Text"
        ],
        initial: "autoForSmartphoneBrowsersSupportingInflation",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
      },
      "text-transform": {
        syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
      },
      "text-underline-offset": {
        syntax: "auto | <length> | <percentage> ",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
      },
      "text-underline-position": {
        syntax: "auto | from-font | [ under || [ left | right ] ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
      },
      top: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
      },
      "touch-action": {
        syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Pointer Events"
        ],
        initial: "auto",
        appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
      },
      transform: {
        syntax: "none | <transform-list>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
      },
      "transform-box": {
        syntax: "content-box | border-box | fill-box | stroke-box | view-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "view-box",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
      },
      "transform-origin": {
        syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50% 0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
      },
      "transform-style": {
        syntax: "flat | preserve-3d",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "flat",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
      },
      transition: {
        syntax: "<single-transition>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function"
        ],
        appliesto: "allElementsAndPseudos",
        computed: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
      },
      "transition-delay": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
      },
      "transition-duration": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
      },
      "transition-property": {
        syntax: "none | <single-transition-property>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "all",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
      },
      "transition-timing-function": {
        syntax: "<timing-function>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
      },
      translate: {
        syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
      },
      "unicode-bidi": {
        syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "normal",
        appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
      },
      "user-select": {
        syntax: "auto | text | none | contain | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
      },
      "vertical-align": {
        syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToLineHeight",
        groups: [
          "CSS Table"
        ],
        initial: "baseline",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "absoluteLengthOrKeyword",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
      },
      visibility: {
        syntax: "visible | hidden | collapse",
        media: "visual",
        inherited: true,
        animationType: "visibility",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "visible",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
      },
      "white-space": {
        syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
      },
      widows: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
      },
      width: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAutoOrAbsoluteLength",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
      },
      "will-change": {
        syntax: "auto | <animateable-feature>#",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Will Change"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
      },
      "word-break": {
        syntax: "normal | break-all | keep-all | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
      },
      "word-spacing": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToWidthOfAffectedGlyph",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
      },
      "word-wrap": {
        syntax: "normal | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "nonReplacedInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "writing-mode": {
        syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "horizontal-tb",
        appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
      },
      "z-index": {
        syntax: "auto | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
      },
      zoom: {
        syntax: "normal | reset | <number> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
      }
    };
  }
});

// node_modules/mdn-data/css/syntaxes.json
var require_syntaxes = __commonJS({
  "node_modules/mdn-data/css/syntaxes.json"(exports2, module2) {
    module2.exports = {
      "absolute-size": {
        syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
      },
      "alpha-value": {
        syntax: "<number> | <percentage>"
      },
      "angle-percentage": {
        syntax: "<angle> | <percentage>"
      },
      "angular-color-hint": {
        syntax: "<angle-percentage>"
      },
      "angular-color-stop": {
        syntax: "<color> && <color-stop-angle>?"
      },
      "angular-color-stop-list": {
        syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
      },
      "animateable-feature": {
        syntax: "scroll-position | contents | <custom-ident>"
      },
      attachment: {
        syntax: "scroll | fixed | local"
      },
      "attr()": {
        syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
      },
      "attr-matcher": {
        syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
      },
      "attr-modifier": {
        syntax: "i | s"
      },
      "attribute-selector": {
        syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
      },
      "auto-repeat": {
        syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "auto-track-list": {
        syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
      },
      "baseline-position": {
        syntax: "[ first | last ]? baseline"
      },
      "basic-shape": {
        syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
      },
      "bg-image": {
        syntax: "none | <image>"
      },
      "bg-layer": {
        syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "bg-position": {
        syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
      },
      "bg-size": {
        syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
      },
      "blur()": {
        syntax: "blur( <length> )"
      },
      "blend-mode": {
        syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
      },
      box: {
        syntax: "border-box | padding-box | content-box"
      },
      "brightness()": {
        syntax: "brightness( <number-percentage> )"
      },
      "calc()": {
        syntax: "calc( <calc-sum> )"
      },
      "calc-sum": {
        syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
      },
      "calc-product": {
        syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
      },
      "calc-value": {
        syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
      },
      "cf-final-image": {
        syntax: "<image> | <color>"
      },
      "cf-mixing-image": {
        syntax: "<percentage>? && <image>"
      },
      "circle()": {
        syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
      },
      "clamp()": {
        syntax: "clamp( <calc-sum>#{3} )"
      },
      "class-selector": {
        syntax: "'.' <ident-token>"
      },
      "clip-source": {
        syntax: "<url>"
      },
      color: {
        syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
      },
      "color-stop": {
        syntax: "<color-stop-length> | <color-stop-angle>"
      },
      "color-stop-angle": {
        syntax: "<angle-percentage>{1,2}"
      },
      "color-stop-length": {
        syntax: "<length-percentage>{1,2}"
      },
      "color-stop-list": {
        syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
      },
      combinator: {
        syntax: "'>' | '+' | '~' | [ '||' ]"
      },
      "common-lig-values": {
        syntax: "[ common-ligatures | no-common-ligatures ]"
      },
      "compat-auto": {
        syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
      },
      "composite-style": {
        syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
      },
      "compositing-operator": {
        syntax: "add | subtract | intersect | exclude"
      },
      "compound-selector": {
        syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
      },
      "compound-selector-list": {
        syntax: "<compound-selector>#"
      },
      "complex-selector": {
        syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
      },
      "complex-selector-list": {
        syntax: "<complex-selector>#"
      },
      "conic-gradient()": {
        syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "contextual-alt-values": {
        syntax: "[ contextual | no-contextual ]"
      },
      "content-distribution": {
        syntax: "space-between | space-around | space-evenly | stretch"
      },
      "content-list": {
        syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> ]+"
      },
      "content-position": {
        syntax: "center | start | end | flex-start | flex-end"
      },
      "content-replacement": {
        syntax: "<image>"
      },
      "contrast()": {
        syntax: "contrast( [ <number-percentage> ] )"
      },
      "counter()": {
        syntax: "counter( <custom-ident>, <counter-style>? )"
      },
      "counter-style": {
        syntax: "<counter-style-name> | symbols()"
      },
      "counter-style-name": {
        syntax: "<custom-ident>"
      },
      "counters()": {
        syntax: "counters( <custom-ident>, <string>, <counter-style>? )"
      },
      "cross-fade()": {
        syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
      },
      "cubic-bezier-timing-function": {
        syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
      },
      "deprecated-system-color": {
        syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
      },
      "discretionary-lig-values": {
        syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
      },
      "display-box": {
        syntax: "contents | none"
      },
      "display-inside": {
        syntax: "flow | flow-root | table | flex | grid | ruby"
      },
      "display-internal": {
        syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
      },
      "display-legacy": {
        syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
      },
      "display-listitem": {
        syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
      },
      "display-outside": {
        syntax: "block | inline | run-in"
      },
      "drop-shadow()": {
        syntax: "drop-shadow( <length>{2,3} <color>? )"
      },
      "east-asian-variant-values": {
        syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
      },
      "east-asian-width-values": {
        syntax: "[ full-width | proportional-width ]"
      },
      "element()": {
        syntax: "element( <id-selector> )"
      },
      "ellipse()": {
        syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
      },
      "ending-shape": {
        syntax: "circle | ellipse"
      },
      "env()": {
        syntax: "env( <custom-ident> , <declaration-value>? )"
      },
      "explicit-track-list": {
        syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
      },
      "family-name": {
        syntax: "<string> | <custom-ident>+"
      },
      "feature-tag-value": {
        syntax: "<string> [ <integer> | on | off ]?"
      },
      "feature-type": {
        syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
      },
      "feature-value-block": {
        syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
      },
      "feature-value-block-list": {
        syntax: "<feature-value-block>+"
      },
      "feature-value-declaration": {
        syntax: "<custom-ident>: <integer>+;"
      },
      "feature-value-declaration-list": {
        syntax: "<feature-value-declaration>"
      },
      "feature-value-name": {
        syntax: "<custom-ident>"
      },
      "fill-rule": {
        syntax: "nonzero | evenodd"
      },
      "filter-function": {
        syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
      },
      "filter-function-list": {
        syntax: "[ <filter-function> | <url> ]+"
      },
      "final-bg-layer": {
        syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "fit-content()": {
        syntax: "fit-content( [ <length> | <percentage> ] )"
      },
      "fixed-breadth": {
        syntax: "<length-percentage>"
      },
      "fixed-repeat": {
        syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "fixed-size": {
        syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
      },
      "font-stretch-absolute": {
        syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
      },
      "font-variant-css21": {
        syntax: "[ normal | small-caps ]"
      },
      "font-weight-absolute": {
        syntax: "normal | bold | <number [1,1000]>"
      },
      "frequency-percentage": {
        syntax: "<frequency> | <percentage>"
      },
      "general-enclosed": {
        syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
      },
      "generic-family": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "generic-name": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "geometry-box": {
        syntax: "<shape-box> | fill-box | stroke-box | view-box"
      },
      gradient: {
        syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()>"
      },
      "grayscale()": {
        syntax: "grayscale( <number-percentage> )"
      },
      "grid-line": {
        syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
      },
      "historical-lig-values": {
        syntax: "[ historical-ligatures | no-historical-ligatures ]"
      },
      "hsl()": {
        syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      "hsla()": {
        syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      hue: {
        syntax: "<number> | <angle>"
      },
      "hue-rotate()": {
        syntax: "hue-rotate( <angle> )"
      },
      "id-selector": {
        syntax: "<hash-token>"
      },
      image: {
        syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
      },
      "image()": {
        syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
      },
      "image-set()": {
        syntax: "image-set( <image-set-option># )"
      },
      "image-set-option": {
        syntax: "[ <image> | <string> ] <resolution>"
      },
      "image-src": {
        syntax: "<url> | <string>"
      },
      "image-tags": {
        syntax: "ltr | rtl"
      },
      "inflexible-breadth": {
        syntax: "<length> | <percentage> | min-content | max-content | auto"
      },
      "inset()": {
        syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
      },
      "invert()": {
        syntax: "invert( <number-percentage> )"
      },
      "keyframes-name": {
        syntax: "<custom-ident> | <string>"
      },
      "keyframe-block": {
        syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
      },
      "keyframe-block-list": {
        syntax: "<keyframe-block>+"
      },
      "keyframe-selector": {
        syntax: "from | to | <percentage>"
      },
      "leader()": {
        syntax: "leader( <leader-type> )"
      },
      "leader-type": {
        syntax: "dotted | solid | space | <string>"
      },
      "length-percentage": {
        syntax: "<length> | <percentage>"
      },
      "line-names": {
        syntax: "'[' <custom-ident>* ']'"
      },
      "line-name-list": {
        syntax: "[ <line-names> | <name-repeat> ]+"
      },
      "line-style": {
        syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
      },
      "line-width": {
        syntax: "<length> | thin | medium | thick"
      },
      "linear-color-hint": {
        syntax: "<length-percentage>"
      },
      "linear-color-stop": {
        syntax: "<color> <color-stop-length>?"
      },
      "linear-gradient()": {
        syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "mask-layer": {
        syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
      },
      "mask-position": {
        syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
      },
      "mask-reference": {
        syntax: "none | <image> | <mask-source>"
      },
      "mask-source": {
        syntax: "<url>"
      },
      "masking-mode": {
        syntax: "alpha | luminance | match-source"
      },
      "matrix()": {
        syntax: "matrix( <number>#{6} )"
      },
      "matrix3d()": {
        syntax: "matrix3d( <number>#{16} )"
      },
      "max()": {
        syntax: "max( <calc-sum># )"
      },
      "media-and": {
        syntax: "<media-in-parens> [ and <media-in-parens> ]+"
      },
      "media-condition": {
        syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
      },
      "media-condition-without-or": {
        syntax: "<media-not> | <media-and> | <media-in-parens>"
      },
      "media-feature": {
        syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
      },
      "media-in-parens": {
        syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
      },
      "media-not": {
        syntax: "not <media-in-parens>"
      },
      "media-or": {
        syntax: "<media-in-parens> [ or <media-in-parens> ]+"
      },
      "media-query": {
        syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
      },
      "media-query-list": {
        syntax: "<media-query>#"
      },
      "media-type": {
        syntax: "<ident>"
      },
      "mf-boolean": {
        syntax: "<mf-name>"
      },
      "mf-name": {
        syntax: "<ident>"
      },
      "mf-plain": {
        syntax: "<mf-name> : <mf-value>"
      },
      "mf-range": {
        syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
      },
      "mf-value": {
        syntax: "<number> | <dimension> | <ident> | <ratio>"
      },
      "min()": {
        syntax: "min( <calc-sum># )"
      },
      "minmax()": {
        syntax: "minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
      },
      "named-color": {
        syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
      },
      "namespace-prefix": {
        syntax: "<ident>"
      },
      "ns-prefix": {
        syntax: "[ <ident-token> | '*' ]? '|'"
      },
      "number-percentage": {
        syntax: "<number> | <percentage>"
      },
      "numeric-figure-values": {
        syntax: "[ lining-nums | oldstyle-nums ]"
      },
      "numeric-fraction-values": {
        syntax: "[ diagonal-fractions | stacked-fractions ]"
      },
      "numeric-spacing-values": {
        syntax: "[ proportional-nums | tabular-nums ]"
      },
      nth: {
        syntax: "<an-plus-b> | even | odd"
      },
      "opacity()": {
        syntax: "opacity( [ <number-percentage> ] )"
      },
      "overflow-position": {
        syntax: "unsafe | safe"
      },
      "outline-radius": {
        syntax: "<length> | <percentage>"
      },
      "page-body": {
        syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
      },
      "page-margin-box": {
        syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
      },
      "page-margin-box-type": {
        syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
      },
      "page-selector-list": {
        syntax: "[ <page-selector># ]?"
      },
      "page-selector": {
        syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
      },
      "path()": {
        syntax: "path( [ <fill-rule>, ]? <string> )"
      },
      "paint()": {
        syntax: "paint( <ident>, <declaration-value>? )"
      },
      "perspective()": {
        syntax: "perspective( <length> )"
      },
      "polygon()": {
        syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
      },
      position: {
        syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
      },
      "pseudo-class-selector": {
        syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
      },
      "pseudo-element-selector": {
        syntax: "':' <pseudo-class-selector>"
      },
      "pseudo-page": {
        syntax: ": [ left | right | first | blank ]"
      },
      quote: {
        syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
      },
      "radial-gradient()": {
        syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      "relative-selector": {
        syntax: "<combinator>? <complex-selector>"
      },
      "relative-selector-list": {
        syntax: "<relative-selector>#"
      },
      "relative-size": {
        syntax: "larger | smaller"
      },
      "repeat-style": {
        syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
      },
      "repeating-linear-gradient()": {
        syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "repeating-radial-gradient()": {
        syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      "rgb()": {
        syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
      },
      "rgba()": {
        syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
      },
      "rotate()": {
        syntax: "rotate( [ <angle> | <zero> ] )"
      },
      "rotate3d()": {
        syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
      },
      "rotateX()": {
        syntax: "rotateX( [ <angle> | <zero> ] )"
      },
      "rotateY()": {
        syntax: "rotateY( [ <angle> | <zero> ] )"
      },
      "rotateZ()": {
        syntax: "rotateZ( [ <angle> | <zero> ] )"
      },
      "saturate()": {
        syntax: "saturate( <number-percentage> )"
      },
      "scale()": {
        syntax: "scale( <number> , <number>? )"
      },
      "scale3d()": {
        syntax: "scale3d( <number> , <number> , <number> )"
      },
      "scaleX()": {
        syntax: "scaleX( <number> )"
      },
      "scaleY()": {
        syntax: "scaleY( <number> )"
      },
      "scaleZ()": {
        syntax: "scaleZ( <number> )"
      },
      "self-position": {
        syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
      },
      "shape-radius": {
        syntax: "<length-percentage> | closest-side | farthest-side"
      },
      "skew()": {
        syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
      },
      "skewX()": {
        syntax: "skewX( [ <angle> | <zero> ] )"
      },
      "skewY()": {
        syntax: "skewY( [ <angle> | <zero> ] )"
      },
      "sepia()": {
        syntax: "sepia( <number-percentage> )"
      },
      shadow: {
        syntax: "inset? && <length>{2,4} && <color>?"
      },
      "shadow-t": {
        syntax: "[ <length>{2,3} && <color>? ]"
      },
      shape: {
        syntax: "rect(<top>, <right>, <bottom>, <left>)"
      },
      "shape-box": {
        syntax: "<box> | margin-box"
      },
      "side-or-corner": {
        syntax: "[ left | right ] || [ top | bottom ]"
      },
      "single-animation": {
        syntax: "<time> || <timing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
      },
      "single-animation-direction": {
        syntax: "normal | reverse | alternate | alternate-reverse"
      },
      "single-animation-fill-mode": {
        syntax: "none | forwards | backwards | both"
      },
      "single-animation-iteration-count": {
        syntax: "infinite | <number>"
      },
      "single-animation-play-state": {
        syntax: "running | paused"
      },
      "single-transition": {
        syntax: "[ none | <single-transition-property> ] || <time> || <timing-function> || <time>"
      },
      "single-transition-property": {
        syntax: "all | <custom-ident>"
      },
      size: {
        syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
      },
      "step-position": {
        syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
      },
      "step-timing-function": {
        syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
      },
      "subclass-selector": {
        syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
      },
      "supports-condition": {
        syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
      },
      "supports-in-parens": {
        syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
      },
      "supports-feature": {
        syntax: "<supports-decl> | <supports-selector-fn>"
      },
      "supports-decl": {
        syntax: "( <declaration> )"
      },
      "supports-selector-fn": {
        syntax: "selector( <complex-selector> )"
      },
      symbol: {
        syntax: "<string> | <image> | <custom-ident>"
      },
      target: {
        syntax: "<target-counter()> | <target-counters()> | <target-text()>"
      },
      "target-counter()": {
        syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
      },
      "target-counters()": {
        syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
      },
      "target-text()": {
        syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
      },
      "time-percentage": {
        syntax: "<time> | <percentage>"
      },
      "timing-function": {
        syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
      },
      "track-breadth": {
        syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
      },
      "track-list": {
        syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
      },
      "track-repeat": {
        syntax: "repeat( [ <positive-integer> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
      },
      "track-size": {
        syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
      },
      "transform-function": {
        syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
      },
      "transform-list": {
        syntax: "<transform-function>+"
      },
      "translate()": {
        syntax: "translate( <length-percentage> , <length-percentage>? )"
      },
      "translate3d()": {
        syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
      },
      "translateX()": {
        syntax: "translateX( <length-percentage> )"
      },
      "translateY()": {
        syntax: "translateY( <length-percentage> )"
      },
      "translateZ()": {
        syntax: "translateZ( <length> )"
      },
      "type-or-unit": {
        syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
      },
      "type-selector": {
        syntax: "<wq-name> | <ns-prefix>? '*'"
      },
      "var()": {
        syntax: "var( <custom-property-name> , <declaration-value>? )"
      },
      "viewport-length": {
        syntax: "auto | <length-percentage>"
      },
      "wq-name": {
        syntax: "<ns-prefix>? <ident-token>"
      }
    };
  }
});

// node_modules/css-tree/data/patch.json
var require_patch = __commonJS({
  "node_modules/css-tree/data/patch.json"(exports2, module2) {
    module2.exports = {
      atrules: {
        charset: {
          prelude: "<string>"
        },
        "font-face": {
          descriptors: {
            "unicode-range": {
              comment: "replaces <unicode-range>, an old production name",
              syntax: "<urange>#"
            }
          }
        }
      },
      properties: {
        "-moz-background-clip": {
          comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "padding | border"
        },
        "-moz-border-radius-bottomleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
          syntax: "<'border-bottom-left-radius'>"
        },
        "-moz-border-radius-bottomright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-border-radius-topleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
          syntax: "<'border-top-left-radius'>"
        },
        "-moz-border-radius-topright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-control-character-visibility": {
          comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
          syntax: "visible | hidden"
        },
        "-moz-osx-font-smoothing": {
          comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | grayscale"
        },
        "-moz-user-select": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "none | text | all | -moz-none"
        },
        "-ms-flex-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "start | end | center | baseline | stretch"
        },
        "-ms-flex-item-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "auto | start | end | center | baseline | stretch"
        },
        "-ms-flex-line-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
          syntax: "start | end | center | justify | distribute | stretch"
        },
        "-ms-flex-negative": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-shrink'>"
        },
        "-ms-flex-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
          syntax: "start | end | center | justify | distribute"
        },
        "-ms-flex-order": {
          comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
          syntax: "<integer>"
        },
        "-ms-flex-positive": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-grow'>"
        },
        "-ms-flex-preferred-size": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-basis'>"
        },
        "-ms-interpolation-mode": {
          comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
          syntax: "nearest-neighbor | bicubic"
        },
        "-ms-grid-column-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-grid-row-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-hyphenate-limit-last": {
          comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
          syntax: "none | always | column | page | spread"
        },
        "-webkit-appearance": {
          comment: "webkit specific keywords",
          references: [
            "http://css-infos.net/property/-webkit-appearance"
          ],
          syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
        },
        "-webkit-background-clip": {
          comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "[ <box> | border | padding | content | text ]#"
        },
        "-webkit-column-break-after": {
          comment: "added, http://help.dottoro.com/lcrthhhv.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-before": {
          comment: "added, http://help.dottoro.com/lcxquvkf.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-inside": {
          comment: "added, http://help.dottoro.com/lclhnthl.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-font-smoothing": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | none | antialiased | subpixel-antialiased"
        },
        "-webkit-mask-box-image": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
        },
        "-webkit-print-color-adjust": {
          comment: "missed",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
          ],
          syntax: "economy | exact"
        },
        "-webkit-text-security": {
          comment: "missed; http://help.dottoro.com/lcbkewgt.php",
          syntax: "none | circle | disc | square"
        },
        "-webkit-user-drag": {
          comment: "missed; http://help.dottoro.com/lcbixvwm.php",
          syntax: "none | element | auto"
        },
        "-webkit-user-select": {
          comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "auto | none | text | all"
        },
        "alignment-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
          ],
          syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
        },
        "baseline-shift": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
          ],
          syntax: "baseline | sub | super | <svg-length>"
        },
        behavior: {
          comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
          syntax: "<url>+"
        },
        "clip-rule": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
          ],
          syntax: "nonzero | evenodd"
        },
        cue: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'cue-before'> <'cue-after'>?"
        },
        "cue-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        "cue-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        cursor: {
          comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
          references: [
            "https://www.sitepoint.com/css3-cursor-styles/"
          ],
          syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
        },
        display: {
          comment: "extended with -ms-flexbox",
          syntax: "| <-non-standard-display>"
        },
        position: {
          comment: "extended with -webkit-sticky",
          syntax: "| -webkit-sticky"
        },
        "dominant-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
          ],
          syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
        },
        "image-rendering": {
          comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
            "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
          ],
          syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
        },
        fill: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<paint>"
        },
        "fill-opacity": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<number-zero-one>"
        },
        "fill-rule": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "nonzero | evenodd"
        },
        filter: {
          comment: "extend with IE legacy syntaxes",
          syntax: "| <-ms-filter-function-list>"
        },
        "glyph-orientation-horizontal": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
          ],
          syntax: "<angle>"
        },
        "glyph-orientation-vertical": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
          ],
          syntax: "<angle>"
        },
        kerning: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#KerningProperty"
          ],
          syntax: "auto | <svg-length>"
        },
        "letter-spacing": {
          comment: "fix syntax <length> -> <length-percentage>",
          references: [
            "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
          ],
          syntax: "normal | <length-percentage>"
        },
        marker: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-end": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-mid": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-start": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "max-width": {
          comment: "fix auto -> none (https://github.com/mdn/data/pull/431); extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
          syntax: "none | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
        },
        width: {
          comment: "per spec fit-content should be a function, however browsers are supporting it as a keyword (https://github.com/csstree/stylelint-validator/issues/29)",
          syntax: "| fit-content | -moz-fit-content | -webkit-fit-content"
        },
        "min-width": {
          comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "auto | <length-percentage> | min-content | max-content | fit-content(<length-percentage>) | <-non-standard-width>"
        },
        overflow: {
          comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "| <-non-standard-overflow>"
        },
        pause: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'pause-before'> <'pause-after'>?"
        },
        "pause-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "pause-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        rest: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'rest-before'> <'rest-after'>?"
        },
        "rest-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "rest-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "shape-rendering": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
          ],
          syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
        },
        src: {
          comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
          syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
        },
        speak: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | none | normal"
        },
        "speak-as": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
        },
        stroke: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<paint>"
        },
        "stroke-dasharray": {
          comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "none | [ <svg-length>+ ]#"
        },
        "stroke-dashoffset": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "stroke-linecap": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "butt | round | square"
        },
        "stroke-linejoin": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "miter | round | bevel"
        },
        "stroke-miterlimit": {
          comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<number-one-or-greater>"
        },
        "stroke-opacity": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<number-zero-one>"
        },
        "stroke-width": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "text-anchor": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
          ],
          syntax: "start | middle | end"
        },
        "unicode-bidi": {
          comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
          syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
        },
        "unicode-range": {
          comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
          syntax: "<urange>#"
        },
        "voice-balance": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<number> | left | center | right | leftwards | rightwards"
        },
        "voice-duration": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | <time>"
        },
        "voice-family": {
          comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
        },
        "voice-pitch": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-range": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-rate": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
        },
        "voice-stress": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | strong | moderate | none | reduced"
        },
        "voice-volume": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
        },
        "writing-mode": {
          comment: "extend with SVG keywords",
          syntax: "| <svg-writing-mode>"
        }
      },
      syntaxes: {
        "-legacy-gradient": {
          comment: "added collection of legacy gradient syntaxes",
          syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
        },
        "-legacy-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-repeating-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-linear-gradient-arguments": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
        },
        "-legacy-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-repeating-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-radial-gradient-arguments": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
        },
        "-legacy-radial-gradient-size": {
          comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
          syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
        },
        "-legacy-radial-gradient-shape": {
          comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
          syntax: "circle | ellipse"
        },
        "-non-standard-font": {
          comment: "non standard fonts",
          references: [
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
        },
        "-non-standard-color": {
          comment: "non standard colors",
          references: [
            "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
            "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
          ],
          syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
        },
        "-non-standard-image-rendering": {
          comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
          syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
        },
        "-non-standard-overflow": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
        },
        "-non-standard-width": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
        },
        "-webkit-gradient()": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
          syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
        },
        "-webkit-gradient-color-stop": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
        },
        "-webkit-gradient-point": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
        },
        "-webkit-gradient-radius": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "<length> | <percentage>"
        },
        "-webkit-gradient-type": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "linear | radial"
        },
        "-webkit-mask-box-repeat": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "repeat | stretch | round"
        },
        "-webkit-mask-clip-style": {
          comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
          syntax: "border | border-box | padding | padding-box | content | content-box | text"
        },
        "-ms-filter-function-list": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function>+"
        },
        "-ms-filter-function": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
        },
        "-ms-filter-function-progid": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
        },
        "-ms-filter-function-legacy": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<ident-token> | <function-token> <any-value>? )"
        },
        "-ms-filter": {
          syntax: "<string>"
        },
        age: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "child | young | old"
        },
        "attr-name": {
          syntax: "<wq-name>"
        },
        "attr-fallback": {
          syntax: "<any-value>"
        },
        "border-radius": {
          comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
          syntax: "<length-percentage>{1,2}"
        },
        bottom: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "content-list": {
          comment: "missed -> https://drafts.csswg.org/css-content/#typedef-content-list (document-url, <target> and leader() is omitted util stabilization)",
          syntax: "[ <string> | contents | <image> | <quote> | <target> | <leader()> | <attr()> | counter( <ident>, <'list-style-type'>? ) ]+"
        },
        "element()": {
          comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
          syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
        },
        "generic-voice": {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "[ <age>? <gender> <integer>? ]"
        },
        gender: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "male | female | neutral"
        },
        "generic-family": {
          comment: "added -apple-system",
          references: [
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "| -apple-system"
        },
        gradient: {
          comment: "added legacy syntaxes support",
          syntax: "| <-legacy-gradient>"
        },
        left: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "mask-image": {
          comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
          syntax: "<mask-reference>#"
        },
        "name-repeat": {
          comment: "missed, and looks like obsolete, keep it as is since other property syntaxes should be changed too; https://www.w3.org/TR/2015/WD-css-grid-1-20150917/#typedef-name-repeat",
          syntax: "repeat( [ <positive-integer> | auto-fill ], <line-names>+)"
        },
        "named-color": {
          comment: "added non standard color names",
          syntax: "| <-non-standard-color>"
        },
        paint: {
          comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
          syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
        },
        "page-size": {
          comment: "https://www.w3.org/TR/css-page-3/#typedef-page-size-page-size",
          syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
        },
        ratio: {
          comment: "missed, https://drafts.csswg.org/mediaqueries-4/#typedef-ratio",
          syntax: "<integer> / <integer>"
        },
        right: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        shape: {
          comment: "missed spaces in function body and add backwards compatible syntax",
          syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
        },
        "svg-length": {
          comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
          references: [
            "https://www.w3.org/TR/SVG11/coords.html#Units"
          ],
          syntax: "<percentage> | <length> | <number>"
        },
        "svg-writing-mode": {
          comment: "SVG specific keywords (deprecated for CSS)",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
            "https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
          ],
          syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
        },
        top: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "track-group": {
          comment: "used by old grid-columns and grid-rows syntax v0",
          syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
        },
        "track-list-v0": {
          comment: "used by old grid-columns and grid-rows syntax v0",
          syntax: "[ <string>* <track-group> <string>* ]+ | none"
        },
        "track-minmax": {
          comment: "used by old grid-columns and grid-rows syntax v0",
          syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
        },
        x: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        y: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        declaration: {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
        },
        "declaration-list": {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "[ <declaration>? ';' ]* <declaration>?"
        },
        url: {
          comment: "https://drafts.csswg.org/css-values-4/#urls",
          syntax: "url( <string> <url-modifier>* ) | <url-token>"
        },
        "url-modifier": {
          comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
          syntax: "<ident> | <function-token> <any-value> )"
        },
        "number-zero-one": {
          syntax: "<number [0,1]>"
        },
        "number-one-or-greater": {
          syntax: "<number [1,\u221E]>"
        },
        "positive-integer": {
          syntax: "<integer [0,\u221E]>"
        },
        "-non-standard-display": {
          syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
        }
      }
    };
  }
});

// node_modules/css-tree/data/index.js
var require_data = __commonJS({
  "node_modules/css-tree/data/index.js"(exports2, module2) {
    var mdnAtrules = require_at_rules();
    var mdnProperties = require_properties();
    var mdnSyntaxes = require_syntaxes();
    var patch = require_patch();
    var extendSyntax = /^\s*\|\s*/;
    function preprocessAtrules(dict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;
        if (atrule.descriptors) {
          descriptors = /* @__PURE__ */ Object.create(null);
          for (const descriptor in atrule.descriptors) {
            descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
          }
        }
        result[atruleName.substr(1)] = {
          prelude: atrule.syntax.trim().match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
          descriptors
        };
      }
      return result;
    }
    function patchDictionary(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
      }
      for (const key in patchDict) {
        if (key in dict) {
          if (patchDict[key].syntax) {
            result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
          } else {
            delete result[key];
          }
        } else {
          if (patchDict[key].syntax) {
            result[key] = patchDict[key].syntax.replace(extendSyntax, "");
          }
        }
      }
      return result;
    }
    function unpackSyntaxes(dict) {
      const result = {};
      for (const key in dict) {
        result[key] = dict[key].syntax;
      }
      return result;
    }
    function patchAtrules(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        const patchDescriptors = patchDict[key] && patchDict[key].descriptors || null;
        result[key] = {
          prelude: key in patchDict && "prelude" in patchDict[key] ? patchDict[key].prelude : dict[key].prelude || null,
          descriptors: dict[key].descriptors ? patchDictionary(dict[key].descriptors, patchDescriptors || {}) : patchDescriptors && unpackSyntaxes(patchDescriptors)
        };
      }
      for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
          result[key] = {
            prelude: patchDict[key].prelude || null,
            descriptors: patchDict[key].descriptors && unpackSyntaxes(patchDict[key].descriptors)
          };
        }
      }
      return result;
    }
    module2.exports = {
      types: patchDictionary(mdnSyntaxes, patch.syntaxes),
      atrules: patchAtrules(preprocessAtrules(mdnAtrules), patch.atrules),
      properties: patchDictionary(mdnProperties, patch.properties)
    };
  }
});

// node_modules/css-tree/lib/syntax/node/AnPlusB.js
var require_AnPlusB = __commonJS({
  "node_modules/css-tree/lib/syntax/node/AnPlusB.js"(exports2, module2) {
    var cmpChar = require_tokenizer().cmpChar;
    var isDigit = require_tokenizer().isDigit;
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function checkInteger(offset, disallowSign) {
      var pos = this.scanner.tokenStart + offset;
      var code = this.scanner.source.charCodeAt(pos);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          this.error("Number sign is not allowed");
        }
        pos++;
      }
      for (; pos < this.scanner.tokenEnd; pos++) {
        if (!isDigit(this.scanner.source.charCodeAt(pos))) {
          this.error("Integer is expected", pos);
        }
      }
    }
    function checkTokenIsInteger(disallowSign) {
      return checkInteger.call(this, 0, disallowSign);
    }
    function expectCharCode(offset, code) {
      if (!cmpChar(this.scanner.source, this.scanner.tokenStart + offset, code)) {
        var msg = "";
        switch (code) {
          case N:
            msg = "N is expected";
            break;
          case HYPHENMINUS:
            msg = "HyphenMinus is expected";
            break;
        }
        this.error(msg, this.scanner.tokenStart + offset);
      }
    }
    function consumeB() {
      var offset = 0;
      var sign = 0;
      var type = this.scanner.tokenType;
      while (type === WHITESPACE || type === COMMENT) {
        type = this.scanner.lookupType(++offset);
      }
      if (type !== NUMBER) {
        if (this.scanner.isDelim(PLUSSIGN, offset) || this.scanner.isDelim(HYPHENMINUS, offset)) {
          sign = this.scanner.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
          do {
            type = this.scanner.lookupType(++offset);
          } while (type === WHITESPACE || type === COMMENT);
          if (type !== NUMBER) {
            this.scanner.skip(offset);
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
          }
        } else {
          return null;
        }
      }
      if (offset > 0) {
        this.scanner.skip(offset);
      }
      if (sign === 0) {
        type = this.scanner.source.charCodeAt(this.scanner.tokenStart);
        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
          this.error("Number sign is expected");
        }
      }
      checkTokenIsInteger.call(this, sign !== 0);
      return sign === HYPHENMINUS ? "-" + this.consume(NUMBER) : this.consume(NUMBER);
    }
    module2.exports = {
      name: "AnPlusB",
      structure: {
        a: [String, null],
        b: [String, null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var a = null;
        var b = null;
        if (this.scanner.tokenType === NUMBER) {
          checkTokenIsInteger.call(this, ALLOW_SIGN);
          b = this.consume(NUMBER);
        } else if (this.scanner.tokenType === IDENT && cmpChar(this.scanner.source, this.scanner.tokenStart, HYPHENMINUS)) {
          a = "-1";
          expectCharCode.call(this, 1, N);
          switch (this.scanner.getTokenLength()) {
            case 2:
              this.scanner.next();
              b = consumeB.call(this);
              break;
            case 3:
              expectCharCode.call(this, 2, HYPHENMINUS);
              this.scanner.next();
              this.scanner.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = "-" + this.consume(NUMBER);
              break;
            default:
              expectCharCode.call(this, 2, HYPHENMINUS);
              checkInteger.call(this, 3, DISALLOW_SIGN);
              this.scanner.next();
              b = this.scanner.substrToCursor(start + 2);
          }
        } else if (this.scanner.tokenType === IDENT || this.scanner.isDelim(PLUSSIGN) && this.scanner.lookupType(1) === IDENT) {
          var sign = 0;
          a = "1";
          if (this.scanner.isDelim(PLUSSIGN)) {
            sign = 1;
            this.scanner.next();
          }
          expectCharCode.call(this, 0, N);
          switch (this.scanner.getTokenLength()) {
            case 1:
              this.scanner.next();
              b = consumeB.call(this);
              break;
            case 2:
              expectCharCode.call(this, 1, HYPHENMINUS);
              this.scanner.next();
              this.scanner.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = "-" + this.consume(NUMBER);
              break;
            default:
              expectCharCode.call(this, 1, HYPHENMINUS);
              checkInteger.call(this, 2, DISALLOW_SIGN);
              this.scanner.next();
              b = this.scanner.substrToCursor(start + sign + 1);
          }
        } else if (this.scanner.tokenType === DIMENSION) {
          var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          var sign = code === PLUSSIGN || code === HYPHENMINUS;
          for (var i = this.scanner.tokenStart + sign; i < this.scanner.tokenEnd; i++) {
            if (!isDigit(this.scanner.source.charCodeAt(i))) {
              break;
            }
          }
          if (i === this.scanner.tokenStart + sign) {
            this.error("Integer is expected", this.scanner.tokenStart + sign);
          }
          expectCharCode.call(this, i - this.scanner.tokenStart, N);
          a = this.scanner.source.substring(start, i);
          if (i + 1 === this.scanner.tokenEnd) {
            this.scanner.next();
            b = consumeB.call(this);
          } else {
            expectCharCode.call(this, i - this.scanner.tokenStart + 1, HYPHENMINUS);
            if (i + 2 === this.scanner.tokenEnd) {
              this.scanner.next();
              this.scanner.skipSC();
              checkTokenIsInteger.call(this, DISALLOW_SIGN);
              b = "-" + this.consume(NUMBER);
            } else {
              checkInteger.call(this, i - this.scanner.tokenStart + 2, DISALLOW_SIGN);
              this.scanner.next();
              b = this.scanner.substrToCursor(i + 1);
            }
          }
        } else {
          this.error();
        }
        if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
          a = a.substr(1);
        }
        if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
          b = b.substr(1);
        }
        return {
          type: "AnPlusB",
          loc: this.getLocation(start, this.scanner.tokenStart),
          a,
          b
        };
      },
      generate: function(node) {
        var a = node.a !== null && node.a !== void 0;
        var b = node.b !== null && node.b !== void 0;
        if (a) {
          this.chunk(
            node.a === "+1" ? "+n" : (
              // eslint-disable-line operator-linebreak, indent
              node.a === "1" ? "n" : (
                // eslint-disable-line operator-linebreak, indent
                node.a === "-1" ? "-n" : (
                  // eslint-disable-line operator-linebreak, indent
                  node.a + "n"
                )
              )
            )
            // eslint-disable-line operator-linebreak, indent
          );
          if (b) {
            b = String(node.b);
            if (b.charAt(0) === "-" || b.charAt(0) === "+") {
              this.chunk(b.charAt(0));
              this.chunk(b.substr(1));
            } else {
              this.chunk("+");
              this.chunk(b);
            }
          }
        } else {
          this.chunk(String(node.b));
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Raw.js
var require_Raw = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Raw.js"(exports2, module2) {
    var tokenizer = require_tokenizer();
    var TYPE = tokenizer.TYPE;
    var WhiteSpace = TYPE.WhiteSpace;
    var Semicolon = TYPE.Semicolon;
    var LeftCurlyBracket = TYPE.LeftCurlyBracket;
    var Delim = TYPE.Delim;
    var EXCLAMATIONMARK = 33;
    function getOffsetExcludeWS() {
      if (this.scanner.tokenIndex > 0) {
        if (this.scanner.lookupType(-1) === WhiteSpace) {
          return this.scanner.tokenIndex > 1 ? this.scanner.getTokenStart(this.scanner.tokenIndex - 1) : this.scanner.firstCharOffset;
        }
      }
      return this.scanner.tokenStart;
    }
    function balanceEnd() {
      return 0;
    }
    function leftCurlyBracket(tokenType) {
      return tokenType === LeftCurlyBracket ? 1 : 0;
    }
    function leftCurlyBracketOrSemicolon(tokenType) {
      return tokenType === LeftCurlyBracket || tokenType === Semicolon ? 1 : 0;
    }
    function exclamationMarkOrSemicolon(tokenType, source, offset) {
      if (tokenType === Delim && source.charCodeAt(offset) === EXCLAMATIONMARK) {
        return 1;
      }
      return tokenType === Semicolon ? 1 : 0;
    }
    function semicolonIncluded(tokenType) {
      return tokenType === Semicolon ? 2 : 0;
    }
    module2.exports = {
      name: "Raw",
      structure: {
        value: String
      },
      parse: function(startToken, mode, excludeWhiteSpace) {
        var startOffset = this.scanner.getTokenStart(startToken);
        var endOffset;
        this.scanner.skip(
          this.scanner.getRawLength(startToken, mode || balanceEnd)
        );
        if (excludeWhiteSpace && this.scanner.tokenStart > startOffset) {
          endOffset = getOffsetExcludeWS.call(this);
        } else {
          endOffset = this.scanner.tokenStart;
        }
        return {
          type: "Raw",
          loc: this.getLocation(startOffset, endOffset),
          value: this.scanner.source.substring(startOffset, endOffset)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      },
      mode: {
        default: balanceEnd,
        leftCurlyBracket,
        leftCurlyBracketOrSemicolon,
        exclamationMarkOrSemicolon,
        semicolonIncluded
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Atrule.js
var require_Atrule = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Atrule.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var ATKEYWORD = TYPE.AtKeyword;
    var SEMICOLON = TYPE.Semicolon;
    var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
    function consumeRaw(startToken) {
      return this.Raw(startToken, rawMode.leftCurlyBracketOrSemicolon, true);
    }
    function isDeclarationBlockAtrule() {
      for (var offset = 1, type; type = this.scanner.lookupType(offset); offset++) {
        if (type === RIGHTCURLYBRACKET) {
          return true;
        }
        if (type === LEFTCURLYBRACKET || type === ATKEYWORD) {
          return false;
        }
      }
      return false;
    }
    module2.exports = {
      name: "Atrule",
      structure: {
        name: String,
        prelude: ["AtrulePrelude", "Raw", null],
        block: ["Block", null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var nameLowerCase;
        var prelude = null;
        var block = null;
        this.eat(ATKEYWORD);
        name = this.scanner.substrToCursor(start + 1);
        nameLowerCase = name.toLowerCase();
        this.scanner.skipSC();
        if (this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
          if (this.parseAtrulePrelude) {
            prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);
            if (prelude.type === "AtrulePrelude" && prelude.children.head === null) {
              prelude = null;
            }
          } else {
            prelude = consumeRaw.call(this, this.scanner.tokenIndex);
          }
          this.scanner.skipSC();
        }
        switch (this.scanner.tokenType) {
          case SEMICOLON:
            this.scanner.next();
            break;
          case LEFTCURLYBRACKET:
            if (this.atrule.hasOwnProperty(nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
              block = this.atrule[nameLowerCase].block.call(this);
            } else {
              block = this.Block(isDeclarationBlockAtrule.call(this));
            }
            break;
        }
        return {
          type: "Atrule",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          prelude,
          block
        };
      },
      generate: function(node) {
        this.chunk("@");
        this.chunk(node.name);
        if (node.prelude !== null) {
          this.chunk(" ");
          this.node(node.prelude);
        }
        if (node.block) {
          this.node(node.block);
        } else {
          this.chunk(";");
        }
      },
      walkContext: "atrule"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/AtrulePrelude.js
var require_AtrulePrelude = __commonJS({
  "node_modules/css-tree/lib/syntax/node/AtrulePrelude.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var SEMICOLON = TYPE.Semicolon;
    var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    module2.exports = {
      name: "AtrulePrelude",
      structure: {
        children: [[]]
      },
      parse: function(name) {
        var children = null;
        if (name !== null) {
          name = name.toLowerCase();
        }
        this.scanner.skipSC();
        if (this.atrule.hasOwnProperty(name) && typeof this.atrule[name].prelude === "function") {
          children = this.atrule[name].prelude.call(this);
        } else {
          children = this.readSequence(this.scope.AtrulePrelude);
        }
        this.scanner.skipSC();
        if (this.scanner.eof !== true && this.scanner.tokenType !== LEFTCURLYBRACKET && this.scanner.tokenType !== SEMICOLON) {
          this.error("Semicolon or block is expected");
        }
        if (children === null) {
          children = this.createList();
        }
        return {
          type: "AtrulePrelude",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      },
      walkContext: "atrulePrelude"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/AttributeSelector.js
var require_AttributeSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/AttributeSelector.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var STRING = TYPE.String;
    var COLON = TYPE.Colon;
    var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
    var DOLLARSIGN = 36;
    var ASTERISK = 42;
    var EQUALSSIGN = 61;
    var CIRCUMFLEXACCENT = 94;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function getAttributeName() {
      if (this.scanner.eof) {
        this.error("Unexpected end of input");
      }
      var start = this.scanner.tokenStart;
      var expectIdent = false;
      var checkColon = true;
      if (this.scanner.isDelim(ASTERISK)) {
        expectIdent = true;
        checkColon = false;
        this.scanner.next();
      } else if (!this.scanner.isDelim(VERTICALLINE)) {
        this.eat(IDENT);
      }
      if (this.scanner.isDelim(VERTICALLINE)) {
        if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 1) !== EQUALSSIGN) {
          this.scanner.next();
          this.eat(IDENT);
        } else if (expectIdent) {
          this.error("Identifier is expected", this.scanner.tokenEnd);
        }
      } else if (expectIdent) {
        this.error("Vertical line is expected");
      }
      if (checkColon && this.scanner.tokenType === COLON) {
        this.scanner.next();
        this.eat(IDENT);
      }
      return {
        type: "Identifier",
        loc: this.getLocation(start, this.scanner.tokenStart),
        name: this.scanner.substrToCursor(start)
      };
    }
    function getOperator() {
      var start = this.scanner.tokenStart;
      var code = this.scanner.source.charCodeAt(start);
      if (code !== EQUALSSIGN && // =
      code !== TILDE && // ~=
      code !== CIRCUMFLEXACCENT && // ^=
      code !== DOLLARSIGN && // $=
      code !== ASTERISK && // *=
      code !== VERTICALLINE) {
        this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
      }
      this.scanner.next();
      if (code !== EQUALSSIGN) {
        if (!this.scanner.isDelim(EQUALSSIGN)) {
          this.error("Equal sign is expected");
        }
        this.scanner.next();
      }
      return this.scanner.substrToCursor(start);
    }
    module2.exports = {
      name: "AttributeSelector",
      structure: {
        name: "Identifier",
        matcher: [String, null],
        value: ["String", "Identifier", null],
        flags: [String, null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var matcher = null;
        var value = null;
        var flags = null;
        this.eat(LEFTSQUAREBRACKET);
        this.scanner.skipSC();
        name = getAttributeName.call(this);
        this.scanner.skipSC();
        if (this.scanner.tokenType !== RIGHTSQUAREBRACKET) {
          if (this.scanner.tokenType !== IDENT) {
            matcher = getOperator.call(this);
            this.scanner.skipSC();
            value = this.scanner.tokenType === STRING ? this.String() : this.Identifier();
            this.scanner.skipSC();
          }
          if (this.scanner.tokenType === IDENT) {
            flags = this.scanner.getTokenValue();
            this.scanner.next();
            this.scanner.skipSC();
          }
        }
        this.eat(RIGHTSQUAREBRACKET);
        return {
          type: "AttributeSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          matcher,
          value,
          flags
        };
      },
      generate: function(node) {
        var flagsPrefix = " ";
        this.chunk("[");
        this.node(node.name);
        if (node.matcher !== null) {
          this.chunk(node.matcher);
          if (node.value !== null) {
            this.node(node.value);
            if (node.value.type === "String") {
              flagsPrefix = "";
            }
          }
        }
        if (node.flags !== null) {
          this.chunk(flagsPrefix);
          this.chunk(node.flags);
        }
        this.chunk("]");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Block.js
var require_Block = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Block.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var SEMICOLON = TYPE.Semicolon;
    var ATKEYWORD = TYPE.AtKeyword;
    var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    var RIGHTCURLYBRACKET = TYPE.RightCurlyBracket;
    function consumeRaw(startToken) {
      return this.Raw(startToken, null, true);
    }
    function consumeRule() {
      return this.parseWithFallback(this.Rule, consumeRaw);
    }
    function consumeRawDeclaration(startToken) {
      return this.Raw(startToken, rawMode.semicolonIncluded, true);
    }
    function consumeDeclaration() {
      if (this.scanner.tokenType === SEMICOLON) {
        return consumeRawDeclaration.call(this, this.scanner.tokenIndex);
      }
      var node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
      if (this.scanner.tokenType === SEMICOLON) {
        this.scanner.next();
      }
      return node;
    }
    module2.exports = {
      name: "Block",
      structure: {
        children: [[
          "Atrule",
          "Rule",
          "Declaration"
        ]]
      },
      parse: function(isDeclaration) {
        var consumer = isDeclaration ? consumeDeclaration : consumeRule;
        var start = this.scanner.tokenStart;
        var children = this.createList();
        this.eat(LEFTCURLYBRACKET);
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case RIGHTCURLYBRACKET:
                break scan;
              case WHITESPACE:
              case COMMENT:
                this.scanner.next();
                break;
              case ATKEYWORD:
                children.push(this.parseWithFallback(this.Atrule, consumeRaw));
                break;
              default:
                children.push(consumer.call(this));
            }
          }
        if (!this.scanner.eof) {
          this.eat(RIGHTCURLYBRACKET);
        }
        return {
          type: "Block",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.chunk("{");
        this.children(node, function(prev) {
          if (prev.type === "Declaration") {
            this.chunk(";");
          }
        });
        this.chunk("}");
      },
      walkContext: "block"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Brackets.js
var require_Brackets = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Brackets.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    var RIGHTSQUAREBRACKET = TYPE.RightSquareBracket;
    module2.exports = {
      name: "Brackets",
      structure: {
        children: [[]]
      },
      parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;
        this.eat(LEFTSQUAREBRACKET);
        children = readSequence.call(this, recognizer);
        if (!this.scanner.eof) {
          this.eat(RIGHTSQUAREBRACKET);
        }
        return {
          type: "Brackets",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.chunk("[");
        this.children(node);
        this.chunk("]");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/CDC.js
var require_CDC = __commonJS({
  "node_modules/css-tree/lib/syntax/node/CDC.js"(exports2, module2) {
    var CDC = require_tokenizer().TYPE.CDC;
    module2.exports = {
      name: "CDC",
      structure: [],
      parse: function() {
        var start = this.scanner.tokenStart;
        this.eat(CDC);
        return {
          type: "CDC",
          loc: this.getLocation(start, this.scanner.tokenStart)
        };
      },
      generate: function() {
        this.chunk("-->");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/CDO.js
var require_CDO = __commonJS({
  "node_modules/css-tree/lib/syntax/node/CDO.js"(exports2, module2) {
    var CDO = require_tokenizer().TYPE.CDO;
    module2.exports = {
      name: "CDO",
      structure: [],
      parse: function() {
        var start = this.scanner.tokenStart;
        this.eat(CDO);
        return {
          type: "CDO",
          loc: this.getLocation(start, this.scanner.tokenStart)
        };
      },
      generate: function() {
        this.chunk("<!--");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/ClassSelector.js
var require_ClassSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/ClassSelector.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var FULLSTOP = 46;
    module2.exports = {
      name: "ClassSelector",
      structure: {
        name: String
      },
      parse: function() {
        if (!this.scanner.isDelim(FULLSTOP)) {
          this.error("Full stop is expected");
        }
        this.scanner.next();
        return {
          type: "ClassSelector",
          loc: this.getLocation(this.scanner.tokenStart - 1, this.scanner.tokenEnd),
          name: this.consume(IDENT)
        };
      },
      generate: function(node) {
        this.chunk(".");
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Combinator.js
var require_Combinator = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Combinator.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var GREATERTHANSIGN = 62;
    var TILDE = 126;
    module2.exports = {
      name: "Combinator",
      structure: {
        name: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
        switch (code) {
          case GREATERTHANSIGN:
          case PLUSSIGN:
          case TILDE:
            this.scanner.next();
            break;
          case SOLIDUS:
            this.scanner.next();
            if (this.scanner.tokenType !== IDENT || this.scanner.lookupValue(0, "deep") === false) {
              this.error("Identifier `deep` is expected");
            }
            this.scanner.next();
            if (!this.scanner.isDelim(SOLIDUS)) {
              this.error("Solidus is expected");
            }
            this.scanner.next();
            break;
          default:
            this.error("Combinator is expected");
        }
        return {
          type: "Combinator",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name: this.scanner.substrToCursor(start)
        };
      },
      generate: function(node) {
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Comment.js
var require_Comment = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Comment.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var COMMENT = TYPE.Comment;
    var ASTERISK = 42;
    var SOLIDUS = 47;
    module2.exports = {
      name: "Comment",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var end = this.scanner.tokenEnd;
        this.eat(COMMENT);
        if (end - start + 2 >= 2 && this.scanner.source.charCodeAt(end - 2) === ASTERISK && this.scanner.source.charCodeAt(end - 1) === SOLIDUS) {
          end -= 2;
        }
        return {
          type: "Comment",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.source.substring(start + 2, end)
        };
      },
      generate: function(node) {
        this.chunk("/*");
        this.chunk(node.value);
        this.chunk("*/");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Declaration.js
var require_Declaration = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Declaration.js"(exports2, module2) {
    var isCustomProperty = require_names().isCustomProperty;
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var IDENT = TYPE.Ident;
    var HASH = TYPE.Hash;
    var COLON = TYPE.Colon;
    var SEMICOLON = TYPE.Semicolon;
    var DELIM = TYPE.Delim;
    var WHITESPACE = TYPE.WhiteSpace;
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var DOLLARSIGN = 36;
    var AMPERSAND = 38;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    function consumeValueRaw(startToken) {
      return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, true);
    }
    function consumeCustomPropertyRaw(startToken) {
      return this.Raw(startToken, rawMode.exclamationMarkOrSemicolon, false);
    }
    function consumeValue() {
      var startValueToken = this.scanner.tokenIndex;
      var value = this.Value();
      if (value.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.isDelim(EXCLAMATIONMARK) === false && this.scanner.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value;
    }
    module2.exports = {
      name: "Declaration",
      structure: {
        important: [Boolean, String],
        property: String,
        value: ["Value", "Raw"]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var startToken = this.scanner.tokenIndex;
        var property = readProperty.call(this);
        var customProperty = isCustomProperty(property);
        var parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
        var consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
        var important = false;
        var value;
        this.scanner.skipSC();
        this.eat(COLON);
        const valueStart = this.scanner.tokenIndex;
        if (!customProperty) {
          this.scanner.skipSC();
        }
        if (parseValue) {
          value = this.parseWithFallback(consumeValue, consumeRaw);
        } else {
          value = consumeRaw.call(this, this.scanner.tokenIndex);
        }
        if (customProperty && value.type === "Value" && value.children.isEmpty()) {
          for (let offset = valueStart - this.scanner.tokenIndex; offset <= 0; offset++) {
            if (this.scanner.lookupType(offset) === WHITESPACE) {
              value.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " "
              });
              break;
            }
          }
        }
        if (this.scanner.isDelim(EXCLAMATIONMARK)) {
          important = getImportant.call(this);
          this.scanner.skipSC();
        }
        if (this.scanner.eof === false && this.scanner.tokenType !== SEMICOLON && this.scanner.isBalanceEdge(startToken) === false) {
          this.error();
        }
        return {
          type: "Declaration",
          loc: this.getLocation(start, this.scanner.tokenStart),
          important,
          property,
          value
        };
      },
      generate: function(node) {
        this.chunk(node.property);
        this.chunk(":");
        this.node(node.value);
        if (node.important) {
          this.chunk(node.important === true ? "!important" : "!" + node.important);
        }
      },
      walkContext: "declaration"
    };
    function readProperty() {
      var start = this.scanner.tokenStart;
      var prefix = 0;
      if (this.scanner.tokenType === DELIM) {
        switch (this.scanner.source.charCodeAt(this.scanner.tokenStart)) {
          case ASTERISK:
          case DOLLARSIGN:
          case PLUSSIGN:
          case NUMBERSIGN:
          case AMPERSAND:
            this.scanner.next();
            break;
          case SOLIDUS:
            this.scanner.next();
            if (this.scanner.isDelim(SOLIDUS)) {
              this.scanner.next();
            }
            break;
        }
      }
      if (prefix) {
        this.scanner.skip(prefix);
      }
      if (this.scanner.tokenType === HASH) {
        this.eat(HASH);
      } else {
        this.eat(IDENT);
      }
      return this.scanner.substrToCursor(start);
    }
    function getImportant() {
      this.eat(DELIM);
      this.scanner.skipSC();
      var important = this.consume(IDENT);
      return important === "important" ? true : important;
    }
  }
});

// node_modules/css-tree/lib/syntax/node/DeclarationList.js
var require_DeclarationList = __commonJS({
  "node_modules/css-tree/lib/syntax/node/DeclarationList.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var SEMICOLON = TYPE.Semicolon;
    function consumeRaw(startToken) {
      return this.Raw(startToken, rawMode.semicolonIncluded, true);
    }
    module2.exports = {
      name: "DeclarationList",
      structure: {
        children: [[
          "Declaration"
        ]]
      },
      parse: function() {
        var children = this.createList();
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE:
              case COMMENT:
              case SEMICOLON:
                this.scanner.next();
                break;
              default:
                children.push(this.parseWithFallback(this.Declaration, consumeRaw));
            }
          }
        return {
          type: "DeclarationList",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node, function(prev) {
          if (prev.type === "Declaration") {
            this.chunk(";");
          }
        });
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Dimension.js
var require_Dimension = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Dimension.js"(exports2, module2) {
    var consumeNumber = require_utils().consumeNumber;
    var TYPE = require_tokenizer().TYPE;
    var DIMENSION = TYPE.Dimension;
    module2.exports = {
      name: "Dimension",
      structure: {
        value: String,
        unit: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber(this.scanner.source, start);
        this.eat(DIMENSION);
        return {
          type: "Dimension",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.source.substring(start, numberEnd),
          unit: this.scanner.source.substring(numberEnd, this.scanner.tokenStart)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
        this.chunk(node.unit);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Function.js
var require_Function = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Function.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module2.exports = {
      name: "Function",
      structure: {
        name: String,
        children: [[]]
      },
      parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var name = this.consumeFunctionName();
        var nameLowerCase = name.toLowerCase();
        var children;
        children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);
        if (!this.scanner.eof) {
          this.eat(RIGHTPARENTHESIS);
        }
        return {
          type: "Function",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          children
        };
      },
      generate: function(node) {
        this.chunk(node.name);
        this.chunk("(");
        this.children(node);
        this.chunk(")");
      },
      walkContext: "function"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Hash.js
var require_Hash = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Hash.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var HASH = TYPE.Hash;
    module2.exports = {
      name: "Hash",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        this.eat(HASH);
        return {
          type: "Hash",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.substrToCursor(start + 1)
        };
      },
      generate: function(node) {
        this.chunk("#");
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Identifier.js
var require_Identifier = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Identifier.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    module2.exports = {
      name: "Identifier",
      structure: {
        name: String
      },
      parse: function() {
        return {
          type: "Identifier",
          loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
          name: this.consume(IDENT)
        };
      },
      generate: function(node) {
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/IdSelector.js
var require_IdSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/IdSelector.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var HASH = TYPE.Hash;
    module2.exports = {
      name: "IdSelector",
      structure: {
        name: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        this.eat(HASH);
        return {
          type: "IdSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name: this.scanner.substrToCursor(start + 1)
        };
      },
      generate: function(node) {
        this.chunk("#");
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/MediaFeature.js
var require_MediaFeature = __commonJS({
  "node_modules/css-tree/lib/syntax/node/MediaFeature.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    var COLON = TYPE.Colon;
    var DELIM = TYPE.Delim;
    module2.exports = {
      name: "MediaFeature",
      structure: {
        name: String,
        value: ["Identifier", "Number", "Dimension", "Ratio", null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var name;
        var value = null;
        this.eat(LEFTPARENTHESIS);
        this.scanner.skipSC();
        name = this.consume(IDENT);
        this.scanner.skipSC();
        if (this.scanner.tokenType !== RIGHTPARENTHESIS) {
          this.eat(COLON);
          this.scanner.skipSC();
          switch (this.scanner.tokenType) {
            case NUMBER:
              if (this.lookupNonWSType(1) === DELIM) {
                value = this.Ratio();
              } else {
                value = this.Number();
              }
              break;
            case DIMENSION:
              value = this.Dimension();
              break;
            case IDENT:
              value = this.Identifier();
              break;
            default:
              this.error("Number, dimension, ratio or identifier is expected");
          }
          this.scanner.skipSC();
        }
        this.eat(RIGHTPARENTHESIS);
        return {
          type: "MediaFeature",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          value
        };
      },
      generate: function(node) {
        this.chunk("(");
        this.chunk(node.name);
        if (node.value !== null) {
          this.chunk(":");
          this.node(node.value);
        }
        this.chunk(")");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/MediaQuery.js
var require_MediaQuery = __commonJS({
  "node_modules/css-tree/lib/syntax/node/MediaQuery.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    module2.exports = {
      name: "MediaQuery",
      structure: {
        children: [[
          "Identifier",
          "MediaFeature",
          "WhiteSpace"
        ]]
      },
      parse: function() {
        this.scanner.skipSC();
        var children = this.createList();
        var child = null;
        var space = null;
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case COMMENT:
                this.scanner.next();
                continue;
              case WHITESPACE:
                space = this.WhiteSpace();
                continue;
              case IDENT:
                child = this.Identifier();
                break;
              case LEFTPARENTHESIS:
                child = this.MediaFeature();
                break;
              default:
                break scan;
            }
            if (space !== null) {
              children.push(space);
              space = null;
            }
            children.push(child);
          }
        if (child === null) {
          this.error("Identifier or parenthesis is expected");
        }
        return {
          type: "MediaQuery",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/MediaQueryList.js
var require_MediaQueryList = __commonJS({
  "node_modules/css-tree/lib/syntax/node/MediaQueryList.js"(exports2, module2) {
    var COMMA = require_tokenizer().TYPE.Comma;
    module2.exports = {
      name: "MediaQueryList",
      structure: {
        children: [[
          "MediaQuery"
        ]]
      },
      parse: function(relative) {
        var children = this.createList();
        this.scanner.skipSC();
        while (!this.scanner.eof) {
          children.push(this.MediaQuery(relative));
          if (this.scanner.tokenType !== COMMA) {
            break;
          }
          this.scanner.next();
        }
        return {
          type: "MediaQueryList",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node, function() {
          this.chunk(",");
        });
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Nth.js
var require_Nth = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Nth.js"(exports2, module2) {
    module2.exports = {
      name: "Nth",
      structure: {
        nth: ["AnPlusB", "Identifier"],
        selector: ["SelectorList", null]
      },
      parse: function(allowOfClause) {
        this.scanner.skipSC();
        var start = this.scanner.tokenStart;
        var end = start;
        var selector = null;
        var query;
        if (this.scanner.lookupValue(0, "odd") || this.scanner.lookupValue(0, "even")) {
          query = this.Identifier();
        } else {
          query = this.AnPlusB();
        }
        this.scanner.skipSC();
        if (allowOfClause && this.scanner.lookupValue(0, "of")) {
          this.scanner.next();
          selector = this.SelectorList();
          if (this.needPositions) {
            end = this.getLastListNode(selector.children).loc.end.offset;
          }
        } else {
          if (this.needPositions) {
            end = query.loc.end.offset;
          }
        }
        return {
          type: "Nth",
          loc: this.getLocation(start, end),
          nth: query,
          selector
        };
      },
      generate: function(node) {
        this.node(node.nth);
        if (node.selector !== null) {
          this.chunk(" of ");
          this.node(node.selector);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Number.js
var require_Number = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Number.js"(exports2, module2) {
    var NUMBER = require_tokenizer().TYPE.Number;
    module2.exports = {
      name: "Number",
      structure: {
        value: String
      },
      parse: function() {
        return {
          type: "Number",
          loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
          value: this.consume(NUMBER)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Operator.js
var require_Operator = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Operator.js"(exports2, module2) {
    module2.exports = {
      name: "Operator",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        this.scanner.next();
        return {
          type: "Operator",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.substrToCursor(start)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Parentheses.js
var require_Parentheses = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Parentheses.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module2.exports = {
      name: "Parentheses",
      structure: {
        children: [[]]
      },
      parse: function(readSequence, recognizer) {
        var start = this.scanner.tokenStart;
        var children = null;
        this.eat(LEFTPARENTHESIS);
        children = readSequence.call(this, recognizer);
        if (!this.scanner.eof) {
          this.eat(RIGHTPARENTHESIS);
        }
        return {
          type: "Parentheses",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.chunk("(");
        this.children(node);
        this.chunk(")");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Percentage.js
var require_Percentage = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Percentage.js"(exports2, module2) {
    var consumeNumber = require_utils().consumeNumber;
    var TYPE = require_tokenizer().TYPE;
    var PERCENTAGE = TYPE.Percentage;
    module2.exports = {
      name: "Percentage",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var numberEnd = consumeNumber(this.scanner.source, start);
        this.eat(PERCENTAGE);
        return {
          type: "Percentage",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.source.substring(start, numberEnd)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
        this.chunk("%");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js
var require_PseudoClassSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var FUNCTION = TYPE.Function;
    var COLON = TYPE.Colon;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module2.exports = {
      name: "PseudoClassSelector",
      structure: {
        name: String,
        children: [["Raw"], null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;
        this.eat(COLON);
        if (this.scanner.tokenType === FUNCTION) {
          name = this.consumeFunctionName();
          nameLowerCase = name.toLowerCase();
          if (this.pseudo.hasOwnProperty(nameLowerCase)) {
            this.scanner.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.scanner.skipSC();
          } else {
            children = this.createList();
            children.push(
              this.Raw(this.scanner.tokenIndex, null, false)
            );
          }
          this.eat(RIGHTPARENTHESIS);
        } else {
          name = this.consume(IDENT);
        }
        return {
          type: "PseudoClassSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          children
        };
      },
      generate: function(node) {
        this.chunk(":");
        this.chunk(node.name);
        if (node.children !== null) {
          this.chunk("(");
          this.children(node);
          this.chunk(")");
        }
      },
      walkContext: "function"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js
var require_PseudoElementSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var FUNCTION = TYPE.Function;
    var COLON = TYPE.Colon;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module2.exports = {
      name: "PseudoElementSelector",
      structure: {
        name: String,
        children: [["Raw"], null]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var children = null;
        var name;
        var nameLowerCase;
        this.eat(COLON);
        this.eat(COLON);
        if (this.scanner.tokenType === FUNCTION) {
          name = this.consumeFunctionName();
          nameLowerCase = name.toLowerCase();
          if (this.pseudo.hasOwnProperty(nameLowerCase)) {
            this.scanner.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.scanner.skipSC();
          } else {
            children = this.createList();
            children.push(
              this.Raw(this.scanner.tokenIndex, null, false)
            );
          }
          this.eat(RIGHTPARENTHESIS);
        } else {
          name = this.consume(IDENT);
        }
        return {
          type: "PseudoElementSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name,
          children
        };
      },
      generate: function(node) {
        this.chunk("::");
        this.chunk(node.name);
        if (node.children !== null) {
          this.chunk("(");
          this.children(node);
          this.chunk(")");
        }
      },
      walkContext: "function"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Ratio.js
var require_Ratio = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Ratio.js"(exports2, module2) {
    var isDigit = require_tokenizer().isDigit;
    var TYPE = require_tokenizer().TYPE;
    var NUMBER = TYPE.Number;
    var DELIM = TYPE.Delim;
    var SOLIDUS = 47;
    var FULLSTOP = 46;
    function consumeNumber() {
      this.scanner.skipWS();
      var value = this.consume(NUMBER);
      for (var i = 0; i < value.length; i++) {
        var code = value.charCodeAt(i);
        if (!isDigit(code) && code !== FULLSTOP) {
          this.error("Unsigned number is expected", this.scanner.tokenStart - value.length + i);
        }
      }
      if (Number(value) === 0) {
        this.error("Zero number is not allowed", this.scanner.tokenStart - value.length);
      }
      return value;
    }
    module2.exports = {
      name: "Ratio",
      structure: {
        left: String,
        right: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var left = consumeNumber.call(this);
        var right;
        this.scanner.skipWS();
        if (!this.scanner.isDelim(SOLIDUS)) {
          this.error("Solidus is expected");
        }
        this.eat(DELIM);
        right = consumeNumber.call(this);
        return {
          type: "Ratio",
          loc: this.getLocation(start, this.scanner.tokenStart),
          left,
          right
        };
      },
      generate: function(node) {
        this.chunk(node.left);
        this.chunk("/");
        this.chunk(node.right);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Rule.js
var require_Rule = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Rule.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var LEFTCURLYBRACKET = TYPE.LeftCurlyBracket;
    function consumeRaw(startToken) {
      return this.Raw(startToken, rawMode.leftCurlyBracket, true);
    }
    function consumePrelude() {
      var prelude = this.SelectorList();
      if (prelude.type !== "Raw" && this.scanner.eof === false && this.scanner.tokenType !== LEFTCURLYBRACKET) {
        this.error();
      }
      return prelude;
    }
    module2.exports = {
      name: "Rule",
      structure: {
        prelude: ["SelectorList", "Raw"],
        block: ["Block"]
      },
      parse: function() {
        var startToken = this.scanner.tokenIndex;
        var startOffset = this.scanner.tokenStart;
        var prelude;
        var block;
        if (this.parseRulePrelude) {
          prelude = this.parseWithFallback(consumePrelude, consumeRaw);
        } else {
          prelude = consumeRaw.call(this, startToken);
        }
        block = this.Block(true);
        return {
          type: "Rule",
          loc: this.getLocation(startOffset, this.scanner.tokenStart),
          prelude,
          block
        };
      },
      generate: function(node) {
        this.node(node.prelude);
        this.node(node.block);
      },
      walkContext: "rule"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Selector.js
var require_Selector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Selector.js"(exports2, module2) {
    module2.exports = {
      name: "Selector",
      structure: {
        children: [[
          "TypeSelector",
          "IdSelector",
          "ClassSelector",
          "AttributeSelector",
          "PseudoClassSelector",
          "PseudoElementSelector",
          "Combinator",
          "WhiteSpace"
        ]]
      },
      parse: function() {
        var children = this.readSequence(this.scope.Selector);
        if (this.getFirstListNode(children) === null) {
          this.error("Selector is expected");
        }
        return {
          type: "Selector",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/SelectorList.js
var require_SelectorList = __commonJS({
  "node_modules/css-tree/lib/syntax/node/SelectorList.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var COMMA = TYPE.Comma;
    module2.exports = {
      name: "SelectorList",
      structure: {
        children: [[
          "Selector",
          "Raw"
        ]]
      },
      parse: function() {
        var children = this.createList();
        while (!this.scanner.eof) {
          children.push(this.Selector());
          if (this.scanner.tokenType === COMMA) {
            this.scanner.next();
            continue;
          }
          break;
        }
        return {
          type: "SelectorList",
          loc: this.getLocationFromList(children),
          children
        };
      },
      generate: function(node) {
        this.children(node, function() {
          this.chunk(",");
        });
      },
      walkContext: "selector"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/String.js
var require_String = __commonJS({
  "node_modules/css-tree/lib/syntax/node/String.js"(exports2, module2) {
    var STRING = require_tokenizer().TYPE.String;
    module2.exports = {
      name: "String",
      structure: {
        value: String
      },
      parse: function() {
        return {
          type: "String",
          loc: this.getLocation(this.scanner.tokenStart, this.scanner.tokenEnd),
          value: this.consume(STRING)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/StyleSheet.js
var require_StyleSheet = __commonJS({
  "node_modules/css-tree/lib/syntax/node/StyleSheet.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var ATKEYWORD = TYPE.AtKeyword;
    var CDO = TYPE.CDO;
    var CDC = TYPE.CDC;
    var EXCLAMATIONMARK = 33;
    function consumeRaw(startToken) {
      return this.Raw(startToken, null, false);
    }
    module2.exports = {
      name: "StyleSheet",
      structure: {
        children: [[
          "Comment",
          "CDO",
          "CDC",
          "Atrule",
          "Rule",
          "Raw"
        ]]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.createList();
        var child;
        scan:
          while (!this.scanner.eof) {
            switch (this.scanner.tokenType) {
              case WHITESPACE:
                this.scanner.next();
                continue;
              case COMMENT:
                if (this.scanner.source.charCodeAt(this.scanner.tokenStart + 2) !== EXCLAMATIONMARK) {
                  this.scanner.next();
                  continue;
                }
                child = this.Comment();
                break;
              case CDO:
                child = this.CDO();
                break;
              case CDC:
                child = this.CDC();
                break;
              case ATKEYWORD:
                child = this.parseWithFallback(this.Atrule, consumeRaw);
                break;
              default:
                child = this.parseWithFallback(this.Rule, consumeRaw);
            }
            children.push(child);
          }
        return {
          type: "StyleSheet",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      },
      walkContext: "stylesheet"
    };
  }
});

// node_modules/css-tree/lib/syntax/node/TypeSelector.js
var require_TypeSelector = __commonJS({
  "node_modules/css-tree/lib/syntax/node/TypeSelector.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var ASTERISK = 42;
    var VERTICALLINE = 124;
    function eatIdentifierOrAsterisk() {
      if (this.scanner.tokenType !== IDENT && this.scanner.isDelim(ASTERISK) === false) {
        this.error("Identifier or asterisk is expected");
      }
      this.scanner.next();
    }
    module2.exports = {
      name: "TypeSelector",
      structure: {
        name: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        if (this.scanner.isDelim(VERTICALLINE)) {
          this.scanner.next();
          eatIdentifierOrAsterisk.call(this);
        } else {
          eatIdentifierOrAsterisk.call(this);
          if (this.scanner.isDelim(VERTICALLINE)) {
            this.scanner.next();
            eatIdentifierOrAsterisk.call(this);
          }
        }
        return {
          type: "TypeSelector",
          loc: this.getLocation(start, this.scanner.tokenStart),
          name: this.scanner.substrToCursor(start)
        };
      },
      generate: function(node) {
        this.chunk(node.name);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/UnicodeRange.js
var require_UnicodeRange = __commonJS({
  "node_modules/css-tree/lib/syntax/node/UnicodeRange.js"(exports2, module2) {
    var isHexDigit = require_tokenizer().isHexDigit;
    var cmpChar = require_tokenizer().cmpChar;
    var TYPE = require_tokenizer().TYPE;
    var NAME = require_tokenizer().NAME;
    var IDENT = TYPE.Ident;
    var NUMBER = TYPE.Number;
    var DIMENSION = TYPE.Dimension;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    var U = 117;
    function eatHexSequence(offset, allowDash) {
      for (var pos = this.scanner.tokenStart + offset, len = 0; pos < this.scanner.tokenEnd; pos++) {
        var code = this.scanner.source.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && len !== 0) {
          if (eatHexSequence.call(this, offset + len + 1, false) === 0) {
            this.error();
          }
          return -1;
        }
        if (!isHexDigit(code)) {
          this.error(
            allowDash && len !== 0 ? "HyphenMinus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
            pos
          );
        }
        if (++len > 6) {
          this.error("Too many hex digits", pos);
        }
        ;
      }
      this.scanner.next();
      return len;
    }
    function eatQuestionMarkSequence(max) {
      var count = 0;
      while (this.scanner.isDelim(QUESTIONMARK)) {
        if (++count > max) {
          this.error("Too many question marks");
        }
        this.scanner.next();
      }
    }
    function startsWith(code) {
      if (this.scanner.source.charCodeAt(this.scanner.tokenStart) !== code) {
        this.error(NAME[code] + " is expected");
      }
    }
    function scanUnicodeRange() {
      var hexLength = 0;
      if (this.scanner.isDelim(PLUSSIGN)) {
        this.scanner.next();
        if (this.scanner.tokenType === IDENT) {
          hexLength = eatHexSequence.call(this, 0, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          return;
        }
        if (this.scanner.isDelim(QUESTIONMARK)) {
          this.scanner.next();
          eatQuestionMarkSequence.call(this, 5);
          return;
        }
        this.error("Hex digit or question mark is expected");
        return;
      }
      if (this.scanner.tokenType === NUMBER) {
        startsWith.call(this, PLUSSIGN);
        hexLength = eatHexSequence.call(this, 1, true);
        if (this.scanner.isDelim(QUESTIONMARK)) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
          return;
        }
        if (this.scanner.tokenType === DIMENSION || this.scanner.tokenType === NUMBER) {
          startsWith.call(this, HYPHENMINUS);
          eatHexSequence.call(this, 1, false);
          return;
        }
        return;
      }
      if (this.scanner.tokenType === DIMENSION) {
        startsWith.call(this, PLUSSIGN);
        hexLength = eatHexSequence.call(this, 1, true);
        if (hexLength > 0) {
          eatQuestionMarkSequence.call(this, 6 - hexLength);
        }
        return;
      }
      this.error();
    }
    module2.exports = {
      name: "UnicodeRange",
      structure: {
        value: String
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        if (!cmpChar(this.scanner.source, start, U)) {
          this.error("U is expected");
        }
        if (!cmpChar(this.scanner.source, start + 1, PLUSSIGN)) {
          this.error("Plus sign is expected");
        }
        this.scanner.next();
        scanUnicodeRange.call(this);
        return {
          type: "UnicodeRange",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value: this.scanner.substrToCursor(start)
        };
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Url.js
var require_Url = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Url.js"(exports2, module2) {
    var isWhiteSpace = require_tokenizer().isWhiteSpace;
    var cmpStr = require_tokenizer().cmpStr;
    var TYPE = require_tokenizer().TYPE;
    var FUNCTION = TYPE.Function;
    var URL = TYPE.Url;
    var RIGHTPARENTHESIS = TYPE.RightParenthesis;
    module2.exports = {
      name: "Url",
      structure: {
        value: ["String", "Raw"]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var value;
        switch (this.scanner.tokenType) {
          case URL:
            var rawStart = start + 4;
            var rawEnd = this.scanner.tokenEnd - 1;
            while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawStart))) {
              rawStart++;
            }
            while (rawStart < rawEnd && isWhiteSpace(this.scanner.source.charCodeAt(rawEnd - 1))) {
              rawEnd--;
            }
            value = {
              type: "Raw",
              loc: this.getLocation(rawStart, rawEnd),
              value: this.scanner.source.substring(rawStart, rawEnd)
            };
            this.eat(URL);
            break;
          case FUNCTION:
            if (!cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(")) {
              this.error("Function name must be `url`");
            }
            this.eat(FUNCTION);
            this.scanner.skipSC();
            value = this.String();
            this.scanner.skipSC();
            this.eat(RIGHTPARENTHESIS);
            break;
          default:
            this.error("Url or Function is expected");
        }
        return {
          type: "Url",
          loc: this.getLocation(start, this.scanner.tokenStart),
          value
        };
      },
      generate: function(node) {
        this.chunk("url");
        this.chunk("(");
        this.node(node.value);
        this.chunk(")");
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/Value.js
var require_Value = __commonJS({
  "node_modules/css-tree/lib/syntax/node/Value.js"(exports2, module2) {
    module2.exports = {
      name: "Value",
      structure: {
        children: [[]]
      },
      parse: function() {
        var start = this.scanner.tokenStart;
        var children = this.readSequence(this.scope.Value);
        return {
          type: "Value",
          loc: this.getLocation(start, this.scanner.tokenStart),
          children
        };
      },
      generate: function(node) {
        this.children(node);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/WhiteSpace.js
var require_WhiteSpace = __commonJS({
  "node_modules/css-tree/lib/syntax/node/WhiteSpace.js"(exports2, module2) {
    var WHITESPACE = require_tokenizer().TYPE.WhiteSpace;
    var SPACE = Object.freeze({
      type: "WhiteSpace",
      loc: null,
      value: " "
    });
    module2.exports = {
      name: "WhiteSpace",
      structure: {
        value: String
      },
      parse: function() {
        this.eat(WHITESPACE);
        return SPACE;
      },
      generate: function(node) {
        this.chunk(node.value);
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/node/index.js
var require_node2 = __commonJS({
  "node_modules/css-tree/lib/syntax/node/index.js"(exports2, module2) {
    module2.exports = {
      AnPlusB: require_AnPlusB(),
      Atrule: require_Atrule(),
      AtrulePrelude: require_AtrulePrelude(),
      AttributeSelector: require_AttributeSelector(),
      Block: require_Block(),
      Brackets: require_Brackets(),
      CDC: require_CDC(),
      CDO: require_CDO(),
      ClassSelector: require_ClassSelector(),
      Combinator: require_Combinator(),
      Comment: require_Comment(),
      Declaration: require_Declaration(),
      DeclarationList: require_DeclarationList(),
      Dimension: require_Dimension(),
      Function: require_Function(),
      Hash: require_Hash(),
      Identifier: require_Identifier(),
      IdSelector: require_IdSelector(),
      MediaFeature: require_MediaFeature(),
      MediaQuery: require_MediaQuery(),
      MediaQueryList: require_MediaQueryList(),
      Nth: require_Nth(),
      Number: require_Number(),
      Operator: require_Operator(),
      Parentheses: require_Parentheses(),
      Percentage: require_Percentage(),
      PseudoClassSelector: require_PseudoClassSelector(),
      PseudoElementSelector: require_PseudoElementSelector(),
      Ratio: require_Ratio(),
      Raw: require_Raw(),
      Rule: require_Rule(),
      Selector: require_Selector(),
      SelectorList: require_SelectorList(),
      String: require_String(),
      StyleSheet: require_StyleSheet(),
      TypeSelector: require_TypeSelector(),
      UnicodeRange: require_UnicodeRange(),
      Url: require_Url(),
      Value: require_Value(),
      WhiteSpace: require_WhiteSpace()
    };
  }
});

// node_modules/css-tree/lib/syntax/config/lexer.js
var require_lexer = __commonJS({
  "node_modules/css-tree/lib/syntax/config/lexer.js"(exports2, module2) {
    var data = require_data();
    module2.exports = {
      generic: true,
      types: data.types,
      atrules: data.atrules,
      properties: data.properties,
      node: require_node2()
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/default.js
var require_default = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/default.js"(exports2, module2) {
    var cmpChar = require_tokenizer().cmpChar;
    var cmpStr = require_tokenizer().cmpStr;
    var TYPE = require_tokenizer().TYPE;
    var IDENT = TYPE.Ident;
    var STRING = TYPE.String;
    var NUMBER = TYPE.Number;
    var FUNCTION = TYPE.Function;
    var URL = TYPE.Url;
    var HASH = TYPE.Hash;
    var DIMENSION = TYPE.Dimension;
    var PERCENTAGE = TYPE.Percentage;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    var COMMA = TYPE.Comma;
    var DELIM = TYPE.Delim;
    var NUMBERSIGN = 35;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var SOLIDUS = 47;
    var U = 117;
    module2.exports = function defaultRecognizer(context) {
      switch (this.scanner.tokenType) {
        case HASH:
          return this.Hash();
        case COMMA:
          context.space = null;
          context.ignoreWSAfter = true;
          return this.Operator();
        case LEFTPARENTHESIS:
          return this.Parentheses(this.readSequence, context.recognizer);
        case LEFTSQUAREBRACKET:
          return this.Brackets(this.readSequence, context.recognizer);
        case STRING:
          return this.String();
        case DIMENSION:
          return this.Dimension();
        case PERCENTAGE:
          return this.Percentage();
        case NUMBER:
          return this.Number();
        case FUNCTION:
          return cmpStr(this.scanner.source, this.scanner.tokenStart, this.scanner.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
        case URL:
          return this.Url();
        case IDENT:
          if (cmpChar(this.scanner.source, this.scanner.tokenStart, U) && cmpChar(this.scanner.source, this.scanner.tokenStart + 1, PLUSSIGN)) {
            return this.UnicodeRange();
          } else {
            return this.Identifier();
          }
        case DELIM:
          var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
            return this.Operator();
          }
          if (code === NUMBERSIGN) {
            this.error("Hex or identifier is expected", this.scanner.tokenStart + 1);
          }
          break;
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/atrulePrelude.js
var require_atrulePrelude = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/atrulePrelude.js"(exports2, module2) {
    module2.exports = {
      getNode: require_default()
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/selector.js
var require_selector = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/selector.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var DELIM = TYPE.Delim;
    var IDENT = TYPE.Ident;
    var DIMENSION = TYPE.Dimension;
    var PERCENTAGE = TYPE.Percentage;
    var NUMBER = TYPE.Number;
    var HASH = TYPE.Hash;
    var COLON = TYPE.Colon;
    var LEFTSQUAREBRACKET = TYPE.LeftSquareBracket;
    var NUMBERSIGN = 35;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var FULLSTOP = 46;
    var GREATERTHANSIGN = 62;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function getNode(context) {
      switch (this.scanner.tokenType) {
        case LEFTSQUAREBRACKET:
          return this.AttributeSelector();
        case HASH:
          return this.IdSelector();
        case COLON:
          if (this.scanner.lookupType(1) === COLON) {
            return this.PseudoElementSelector();
          } else {
            return this.PseudoClassSelector();
          }
        case IDENT:
          return this.TypeSelector();
        case NUMBER:
        case PERCENTAGE:
          return this.Percentage();
        case DIMENSION:
          if (this.scanner.source.charCodeAt(this.scanner.tokenStart) === FULLSTOP) {
            this.error("Identifier is expected", this.scanner.tokenStart + 1);
          }
          break;
        case DELIM:
          var code = this.scanner.source.charCodeAt(this.scanner.tokenStart);
          switch (code) {
            case PLUSSIGN:
            case GREATERTHANSIGN:
            case TILDE:
              context.space = null;
              context.ignoreWSAfter = true;
              return this.Combinator();
            case SOLIDUS:
              return this.Combinator();
            case FULLSTOP:
              return this.ClassSelector();
            case ASTERISK:
            case VERTICALLINE:
              return this.TypeSelector();
            case NUMBERSIGN:
              return this.IdSelector();
          }
          break;
      }
    }
    module2.exports = {
      getNode
    };
  }
});

// node_modules/css-tree/lib/syntax/function/expression.js
var require_expression = __commonJS({
  "node_modules/css-tree/lib/syntax/function/expression.js"(exports2, module2) {
    module2.exports = function() {
      return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
      );
    };
  }
});

// node_modules/css-tree/lib/syntax/function/var.js
var require_var = __commonJS({
  "node_modules/css-tree/lib/syntax/function/var.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var rawMode = require_Raw().mode;
    var COMMA = TYPE.Comma;
    var WHITESPACE = TYPE.WhiteSpace;
    module2.exports = function() {
      var children = this.createList();
      this.scanner.skipSC();
      children.push(this.Identifier());
      this.scanner.skipSC();
      if (this.scanner.tokenType === COMMA) {
        children.push(this.Operator());
        const startIndex = this.scanner.tokenIndex;
        const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.scanner.tokenIndex, rawMode.exclamationMarkOrSemicolon, false);
        if (value.type === "Value" && value.children.isEmpty()) {
          for (let offset = startIndex - this.scanner.tokenIndex; offset <= 0; offset++) {
            if (this.scanner.lookupType(offset) === WHITESPACE) {
              value.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " "
              });
              break;
            }
          }
        }
        children.push(value);
      }
      return children;
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/value.js
var require_value = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/value.js"(exports2, module2) {
    module2.exports = {
      getNode: require_default(),
      "expression": require_expression(),
      "var": require_var()
    };
  }
});

// node_modules/css-tree/lib/syntax/scope/index.js
var require_scope = __commonJS({
  "node_modules/css-tree/lib/syntax/scope/index.js"(exports2, module2) {
    module2.exports = {
      AtrulePrelude: require_atrulePrelude(),
      Selector: require_selector(),
      Value: require_value()
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/font-face.js
var require_font_face = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/font-face.js"(exports2, module2) {
    module2.exports = {
      parse: {
        prelude: null,
        block: function() {
          return this.Block(true);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/import.js
var require_import = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/import.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var STRING = TYPE.String;
    var IDENT = TYPE.Ident;
    var URL = TYPE.Url;
    var FUNCTION = TYPE.Function;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    module2.exports = {
      parse: {
        prelude: function() {
          var children = this.createList();
          this.scanner.skipSC();
          switch (this.scanner.tokenType) {
            case STRING:
              children.push(this.String());
              break;
            case URL:
            case FUNCTION:
              children.push(this.Url());
              break;
            default:
              this.error("String or url() is expected");
          }
          if (this.lookupNonWSType(0) === IDENT || this.lookupNonWSType(0) === LEFTPARENTHESIS) {
            children.push(this.WhiteSpace());
            children.push(this.MediaQueryList());
          }
          return children;
        },
        block: null
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/media.js
var require_media = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/media.js"(exports2, module2) {
    module2.exports = {
      parse: {
        prelude: function() {
          return this.createSingleNodeList(
            this.MediaQueryList()
          );
        },
        block: function() {
          return this.Block(false);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/page.js
var require_page = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/page.js"(exports2, module2) {
    module2.exports = {
      parse: {
        prelude: function() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        },
        block: function() {
          return this.Block(true);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/supports.js
var require_supports = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/supports.js"(exports2, module2) {
    var TYPE = require_tokenizer().TYPE;
    var WHITESPACE = TYPE.WhiteSpace;
    var COMMENT = TYPE.Comment;
    var IDENT = TYPE.Ident;
    var FUNCTION = TYPE.Function;
    var COLON = TYPE.Colon;
    var LEFTPARENTHESIS = TYPE.LeftParenthesis;
    function consumeRaw() {
      return this.createSingleNodeList(
        this.Raw(this.scanner.tokenIndex, null, false)
      );
    }
    function parentheses() {
      this.scanner.skipSC();
      if (this.scanner.tokenType === IDENT && this.lookupNonWSType(1) === COLON) {
        return this.createSingleNodeList(
          this.Declaration()
        );
      }
      return readSequence.call(this);
    }
    function readSequence() {
      var children = this.createList();
      var space = null;
      var child;
      this.scanner.skipSC();
      scan:
        while (!this.scanner.eof) {
          switch (this.scanner.tokenType) {
            case WHITESPACE:
              space = this.WhiteSpace();
              continue;
            case COMMENT:
              this.scanner.next();
              continue;
            case FUNCTION:
              child = this.Function(consumeRaw, this.scope.AtrulePrelude);
              break;
            case IDENT:
              child = this.Identifier();
              break;
            case LEFTPARENTHESIS:
              child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
              break;
            default:
              break scan;
          }
          if (space !== null) {
            children.push(space);
            space = null;
          }
          children.push(child);
        }
      return children;
    }
    module2.exports = {
      parse: {
        prelude: function() {
          var children = readSequence.call(this);
          if (this.getFirstListNode(children) === null) {
            this.error("Condition is expected");
          }
          return children;
        },
        block: function() {
          return this.Block(false);
        }
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/atrule/index.js
var require_atrule = __commonJS({
  "node_modules/css-tree/lib/syntax/atrule/index.js"(exports2, module2) {
    module2.exports = {
      "font-face": require_font_face(),
      "import": require_import(),
      "media": require_media(),
      "page": require_page(),
      "supports": require_supports()
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/dir.js
var require_dir = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/dir.js"(exports2, module2) {
    module2.exports = {
      parse: function() {
        return this.createSingleNodeList(
          this.Identifier()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/has.js
var require_has = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/has.js"(exports2, module2) {
    module2.exports = {
      parse: function() {
        return this.createSingleNodeList(
          this.SelectorList()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/lang.js
var require_lang = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/lang.js"(exports2, module2) {
    module2.exports = {
      parse: function() {
        return this.createSingleNodeList(
          this.Identifier()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/common/selectorList.js
var require_selectorList = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/common/selectorList.js"(exports2, module2) {
    module2.exports = {
      parse: function selectorList() {
        return this.createSingleNodeList(
          this.SelectorList()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/matches.js
var require_matches = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/matches.js"(exports2, module2) {
    module2.exports = require_selectorList();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/not.js
var require_not = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/not.js"(exports2, module2) {
    module2.exports = require_selectorList();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/common/nthWithOfClause.js
var require_nthWithOfClause = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/common/nthWithOfClause.js"(exports2, module2) {
    var ALLOW_OF_CLAUSE = true;
    module2.exports = {
      parse: function nthWithOfClause() {
        return this.createSingleNodeList(
          this.Nth(ALLOW_OF_CLAUSE)
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/nth-child.js
var require_nth_child = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/nth-child.js"(exports2, module2) {
    module2.exports = require_nthWithOfClause();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/nth-last-child.js
var require_nth_last_child = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/nth-last-child.js"(exports2, module2) {
    module2.exports = require_nthWithOfClause();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/common/nth.js
var require_nth = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/common/nth.js"(exports2, module2) {
    var DISALLOW_OF_CLAUSE = false;
    module2.exports = {
      parse: function nth() {
        return this.createSingleNodeList(
          this.Nth(DISALLOW_OF_CLAUSE)
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/nth-last-of-type.js
var require_nth_last_of_type = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/nth-last-of-type.js"(exports2, module2) {
    module2.exports = require_nth();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/nth-of-type.js
var require_nth_of_type = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/nth-of-type.js"(exports2, module2) {
    module2.exports = require_nth();
  }
});

// node_modules/css-tree/lib/syntax/pseudo/slotted.js
var require_slotted = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/slotted.js"(exports2, module2) {
    module2.exports = {
      parse: function compoundSelector() {
        return this.createSingleNodeList(
          this.Selector()
        );
      }
    };
  }
});

// node_modules/css-tree/lib/syntax/pseudo/index.js
var require_pseudo = __commonJS({
  "node_modules/css-tree/lib/syntax/pseudo/index.js"(exports2, module2) {
    module2.exports = {
      "dir": require_dir(),
      "has": require_has(),
      "lang": require_lang(),
      "matches": require_matches(),
      "not": require_not(),
      "nth-child": require_nth_child(),
      "nth-last-child": require_nth_last_child(),
      "nth-last-of-type": require_nth_last_of_type(),
      "nth-of-type": require_nth_of_type(),
      "slotted": require_slotted()
    };
  }
});

// node_modules/css-tree/lib/syntax/config/parser.js
var require_parser = __commonJS({
  "node_modules/css-tree/lib/syntax/config/parser.js"(exports2, module2) {
    module2.exports = {
      parseContext: {
        default: "StyleSheet",
        stylesheet: "StyleSheet",
        atrule: "Atrule",
        atrulePrelude: function(options) {
          return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: "MediaQueryList",
        mediaQuery: "MediaQuery",
        rule: "Rule",
        selectorList: "SelectorList",
        selector: "Selector",
        block: function() {
          return this.Block(true);
        },
        declarationList: "DeclarationList",
        declaration: "Declaration",
        value: "Value"
      },
      scope: require_scope(),
      atrule: require_atrule(),
      pseudo: require_pseudo(),
      node: require_node2()
    };
  }
});

// node_modules/css-tree/lib/syntax/config/walker.js
var require_walker = __commonJS({
  "node_modules/css-tree/lib/syntax/config/walker.js"(exports2, module2) {
    module2.exports = {
      node: require_node2()
    };
  }
});

// node_modules/css-tree/package.json
var require_package = __commonJS({
  "node_modules/css-tree/package.json"(exports2, module2) {
    module2.exports = {
      name: "css-tree",
      version: "1.1.3",
      description: "A tool set for CSS: fast detailed parser (CSS \u2192 AST), walker (AST traversal), generator (AST \u2192 CSS) and lexer (validation and matching) based on specs and browser implementations",
      author: "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
      license: "MIT",
      repository: "csstree/csstree",
      keywords: [
        "css",
        "ast",
        "tokenizer",
        "parser",
        "walker",
        "lexer",
        "generator",
        "utils",
        "syntax",
        "validation"
      ],
      main: "lib/index.js",
      unpkg: "dist/csstree.min.js",
      jsdelivr: "dist/csstree.min.js",
      scripts: {
        build: "rollup --config",
        lint: "eslint data lib scripts test && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
        "lint-and-test": "npm run lint && npm test",
        "update:docs": "node scripts/update-docs",
        "review:syntax-patch": "node scripts/review-syntax-patch",
        test: "mocha --reporter progress",
        coverage: "nyc npm test",
        travis: "nyc npm run lint-and-test && npm run coveralls",
        coveralls: "nyc report --reporter=text-lcov | coveralls",
        prepublishOnly: "npm run build",
        hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
      },
      dependencies: {
        "mdn-data": "2.0.14",
        "source-map": "^0.6.1"
      },
      devDependencies: {
        "@rollup/plugin-commonjs": "^11.0.2",
        "@rollup/plugin-json": "^4.0.2",
        "@rollup/plugin-node-resolve": "^7.1.1",
        coveralls: "^3.0.9",
        eslint: "^6.8.0",
        "json-to-ast": "^2.1.0",
        mocha: "^6.2.3",
        nyc: "^14.1.1",
        rollup: "^1.32.1",
        "rollup-plugin-terser": "^5.3.0"
      },
      engines: {
        node: ">=8.0.0"
      },
      files: [
        "data",
        "dist",
        "lib"
      ]
    };
  }
});

// node_modules/css-tree/lib/syntax/index.js
var require_syntax = __commonJS({
  "node_modules/css-tree/lib/syntax/index.js"(exports2, module2) {
    function merge() {
      var dest = {};
      for (var i = 0; i < arguments.length; i++) {
        var src = arguments[i];
        for (var key in src) {
          dest[key] = src[key];
        }
      }
      return dest;
    }
    module2.exports = require_create5().create(
      merge(
        require_lexer(),
        require_parser(),
        require_walker()
      )
    );
    module2.exports.version = require_package().version;
  }
});

// node_modules/css-tree/lib/index.js
var require_lib10 = __commonJS({
  "node_modules/css-tree/lib/index.js"(exports2, module2) {
    module2.exports = require_syntax();
  }
});

// node_modules/stable/stable.js
var require_stable = __commonJS({
  "node_modules/stable/stable.js"(exports2, module2) {
    (function(global, factory) {
      typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global.stable = factory();
    })(exports2, function() {
      "use strict";
      var stable = function(arr, comp) {
        return exec(arr.slice(), comp);
      };
      stable.inplace = function(arr, comp) {
        var result = exec(arr, comp);
        if (result !== arr) {
          pass(result, null, arr.length, arr);
        }
        return arr;
      };
      function exec(arr, comp) {
        if (typeof comp !== "function") {
          comp = function(a, b) {
            return String(a).localeCompare(b);
          };
        }
        var len = arr.length;
        if (len <= 1) {
          return arr;
        }
        var buffer = new Array(len);
        for (var chk = 1; chk < len; chk *= 2) {
          pass(arr, comp, chk, buffer);
          var tmp = arr;
          arr = buffer;
          buffer = tmp;
        }
        return arr;
      }
      var pass = function(arr, comp, chk, result) {
        var len = arr.length;
        var i = 0;
        var dbl = chk * 2;
        var l, r, e;
        var li, ri;
        for (l = 0; l < len; l += dbl) {
          r = l + chk;
          e = r + chk;
          if (r > len) r = len;
          if (e > len) e = len;
          li = l;
          ri = r;
          while (true) {
            if (li < r && ri < e) {
              if (comp(arr[li], arr[ri]) <= 0) {
                result[i++] = arr[li++];
              } else {
                result[i++] = arr[ri++];
              }
            } else if (li < r) {
              result[i++] = arr[li++];
            } else if (ri < e) {
              result[i++] = arr[ri++];
            } else {
              break;
            }
          }
        }
      };
      return stable;
    });
  }
});

// node_modules/csso/lib/restructure/prepare/specificity.js
var require_specificity = __commonJS({
  "node_modules/csso/lib/restructure/prepare/specificity.js"(exports2, module2) {
    module2.exports = function specificity(simpleSelector) {
      var A = 0;
      var B = 0;
      var C = 0;
      simpleSelector.children.each(function walk(node) {
        switch (node.type) {
          case "SelectorList":
          case "Selector":
            node.children.each(walk);
            break;
          case "IdSelector":
            A++;
            break;
          case "ClassSelector":
          case "AttributeSelector":
            B++;
            break;
          case "PseudoClassSelector":
            switch (node.name.toLowerCase()) {
              case "not":
                node.children.each(walk);
                break;
              case "before":
              case "after":
              case "first-line":
              case "first-letter":
                C++;
                break;
              default:
                B++;
            }
            break;
          case "PseudoElementSelector":
            C++;
            break;
          case "TypeSelector":
            if (node.name.charAt(node.name.length - 1) !== "*") {
              C++;
            }
            break;
        }
      });
      return [A, B, C];
    };
  }
});

// node_modules/svgo/lib/css-tools.js
var require_css_tools = __commonJS({
  "node_modules/svgo/lib/css-tools.js"(exports2, module2) {
    "use strict";
    var csstree = require_lib10();
    var List = csstree.List;
    var stable = require_stable();
    var specificity = require_specificity();
    function flattenToSelectors(cssAst) {
      var selectors = [];
      csstree.walk(cssAst, {
        visit: "Rule",
        enter: function(node) {
          if (node.type !== "Rule") {
            return;
          }
          var atrule = this.atrule;
          var rule = node;
          node.prelude.children.each(function(selectorNode, selectorItem) {
            var selector = {
              item: selectorItem,
              atrule,
              rule,
              pseudos: (
                /** @type {{item: any; list: any[]}[]} */
                []
              )
            };
            selectorNode.children.each(function(selectorChildNode, selectorChildItem, selectorChildList) {
              if (selectorChildNode.type === "PseudoClassSelector" || selectorChildNode.type === "PseudoElementSelector") {
                selector.pseudos.push({
                  item: selectorChildItem,
                  list: selectorChildList
                });
              }
            });
            selectors.push(selector);
          });
        }
      });
      return selectors;
    }
    function filterByMqs(selectors, useMqs) {
      return selectors.filter(function(selector) {
        if (selector.atrule === null) {
          return ~useMqs.indexOf("");
        }
        var mqName = selector.atrule.name;
        var mqStr = mqName;
        if (selector.atrule.expression && selector.atrule.expression.children.first().type === "MediaQueryList") {
          var mqExpr = csstree.generate(selector.atrule.expression);
          mqStr = [mqName, mqExpr].join(" ");
        }
        return ~useMqs.indexOf(mqStr);
      });
    }
    function filterByPseudos(selectors, usePseudos) {
      return selectors.filter(function(selector) {
        var pseudoSelectorsStr = csstree.generate({
          type: "Selector",
          children: new List().fromArray(
            selector.pseudos.map(function(pseudo) {
              return pseudo.item.data;
            })
          )
        });
        return ~usePseudos.indexOf(pseudoSelectorsStr);
      });
    }
    function cleanPseudos(selectors) {
      selectors.forEach(function(selector) {
        selector.pseudos.forEach(function(pseudo) {
          pseudo.list.remove(pseudo.item);
        });
      });
    }
    function compareSpecificity(aSpecificity, bSpecificity) {
      for (var i = 0; i < 4; i += 1) {
        if (aSpecificity[i] < bSpecificity[i]) {
          return -1;
        } else if (aSpecificity[i] > bSpecificity[i]) {
          return 1;
        }
      }
      return 0;
    }
    function compareSimpleSelectorNode(aSimpleSelectorNode, bSimpleSelectorNode) {
      var aSpecificity = specificity(aSimpleSelectorNode), bSpecificity = specificity(bSimpleSelectorNode);
      return compareSpecificity(aSpecificity, bSpecificity);
    }
    function _bySelectorSpecificity(selectorA, selectorB) {
      return compareSimpleSelectorNode(selectorA.item.data, selectorB.item.data);
    }
    function sortSelectors(selectors) {
      return stable(selectors, _bySelectorSpecificity);
    }
    function csstreeToStyleDeclaration(declaration) {
      var propertyName = declaration.property, propertyValue = csstree.generate(declaration.value), propertyPriority = declaration.important ? "important" : "";
      return {
        name: propertyName,
        value: propertyValue,
        priority: propertyPriority
      };
    }
    function getCssStr(elem) {
      if (elem.children.length > 0 && (elem.children[0].type === "text" || elem.children[0].type === "cdata")) {
        return elem.children[0].value;
      }
      return "";
    }
    function setCssStr(elem, css) {
      if (elem.children.length === 0) {
        elem.children.push({
          type: "text",
          value: ""
        });
      }
      if (elem.children[0].type !== "text" && elem.children[0].type !== "cdata") {
        return css;
      }
      elem.children[0].value = css;
      return css;
    }
    module2.exports.flattenToSelectors = flattenToSelectors;
    module2.exports.filterByMqs = filterByMqs;
    module2.exports.filterByPseudos = filterByPseudos;
    module2.exports.cleanPseudos = cleanPseudos;
    module2.exports.compareSpecificity = compareSpecificity;
    module2.exports.compareSimpleSelectorNode = compareSimpleSelectorNode;
    module2.exports.sortSelectors = sortSelectors;
    module2.exports.csstreeToStyleDeclaration = csstreeToStyleDeclaration;
    module2.exports.getCssStr = getCssStr;
    module2.exports.setCssStr = setCssStr;
  }
});

// node_modules/svgo/lib/svgo/css-style-declaration.js
var require_css_style_declaration = __commonJS({
  "node_modules/svgo/lib/svgo/css-style-declaration.js"(exports2, module2) {
    "use strict";
    var csstree = require_lib10();
    var csstools = require_css_tools();
    var CSSStyleDeclaration = function(node) {
      this.parentNode = node;
      this.properties = /* @__PURE__ */ new Map();
      this.hasSynced = false;
      this.styleValue = null;
      this.parseError = false;
      const value = node.attributes.style;
      if (value != null) {
        this.addStyleValueHandler();
        this.setStyleValue(value);
      }
    };
    CSSStyleDeclaration.prototype.addStyleValueHandler = function() {
      Object.defineProperty(this.parentNode.attributes, "style", {
        get: this.getStyleValue.bind(this),
        set: this.setStyleValue.bind(this),
        enumerable: true,
        configurable: true
      });
    };
    CSSStyleDeclaration.prototype.getStyleValue = function() {
      return this.getCssText();
    };
    CSSStyleDeclaration.prototype.setStyleValue = function(newValue) {
      this.properties.clear();
      this.styleValue = newValue;
      this.hasSynced = false;
    };
    CSSStyleDeclaration.prototype._loadCssText = function() {
      if (this.hasSynced) {
        return;
      }
      this.hasSynced = true;
      if (!this.styleValue || this.styleValue.length === 0) {
        return;
      }
      var inlineCssStr = this.styleValue;
      var declarations = {};
      try {
        declarations = csstree.parse(inlineCssStr, {
          context: "declarationList",
          parseValue: false
        });
      } catch (parseError) {
        this.parseError = parseError;
        return;
      }
      this.parseError = false;
      var self = this;
      declarations.children.each(function(declaration) {
        try {
          var styleDeclaration = csstools.csstreeToStyleDeclaration(declaration);
          self.setProperty(
            styleDeclaration.name,
            styleDeclaration.value,
            styleDeclaration.priority
          );
        } catch (styleError) {
          if (styleError.message !== "Unknown node type: undefined") {
            self.parseError = styleError;
          }
        }
      });
    };
    CSSStyleDeclaration.prototype.getCssText = function() {
      var properties = this.getProperties();
      if (this.parseError) {
        return this.styleValue;
      }
      var cssText = [];
      properties.forEach(function(property, propertyName) {
        var strImportant = property.priority === "important" ? "!important" : "";
        cssText.push(
          propertyName.trim() + ":" + property.value.trim() + strImportant
        );
      });
      return cssText.join(";");
    };
    CSSStyleDeclaration.prototype._handleParseError = function() {
      if (this.parseError) {
        console.warn(
          "Warning: Parse error when parsing inline styles, style properties of this element cannot be used. The raw styles can still be get/set using .attr('style').value. Error details: " + this.parseError
        );
      }
    };
    CSSStyleDeclaration.prototype._getProperty = function(propertyName) {
      if (typeof propertyName === "undefined") {
        throw Error("1 argument required, but only 0 present.");
      }
      var properties = this.getProperties();
      this._handleParseError();
      var property = properties.get(propertyName.trim());
      return property;
    };
    CSSStyleDeclaration.prototype.getPropertyPriority = function(propertyName) {
      var property = this._getProperty(propertyName);
      return property ? property.priority : "";
    };
    CSSStyleDeclaration.prototype.getPropertyValue = function(propertyName) {
      var property = this._getProperty(propertyName);
      return property ? property.value : null;
    };
    CSSStyleDeclaration.prototype.item = function(index) {
      if (typeof index === "undefined") {
        throw Error("1 argument required, but only 0 present.");
      }
      var properties = this.getProperties();
      this._handleParseError();
      return Array.from(properties.keys())[index];
    };
    CSSStyleDeclaration.prototype.getProperties = function() {
      this._loadCssText();
      return this.properties;
    };
    CSSStyleDeclaration.prototype.removeProperty = function(propertyName) {
      if (typeof propertyName === "undefined") {
        throw Error("1 argument required, but only 0 present.");
      }
      this.addStyleValueHandler();
      var properties = this.getProperties();
      this._handleParseError();
      var oldValue = this.getPropertyValue(propertyName);
      properties.delete(propertyName.trim());
      return oldValue;
    };
    CSSStyleDeclaration.prototype.setProperty = function(propertyName, value, priority) {
      if (typeof propertyName === "undefined") {
        throw Error("propertyName argument required, but only not present.");
      }
      this.addStyleValueHandler();
      var properties = this.getProperties();
      this._handleParseError();
      var property = {
        value: value.trim(),
        priority: priority.trim()
      };
      properties.set(propertyName.trim(), property);
      return property;
    };
    module2.exports = CSSStyleDeclaration;
  }
});

// node_modules/svgo/lib/svgo/jsAPI.js
var require_jsAPI = __commonJS({
  "node_modules/svgo/lib/svgo/jsAPI.js"(exports2, module2) {
    "use strict";
    var { selectAll, selectOne, is } = require_lib9();
    var svgoCssSelectAdapter = require_css_select_adapter();
    var CSSClassList = require_css_class_list();
    var CSSStyleDeclaration = require_css_style_declaration();
    var parseName = (name) => {
      if (name == null) {
        return {
          prefix: "",
          local: ""
        };
      }
      if (name === "xmlns") {
        return {
          prefix: "xmlns",
          local: ""
        };
      }
      const chunks = name.split(":");
      if (chunks.length === 1) {
        return {
          prefix: "",
          local: chunks[0]
        };
      }
      return {
        prefix: chunks[0],
        local: chunks[1]
      };
    };
    var cssSelectOpts = {
      xmlMode: true,
      adapter: svgoCssSelectAdapter
    };
    var attrsHandler = {
      get: (attributes, name) => {
        if (attributes.hasOwnProperty(name)) {
          return {
            name,
            get value() {
              return attributes[name];
            },
            set value(value) {
              attributes[name] = value;
            }
          };
        }
      },
      set: (attributes, name, attr) => {
        attributes[name] = attr.value;
        return true;
      }
    };
    var JSAPI = function(data, parentNode) {
      Object.assign(this, data);
      if (this.type === "element") {
        if (this.attributes == null) {
          this.attributes = {};
        }
        if (this.children == null) {
          this.children = [];
        }
        Object.defineProperty(this, "class", {
          writable: true,
          configurable: true,
          value: new CSSClassList(this)
        });
        Object.defineProperty(this, "style", {
          writable: true,
          configurable: true,
          value: new CSSStyleDeclaration(this)
        });
        Object.defineProperty(this, "parentNode", {
          writable: true,
          value: parentNode
        });
        const element = this;
        Object.defineProperty(this, "attrs", {
          configurable: true,
          get() {
            return new Proxy(element.attributes, attrsHandler);
          },
          set(value) {
            const newAttributes = {};
            for (const attr of Object.values(value)) {
              newAttributes[attr.name] = attr.value;
            }
            element.attributes = newAttributes;
          }
        });
      }
    };
    module2.exports = JSAPI;
    JSAPI.prototype.clone = function() {
      const { children, ...nodeData } = this;
      const clonedNode = new JSAPI(JSON.parse(JSON.stringify(nodeData)), null);
      if (children) {
        clonedNode.children = children.map((child) => {
          const clonedChild = child.clone();
          clonedChild.parentNode = clonedNode;
          return clonedChild;
        });
      }
      return clonedNode;
    };
    JSAPI.prototype.isElem = function(param) {
      if (this.type !== "element") {
        return false;
      }
      if (param == null) {
        return true;
      }
      if (Array.isArray(param)) {
        return param.includes(this.name);
      }
      return this.name === param;
    };
    JSAPI.prototype.renameElem = function(name) {
      if (name && typeof name === "string") this.name = name;
      return this;
    };
    JSAPI.prototype.isEmpty = function() {
      return !this.children || !this.children.length;
    };
    JSAPI.prototype.closestElem = function(elemName) {
      var elem = this;
      while ((elem = elem.parentNode) && !elem.isElem(elemName)) ;
      return elem;
    };
    JSAPI.prototype.spliceContent = function(start, n, insertion) {
      if (arguments.length < 2) return [];
      if (!Array.isArray(insertion))
        insertion = Array.apply(null, arguments).slice(2);
      insertion.forEach(function(inner) {
        inner.parentNode = this;
      }, this);
      return this.children.splice.apply(
        this.children,
        [start, n].concat(insertion)
      );
    };
    JSAPI.prototype.hasAttr = function(name, val) {
      if (this.type !== "element") {
        return false;
      }
      if (Object.keys(this.attributes).length === 0) {
        return false;
      }
      if (name == null) {
        return true;
      }
      if (this.attributes.hasOwnProperty(name) === false) {
        return false;
      }
      if (val !== void 0) {
        return this.attributes[name] === val.toString();
      }
      return true;
    };
    JSAPI.prototype.hasAttrLocal = function(localName, val) {
      if (!this.attrs || !Object.keys(this.attrs).length) return false;
      if (!arguments.length) return !!this.attrs;
      var callback;
      switch (val != null && val.constructor && val.constructor.name) {
        case "Number":
        case "String":
          callback = stringValueTest;
          break;
        case "RegExp":
          callback = regexpValueTest;
          break;
        case "Function":
          callback = funcValueTest;
          break;
        default:
          callback = nameTest;
      }
      return this.someAttr(callback);
      function nameTest(attr) {
        const { local } = parseName(attr.name);
        return local === localName;
      }
      function stringValueTest(attr) {
        const { local } = parseName(attr.name);
        return local === localName && val == attr.value;
      }
      function regexpValueTest(attr) {
        const { local } = parseName(attr.name);
        return local === localName && val.test(attr.value);
      }
      function funcValueTest(attr) {
        const { local } = parseName(attr.name);
        return local === localName && val(attr.value);
      }
    };
    JSAPI.prototype.attr = function(name, val) {
      if (this.hasAttr(name, val)) {
        return this.attrs[name];
      }
    };
    JSAPI.prototype.computedAttr = function(name, val) {
      if (!arguments.length) return;
      for (var elem = this; elem && (!elem.hasAttr(name) || !elem.attributes[name]); elem = elem.parentNode) ;
      if (val != null) {
        return elem ? elem.hasAttr(name, val) : false;
      } else if (elem && elem.hasAttr(name)) {
        return elem.attributes[name];
      }
    };
    JSAPI.prototype.removeAttr = function(name, val) {
      if (this.type !== "element") {
        return false;
      }
      if (arguments.length === 0) {
        return false;
      }
      if (Array.isArray(name)) {
        for (const nameItem of name) {
          this.removeAttr(nameItem, val);
        }
        return false;
      }
      if (this.hasAttr(name, val) === false) {
        return false;
      }
      delete this.attributes[name];
      return true;
    };
    JSAPI.prototype.addAttr = function(attr) {
      attr = attr || {};
      if (attr.name === void 0) return false;
      this.attributes[attr.name] = attr.value;
      if (attr.name === "class") {
        this.class.addClassValueHandler();
      }
      if (attr.name === "style") {
        this.style.addStyleValueHandler();
      }
      return this.attrs[attr.name];
    };
    JSAPI.prototype.eachAttr = function(callback, context) {
      if (this.type !== "element") {
        return false;
      }
      if (callback == null) {
        return false;
      }
      for (const attr of Object.values(this.attrs)) {
        callback.call(context, attr);
      }
      return true;
    };
    JSAPI.prototype.someAttr = function(callback, context) {
      if (this.type !== "element") {
        return false;
      }
      for (const attr of Object.values(this.attrs)) {
        if (callback.call(context, attr)) return true;
      }
      return false;
    };
    JSAPI.prototype.querySelectorAll = function(selectors) {
      var matchedEls = selectAll(selectors, this, cssSelectOpts);
      return matchedEls.length > 0 ? matchedEls : null;
    };
    JSAPI.prototype.querySelector = function(selectors) {
      return selectOne(selectors, this, cssSelectOpts);
    };
    JSAPI.prototype.matches = function(selector) {
      return is(this, selector, cssSelectOpts);
    };
  }
});

// node_modules/svgo/plugins/mergeStyles.js
var require_mergeStyles = __commonJS({
  "node_modules/svgo/plugins/mergeStyles.js"(exports2) {
    "use strict";
    var { visitSkip, detachNodeFromParent } = require_xast();
    var JSAPI = require_jsAPI();
    exports2.name = "mergeStyles";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "merge multiple style elements into one";
    exports2.fn = () => {
      let firstStyleElement = null;
      let collectedStyles = "";
      let styleContentType = "text";
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "foreignObject") {
              return visitSkip;
            }
            if (node.name !== "style") {
              return;
            }
            if (node.attributes.type != null && node.attributes.type !== "" && node.attributes.type !== "text/css") {
              return;
            }
            let css = "";
            for (const child of node.children) {
              if (child.type === "text") {
                css += child.value;
              }
              if (child.type === "cdata") {
                styleContentType = "cdata";
                css += child.value;
              }
            }
            if (css.trim().length === 0) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (node.attributes.media == null) {
              collectedStyles += css;
            } else {
              collectedStyles += `@media ${node.attributes.media}{${css}}`;
              delete node.attributes.media;
            }
            if (firstStyleElement == null) {
              firstStyleElement = node;
            } else {
              detachNodeFromParent(node, parentNode);
              firstStyleElement.children = [
                new JSAPI(
                  { type: styleContentType, value: collectedStyles },
                  firstStyleElement
                )
              ];
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/inlineStyles.js
var require_inlineStyles = __commonJS({
  "node_modules/svgo/plugins/inlineStyles.js"(exports2) {
    "use strict";
    var csstree = require_lib10();
    var specificity = require_specificity();
    var stable = require_stable();
    var {
      visitSkip,
      querySelectorAll,
      detachNodeFromParent
    } = require_xast();
    exports2.type = "visitor";
    exports2.name = "inlineStyles";
    exports2.active = true;
    exports2.description = "inline styles (additional options)";
    var compareSpecificity = (a, b) => {
      for (var i = 0; i < 4; i += 1) {
        if (a[i] < b[i]) {
          return -1;
        } else if (a[i] > b[i]) {
          return 1;
        }
      }
      return 0;
    };
    exports2.fn = (root, params) => {
      const {
        onlyMatchedOnce = true,
        removeMatchedSelectors = true,
        useMqs = ["", "screen"],
        usePseudos = [""]
      } = params;
      const styles = [];
      let selectors = [];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "foreignObject") {
              return visitSkip;
            }
            if (node.name !== "style" || node.children.length === 0) {
              return;
            }
            if (node.attributes.type != null && node.attributes.type !== "" && node.attributes.type !== "text/css") {
              return;
            }
            let cssText = "";
            for (const child of node.children) {
              if (child.type === "text" || child.type === "cdata") {
                cssText += child.value;
              }
            }
            let cssAst = null;
            try {
              cssAst = csstree.parse(cssText, {
                parseValue: false,
                parseCustomProperty: false
              });
            } catch {
              return;
            }
            if (cssAst.type === "StyleSheet") {
              styles.push({ node, parentNode, cssAst });
            }
            csstree.walk(cssAst, {
              visit: "Selector",
              enter(node2, item) {
                const atrule = this.atrule;
                const rule = this.rule;
                if (rule == null) {
                  return;
                }
                let mq = "";
                if (atrule != null) {
                  mq = atrule.name;
                  if (atrule.prelude != null) {
                    mq += ` ${csstree.generate(atrule.prelude)}`;
                  }
                }
                if (useMqs.includes(mq) === false) {
                  return;
                }
                const pseudos = [];
                if (node2.type === "Selector") {
                  node2.children.each((childNode, childItem, childList) => {
                    if (childNode.type === "PseudoClassSelector" || childNode.type === "PseudoElementSelector") {
                      pseudos.push({ item: childItem, list: childList });
                    }
                  });
                }
                const pseudoSelectors = csstree.generate({
                  type: "Selector",
                  children: new csstree.List().fromArray(
                    pseudos.map((pseudo) => pseudo.item.data)
                  )
                });
                if (usePseudos.includes(pseudoSelectors) === false) {
                  return;
                }
                for (const pseudo of pseudos) {
                  pseudo.list.remove(pseudo.item);
                }
                selectors.push({ node: node2, item, rule });
              }
            });
          }
        },
        root: {
          exit: () => {
            if (styles.length === 0) {
              return;
            }
            const sortedSelectors = stable(selectors, (a, b) => {
              const aSpecificity = specificity(a.item.data);
              const bSpecificity = specificity(b.item.data);
              return compareSpecificity(aSpecificity, bSpecificity);
            }).reverse();
            for (const selector of sortedSelectors) {
              const selectorText = csstree.generate(selector.item.data);
              const matchedElements = [];
              try {
                for (const node of querySelectorAll(root, selectorText)) {
                  if (node.type === "element") {
                    matchedElements.push(node);
                  }
                }
              } catch (selectError) {
                continue;
              }
              if (matchedElements.length === 0) {
                continue;
              }
              if (onlyMatchedOnce && matchedElements.length > 1) {
                continue;
              }
              for (const selectedEl of matchedElements) {
                const styleDeclarationList = csstree.parse(
                  selectedEl.attributes.style == null ? "" : selectedEl.attributes.style,
                  {
                    context: "declarationList",
                    parseValue: false
                  }
                );
                if (styleDeclarationList.type !== "DeclarationList") {
                  continue;
                }
                const styleDeclarationItems = /* @__PURE__ */ new Map();
                csstree.walk(styleDeclarationList, {
                  visit: "Declaration",
                  enter(node, item) {
                    styleDeclarationItems.set(node.property, item);
                  }
                });
                csstree.walk(selector.rule, {
                  visit: "Declaration",
                  enter(ruleDeclaration) {
                    const matchedItem = styleDeclarationItems.get(
                      ruleDeclaration.property
                    );
                    const ruleDeclarationItem = styleDeclarationList.children.createItem(ruleDeclaration);
                    if (matchedItem == null) {
                      styleDeclarationList.children.append(ruleDeclarationItem);
                    } else if (matchedItem.data.important !== true && ruleDeclaration.important === true) {
                      styleDeclarationList.children.replace(
                        matchedItem,
                        ruleDeclarationItem
                      );
                      styleDeclarationItems.set(
                        ruleDeclaration.property,
                        ruleDeclarationItem
                      );
                    }
                  }
                });
                selectedEl.attributes.style = csstree.generate(styleDeclarationList);
              }
              if (removeMatchedSelectors && matchedElements.length !== 0 && selector.rule.prelude.type === "SelectorList") {
                selector.rule.prelude.children.remove(selector.item);
              }
              selector.matchedElements = matchedElements;
            }
            if (removeMatchedSelectors === false) {
              return;
            }
            for (const selector of sortedSelectors) {
              if (selector.matchedElements == null) {
                continue;
              }
              if (onlyMatchedOnce && selector.matchedElements.length > 1) {
                continue;
              }
              for (const selectedEl of selector.matchedElements) {
                const classList = new Set(
                  selectedEl.attributes.class == null ? null : selectedEl.attributes.class.split(" ")
                );
                const firstSubSelector = selector.node.children.first();
                if (firstSubSelector != null && firstSubSelector.type === "ClassSelector") {
                  classList.delete(firstSubSelector.name);
                }
                if (classList.size === 0) {
                  delete selectedEl.attributes.class;
                } else {
                  selectedEl.attributes.class = Array.from(classList).join(" ");
                }
                if (firstSubSelector != null && firstSubSelector.type === "IdSelector") {
                  if (selectedEl.attributes.id === firstSubSelector.name) {
                    delete selectedEl.attributes.id;
                  }
                }
              }
            }
            for (const style of styles) {
              csstree.walk(style.cssAst, {
                visit: "Rule",
                enter: function(node, item, list) {
                  if (node.type === "Rule" && node.prelude.type === "SelectorList" && node.prelude.children.isEmpty()) {
                    list.remove(item);
                  }
                }
              });
              if (style.cssAst.children.isEmpty()) {
                detachNodeFromParent(style.node, style.parentNode);
              } else {
                const firstChild = style.node.children[0];
                if (firstChild.type === "text" || firstChild.type === "cdata") {
                  firstChild.value = csstree.generate(style.cssAst);
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/csso/lib/usage.js
var require_usage = __commonJS({
  "node_modules/csso/lib/usage.js"(exports2, module2) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function buildMap(list, caseInsensitive) {
      var map = /* @__PURE__ */ Object.create(null);
      if (!Array.isArray(list)) {
        return null;
      }
      for (var i = 0; i < list.length; i++) {
        var name = list[i];
        if (caseInsensitive) {
          name = name.toLowerCase();
        }
        map[name] = true;
      }
      return map;
    }
    function buildList(data) {
      if (!data) {
        return null;
      }
      var tags = buildMap(data.tags, true);
      var ids = buildMap(data.ids);
      var classes = buildMap(data.classes);
      if (tags === null && ids === null && classes === null) {
        return null;
      }
      return {
        tags,
        ids,
        classes
      };
    }
    function buildIndex(data) {
      var scopes = false;
      if (data.scopes && Array.isArray(data.scopes)) {
        scopes = /* @__PURE__ */ Object.create(null);
        for (var i = 0; i < data.scopes.length; i++) {
          var list = data.scopes[i];
          if (!list || !Array.isArray(list)) {
            throw new Error("Wrong usage format");
          }
          for (var j = 0; j < list.length; j++) {
            var name = list[j];
            if (hasOwnProperty2.call(scopes, name)) {
              throw new Error("Class can't be used for several scopes: " + name);
            }
            scopes[name] = i + 1;
          }
        }
      }
      return {
        whitelist: buildList(data),
        blacklist: buildList(data.blacklist),
        scopes
      };
    }
    module2.exports = {
      buildIndex
    };
  }
});

// node_modules/csso/lib/clean/utils.js
var require_utils2 = __commonJS({
  "node_modules/csso/lib/clean/utils.js"(exports2, module2) {
    module2.exports = {
      hasNoChildren: function(node) {
        return !node || !node.children || node.children.isEmpty();
      },
      isNodeChildrenList: function(node, list) {
        return node !== null && node.children === list;
      }
    };
  }
});

// node_modules/csso/lib/clean/Atrule.js
var require_Atrule2 = __commonJS({
  "node_modules/csso/lib/clean/Atrule.js"(exports2, module2) {
    var resolveKeyword = require_lib10().keyword;
    var { hasNoChildren } = require_utils2();
    module2.exports = function cleanAtrule(node, item, list) {
      if (node.block) {
        if (this.stylesheet !== null) {
          this.stylesheet.firstAtrulesAllowed = false;
        }
        if (hasNoChildren(node.block)) {
          list.remove(item);
          return;
        }
      }
      switch (node.name) {
        case "charset":
          if (hasNoChildren(node.prelude)) {
            list.remove(item);
            return;
          }
          if (item.prev) {
            list.remove(item);
            return;
          }
          break;
        case "import":
          if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
            list.remove(item);
            return;
          }
          list.prevUntil(item.prev, function(rule) {
            if (rule.type === "Atrule") {
              if (rule.name === "import" || rule.name === "charset") {
                return;
              }
            }
            this.root.firstAtrulesAllowed = false;
            list.remove(item);
            return true;
          }, this);
          break;
        default:
          var name = resolveKeyword(node.name).basename;
          if (name === "keyframes" || name === "media" || name === "supports") {
            if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
              list.remove(item);
            }
          }
      }
    };
  }
});

// node_modules/csso/lib/clean/Comment.js
var require_Comment2 = __commonJS({
  "node_modules/csso/lib/clean/Comment.js"(exports2, module2) {
    module2.exports = function cleanComment(data, item, list) {
      list.remove(item);
    };
  }
});

// node_modules/csso/lib/clean/Declaration.js
var require_Declaration2 = __commonJS({
  "node_modules/csso/lib/clean/Declaration.js"(exports2, module2) {
    var property = require_lib10().property;
    module2.exports = function cleanDeclartion(node, item, list) {
      if (node.value.children && node.value.children.isEmpty()) {
        list.remove(item);
        return;
      }
      if (property(node.property).custom) {
        if (/\S/.test(node.value.value)) {
          node.value.value = node.value.value.trim();
        }
      }
    };
  }
});

// node_modules/csso/lib/clean/Raw.js
var require_Raw2 = __commonJS({
  "node_modules/csso/lib/clean/Raw.js"(exports2, module2) {
    var { isNodeChildrenList } = require_utils2();
    module2.exports = function cleanRaw(node, item, list) {
      if (isNodeChildrenList(this.stylesheet, list) || isNodeChildrenList(this.block, list)) {
        list.remove(item);
      }
    };
  }
});

// node_modules/csso/lib/clean/Rule.js
var require_Rule2 = __commonJS({
  "node_modules/csso/lib/clean/Rule.js"(exports2, module2) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var walk = require_lib10().walk;
    var { hasNoChildren } = require_utils2();
    function cleanUnused(selectorList, usageData) {
      selectorList.children.each(function(selector, item, list) {
        var shouldRemove = false;
        walk(selector, function(node) {
          if (this.selector === null || this.selector === selectorList) {
            switch (node.type) {
              case "SelectorList":
                if (this.function === null || this.function.name.toLowerCase() !== "not") {
                  if (cleanUnused(node, usageData)) {
                    shouldRemove = true;
                  }
                }
                break;
              case "ClassSelector":
                if (usageData.whitelist !== null && usageData.whitelist.classes !== null && !hasOwnProperty2.call(usageData.whitelist.classes, node.name)) {
                  shouldRemove = true;
                }
                if (usageData.blacklist !== null && usageData.blacklist.classes !== null && hasOwnProperty2.call(usageData.blacklist.classes, node.name)) {
                  shouldRemove = true;
                }
                break;
              case "IdSelector":
                if (usageData.whitelist !== null && usageData.whitelist.ids !== null && !hasOwnProperty2.call(usageData.whitelist.ids, node.name)) {
                  shouldRemove = true;
                }
                if (usageData.blacklist !== null && usageData.blacklist.ids !== null && hasOwnProperty2.call(usageData.blacklist.ids, node.name)) {
                  shouldRemove = true;
                }
                break;
              case "TypeSelector":
                if (node.name.charAt(node.name.length - 1) !== "*") {
                  if (usageData.whitelist !== null && usageData.whitelist.tags !== null && !hasOwnProperty2.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                    shouldRemove = true;
                  }
                  if (usageData.blacklist !== null && usageData.blacklist.tags !== null && hasOwnProperty2.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                    shouldRemove = true;
                  }
                }
                break;
            }
          }
        });
        if (shouldRemove) {
          list.remove(item);
        }
      });
      return selectorList.children.isEmpty();
    }
    module2.exports = function cleanRule(node, item, list, options) {
      if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
        list.remove(item);
        return;
      }
      var usageData = options.usage;
      if (usageData && (usageData.whitelist !== null || usageData.blacklist !== null)) {
        cleanUnused(node.prelude, usageData);
        if (hasNoChildren(node.prelude)) {
          list.remove(item);
          return;
        }
      }
    };
  }
});

// node_modules/csso/lib/clean/TypeSelector.js
var require_TypeSelector2 = __commonJS({
  "node_modules/csso/lib/clean/TypeSelector.js"(exports2, module2) {
    module2.exports = function cleanTypeSelector(node, item, list) {
      var name = item.data.name;
      if (name !== "*") {
        return;
      }
      var nextType = item.next && item.next.data.type;
      if (nextType === "IdSelector" || nextType === "ClassSelector" || nextType === "AttributeSelector" || nextType === "PseudoClassSelector" || nextType === "PseudoElementSelector") {
        list.remove(item);
      }
    };
  }
});

// node_modules/csso/lib/clean/WhiteSpace.js
var require_WhiteSpace2 = __commonJS({
  "node_modules/csso/lib/clean/WhiteSpace.js"(exports2, module2) {
    var { isNodeChildrenList } = require_utils2();
    function isSafeOperator(node) {
      return node.type === "Operator" && node.value !== "+" && node.value !== "-";
    }
    module2.exports = function cleanWhitespace(node, item, list) {
      if (item.next === null || item.prev === null) {
        list.remove(item);
        return;
      }
      if (isNodeChildrenList(this.stylesheet, list) || isNodeChildrenList(this.block, list)) {
        list.remove(item);
        return;
      }
      if (item.next.data.type === "WhiteSpace") {
        list.remove(item);
        return;
      }
      if (isSafeOperator(item.prev.data) || isSafeOperator(item.next.data)) {
        list.remove(item);
        return;
      }
    };
  }
});

// node_modules/csso/lib/clean/index.js
var require_clean = __commonJS({
  "node_modules/csso/lib/clean/index.js"(exports2, module2) {
    var walk = require_lib10().walk;
    var handlers = {
      Atrule: require_Atrule2(),
      Comment: require_Comment2(),
      Declaration: require_Declaration2(),
      Raw: require_Raw2(),
      Rule: require_Rule2(),
      TypeSelector: require_TypeSelector2(),
      WhiteSpace: require_WhiteSpace2()
    };
    module2.exports = function(ast, options) {
      walk(ast, {
        leave: function(node, item, list) {
          if (handlers.hasOwnProperty(node.type)) {
            handlers[node.type].call(this, node, item, list, options);
          }
        }
      });
    };
  }
});

// node_modules/csso/lib/replace/atrule/keyframes.js
var require_keyframes = __commonJS({
  "node_modules/csso/lib/replace/atrule/keyframes.js"(exports2, module2) {
    module2.exports = function(node) {
      node.block.children.each(function(rule) {
        rule.prelude.children.each(function(simpleselector) {
          simpleselector.children.each(function(data, item) {
            if (data.type === "Percentage" && data.value === "100") {
              item.data = {
                type: "TypeSelector",
                loc: data.loc,
                name: "to"
              };
            } else if (data.type === "TypeSelector" && data.name === "from") {
              item.data = {
                type: "Percentage",
                loc: data.loc,
                value: "0"
              };
            }
          });
        });
      });
    };
  }
});

// node_modules/csso/lib/replace/Atrule.js
var require_Atrule3 = __commonJS({
  "node_modules/csso/lib/replace/Atrule.js"(exports2, module2) {
    var resolveKeyword = require_lib10().keyword;
    var compressKeyframes = require_keyframes();
    module2.exports = function(node) {
      if (resolveKeyword(node.name).basename === "keyframes") {
        compressKeyframes(node);
      }
    };
  }
});

// node_modules/csso/lib/replace/AttributeSelector.js
var require_AttributeSelector2 = __commonJS({
  "node_modules/csso/lib/replace/AttributeSelector.js"(exports2, module2) {
    var escapesRx = /\\([0-9A-Fa-f]{1,6})(\r\n|[ \t\n\f\r])?|\\./g;
    var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;
    function canUnquote(value) {
      if (value === "" || value === "-") {
        return;
      }
      value = value.replace(escapesRx, "a");
      return !blockUnquoteRx.test(value);
    }
    module2.exports = function(node) {
      var attrValue = node.value;
      if (!attrValue || attrValue.type !== "String") {
        return;
      }
      var unquotedValue = attrValue.value.replace(/^(.)(.*)\1$/, "$2");
      if (canUnquote(unquotedValue)) {
        node.value = {
          type: "Identifier",
          loc: attrValue.loc,
          name: unquotedValue
        };
      }
    };
  }
});

// node_modules/csso/lib/replace/property/font.js
var require_font = __commonJS({
  "node_modules/csso/lib/replace/property/font.js"(exports2, module2) {
    module2.exports = function compressFont(node) {
      var list = node.children;
      list.eachRight(function(node2, item) {
        if (node2.type === "Identifier") {
          if (node2.name === "bold") {
            item.data = {
              type: "Number",
              loc: node2.loc,
              value: "700"
            };
          } else if (node2.name === "normal") {
            var prev = item.prev;
            if (prev && prev.data.type === "Operator" && prev.data.value === "/") {
              this.remove(prev);
            }
            this.remove(item);
          } else if (node2.name === "medium") {
            var next = item.next;
            if (!next || next.data.type !== "Operator") {
              this.remove(item);
            }
          }
        }
      });
      list.each(function(node2, item) {
        if (node2.type === "WhiteSpace") {
          if (!item.prev || !item.next || item.next.data.type === "WhiteSpace") {
            this.remove(item);
          }
        }
      });
      if (list.isEmpty()) {
        list.insert(list.createItem({
          type: "Identifier",
          name: "normal"
        }));
      }
    };
  }
});

// node_modules/csso/lib/replace/property/font-weight.js
var require_font_weight = __commonJS({
  "node_modules/csso/lib/replace/property/font-weight.js"(exports2, module2) {
    module2.exports = function compressFontWeight(node) {
      var value = node.children.head.data;
      if (value.type === "Identifier") {
        switch (value.name) {
          case "normal":
            node.children.head.data = {
              type: "Number",
              loc: value.loc,
              value: "400"
            };
            break;
          case "bold":
            node.children.head.data = {
              type: "Number",
              loc: value.loc,
              value: "700"
            };
            break;
        }
      }
    };
  }
});

// node_modules/csso/lib/replace/property/background.js
var require_background = __commonJS({
  "node_modules/csso/lib/replace/property/background.js"(exports2, module2) {
    var List = require_lib10().List;
    module2.exports = function compressBackground(node) {
      function lastType() {
        if (buffer.length) {
          return buffer[buffer.length - 1].type;
        }
      }
      function flush() {
        if (lastType() === "WhiteSpace") {
          buffer.pop();
        }
        if (!buffer.length) {
          buffer.unshift(
            {
              type: "Number",
              loc: null,
              value: "0"
            },
            {
              type: "WhiteSpace",
              value: " "
            },
            {
              type: "Number",
              loc: null,
              value: "0"
            }
          );
        }
        newValue.push.apply(newValue, buffer);
        buffer = [];
      }
      var newValue = [];
      var buffer = [];
      node.children.each(function(node2) {
        if (node2.type === "Operator" && node2.value === ",") {
          flush();
          newValue.push(node2);
          return;
        }
        if (node2.type === "Identifier") {
          if (node2.name === "transparent" || node2.name === "none" || node2.name === "repeat" || node2.name === "scroll") {
            return;
          }
        }
        if (node2.type === "WhiteSpace" && (!buffer.length || lastType() === "WhiteSpace")) {
          return;
        }
        buffer.push(node2);
      });
      flush();
      node.children = new List().fromArray(newValue);
    };
  }
});

// node_modules/csso/lib/replace/property/border.js
var require_border = __commonJS({
  "node_modules/csso/lib/replace/property/border.js"(exports2, module2) {
    function removeItemAndRedundantWhiteSpace(list, item) {
      var prev = item.prev;
      var next = item.next;
      if (next !== null) {
        if (next.data.type === "WhiteSpace" && (prev === null || prev.data.type === "WhiteSpace")) {
          list.remove(next);
        }
      } else if (prev !== null && prev.data.type === "WhiteSpace") {
        list.remove(prev);
      }
      list.remove(item);
    }
    module2.exports = function compressBorder(node) {
      node.children.each(function(node2, item, list) {
        if (node2.type === "Identifier" && node2.name.toLowerCase() === "none") {
          if (list.head === list.tail) {
            item.data = {
              type: "Number",
              loc: node2.loc,
              value: "0"
            };
          } else {
            removeItemAndRedundantWhiteSpace(list, item);
          }
        }
      });
    };
  }
});

// node_modules/csso/lib/replace/Value.js
var require_Value2 = __commonJS({
  "node_modules/csso/lib/replace/Value.js"(exports2, module2) {
    var resolveName = require_lib10().property;
    var handlers = {
      "font": require_font(),
      "font-weight": require_font_weight(),
      "background": require_background(),
      "border": require_border(),
      "outline": require_border()
    };
    module2.exports = function compressValue(node) {
      if (!this.declaration) {
        return;
      }
      var property = resolveName(this.declaration.property);
      if (handlers.hasOwnProperty(property.basename)) {
        handlers[property.basename](node);
      }
    };
  }
});

// node_modules/csso/lib/replace/Number.js
var require_Number2 = __commonJS({
  "node_modules/csso/lib/replace/Number.js"(exports2, module2) {
    var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
    var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
    var unsafeToRemovePlusSignAfter = {
      Dimension: true,
      Hash: true,
      Identifier: true,
      Number: true,
      Raw: true,
      UnicodeRange: true
    };
    function packNumber(value, item) {
      var regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.hasOwnProperty(item.prev.data.type) ? KEEP_PLUSSIGN : OMIT_PLUSSIGN;
      value = String(value).replace(regexp, "$1$2$3");
      if (value === "" || value === "-") {
        value = "0";
      }
      return value;
    }
    module2.exports = function(node, item) {
      node.value = packNumber(node.value, item);
    };
    module2.exports.pack = packNumber;
  }
});

// node_modules/csso/lib/replace/Dimension.js
var require_Dimension2 = __commonJS({
  "node_modules/csso/lib/replace/Dimension.js"(exports2, module2) {
    var packNumber = require_Number2().pack;
    var MATH_FUNCTIONS = {
      "calc": true,
      "min": true,
      "max": true,
      "clamp": true
    };
    var LENGTH_UNIT = {
      // absolute length units
      "px": true,
      "mm": true,
      "cm": true,
      "in": true,
      "pt": true,
      "pc": true,
      // relative length units
      "em": true,
      "ex": true,
      "ch": true,
      "rem": true,
      // viewport-percentage lengths
      "vh": true,
      "vw": true,
      "vmin": true,
      "vmax": true,
      "vm": true
    };
    module2.exports = function compressDimension(node, item) {
      var value = packNumber(node.value, item);
      node.value = value;
      if (value === "0" && this.declaration !== null && this.atrulePrelude === null) {
        var unit = node.unit.toLowerCase();
        if (!LENGTH_UNIT.hasOwnProperty(unit)) {
          return;
        }
        if (this.declaration.property === "-ms-flex" || this.declaration.property === "flex") {
          return;
        }
        if (this.function && MATH_FUNCTIONS.hasOwnProperty(this.function.name)) {
          return;
        }
        item.data = {
          type: "Number",
          loc: node.loc,
          value
        };
      }
    };
  }
});

// node_modules/csso/lib/replace/Percentage.js
var require_Percentage2 = __commonJS({
  "node_modules/csso/lib/replace/Percentage.js"(exports2, module2) {
    var lexer = require_lib10().lexer;
    var packNumber = require_Number2().pack;
    var blacklist = /* @__PURE__ */ new Set([
      // see https://github.com/jakubpawlowicz/clean-css/issues/957
      "width",
      "min-width",
      "max-width",
      "height",
      "min-height",
      "max-height",
      // issue #410: Don’t remove units in flex-basis value for (-ms-)flex shorthand
      // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
      // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
      "flex",
      "-ms-flex"
    ]);
    module2.exports = function compressPercentage(node, item) {
      node.value = packNumber(node.value, item);
      if (node.value === "0" && this.declaration && !blacklist.has(this.declaration.property)) {
        item.data = {
          type: "Number",
          loc: node.loc,
          value: node.value
        };
        if (!lexer.matchDeclaration(this.declaration).isType(item.data, "length")) {
          item.data = node;
        }
      }
    };
  }
});

// node_modules/csso/lib/replace/String.js
var require_String2 = __commonJS({
  "node_modules/csso/lib/replace/String.js"(exports2, module2) {
    module2.exports = function(node) {
      var value = node.value;
      value = value.replace(/\\(\r\n|\r|\n|\f)/g, "");
      node.value = value;
    };
  }
});

// node_modules/csso/lib/replace/Url.js
var require_Url2 = __commonJS({
  "node_modules/csso/lib/replace/Url.js"(exports2, module2) {
    var UNICODE = "\\\\[0-9a-f]{1,6}(\\r\\n|[ \\n\\r\\t\\f])?";
    var ESCAPE = "(" + UNICODE + "|\\\\[^\\n\\r\\f0-9a-fA-F])";
    var NONPRINTABLE = "\0\b\v-\x7F";
    var SAFE_URL = new RegExp("^(" + ESCAPE + `|[^"'\\(\\)\\\\\\s` + NONPRINTABLE + "])*$", "i");
    module2.exports = function(node) {
      var value = node.value;
      if (value.type !== "String") {
        return;
      }
      var quote = value.value[0];
      var url = value.value.substr(1, value.value.length - 2);
      url = url.replace(/\\\\/g, "/");
      if (SAFE_URL.test(url)) {
        node.value = {
          type: "Raw",
          loc: node.value.loc,
          value: url
        };
      } else {
        node.value.value = url.indexOf('"') === -1 ? '"' + url + '"' : quote + url + quote;
      }
    };
  }
});

// node_modules/csso/lib/replace/color.js
var require_color = __commonJS({
  "node_modules/csso/lib/replace/color.js"(exports2, module2) {
    var lexer = require_lib10().lexer;
    var packNumber = require_Number2().pack;
    var NAME_TO_HEX = {
      "aliceblue": "f0f8ff",
      "antiquewhite": "faebd7",
      "aqua": "0ff",
      "aquamarine": "7fffd4",
      "azure": "f0ffff",
      "beige": "f5f5dc",
      "bisque": "ffe4c4",
      "black": "000",
      "blanchedalmond": "ffebcd",
      "blue": "00f",
      "blueviolet": "8a2be2",
      "brown": "a52a2a",
      "burlywood": "deb887",
      "cadetblue": "5f9ea0",
      "chartreuse": "7fff00",
      "chocolate": "d2691e",
      "coral": "ff7f50",
      "cornflowerblue": "6495ed",
      "cornsilk": "fff8dc",
      "crimson": "dc143c",
      "cyan": "0ff",
      "darkblue": "00008b",
      "darkcyan": "008b8b",
      "darkgoldenrod": "b8860b",
      "darkgray": "a9a9a9",
      "darkgrey": "a9a9a9",
      "darkgreen": "006400",
      "darkkhaki": "bdb76b",
      "darkmagenta": "8b008b",
      "darkolivegreen": "556b2f",
      "darkorange": "ff8c00",
      "darkorchid": "9932cc",
      "darkred": "8b0000",
      "darksalmon": "e9967a",
      "darkseagreen": "8fbc8f",
      "darkslateblue": "483d8b",
      "darkslategray": "2f4f4f",
      "darkslategrey": "2f4f4f",
      "darkturquoise": "00ced1",
      "darkviolet": "9400d3",
      "deeppink": "ff1493",
      "deepskyblue": "00bfff",
      "dimgray": "696969",
      "dimgrey": "696969",
      "dodgerblue": "1e90ff",
      "firebrick": "b22222",
      "floralwhite": "fffaf0",
      "forestgreen": "228b22",
      "fuchsia": "f0f",
      "gainsboro": "dcdcdc",
      "ghostwhite": "f8f8ff",
      "gold": "ffd700",
      "goldenrod": "daa520",
      "gray": "808080",
      "grey": "808080",
      "green": "008000",
      "greenyellow": "adff2f",
      "honeydew": "f0fff0",
      "hotpink": "ff69b4",
      "indianred": "cd5c5c",
      "indigo": "4b0082",
      "ivory": "fffff0",
      "khaki": "f0e68c",
      "lavender": "e6e6fa",
      "lavenderblush": "fff0f5",
      "lawngreen": "7cfc00",
      "lemonchiffon": "fffacd",
      "lightblue": "add8e6",
      "lightcoral": "f08080",
      "lightcyan": "e0ffff",
      "lightgoldenrodyellow": "fafad2",
      "lightgray": "d3d3d3",
      "lightgrey": "d3d3d3",
      "lightgreen": "90ee90",
      "lightpink": "ffb6c1",
      "lightsalmon": "ffa07a",
      "lightseagreen": "20b2aa",
      "lightskyblue": "87cefa",
      "lightslategray": "789",
      "lightslategrey": "789",
      "lightsteelblue": "b0c4de",
      "lightyellow": "ffffe0",
      "lime": "0f0",
      "limegreen": "32cd32",
      "linen": "faf0e6",
      "magenta": "f0f",
      "maroon": "800000",
      "mediumaquamarine": "66cdaa",
      "mediumblue": "0000cd",
      "mediumorchid": "ba55d3",
      "mediumpurple": "9370db",
      "mediumseagreen": "3cb371",
      "mediumslateblue": "7b68ee",
      "mediumspringgreen": "00fa9a",
      "mediumturquoise": "48d1cc",
      "mediumvioletred": "c71585",
      "midnightblue": "191970",
      "mintcream": "f5fffa",
      "mistyrose": "ffe4e1",
      "moccasin": "ffe4b5",
      "navajowhite": "ffdead",
      "navy": "000080",
      "oldlace": "fdf5e6",
      "olive": "808000",
      "olivedrab": "6b8e23",
      "orange": "ffa500",
      "orangered": "ff4500",
      "orchid": "da70d6",
      "palegoldenrod": "eee8aa",
      "palegreen": "98fb98",
      "paleturquoise": "afeeee",
      "palevioletred": "db7093",
      "papayawhip": "ffefd5",
      "peachpuff": "ffdab9",
      "peru": "cd853f",
      "pink": "ffc0cb",
      "plum": "dda0dd",
      "powderblue": "b0e0e6",
      "purple": "800080",
      "rebeccapurple": "639",
      "red": "f00",
      "rosybrown": "bc8f8f",
      "royalblue": "4169e1",
      "saddlebrown": "8b4513",
      "salmon": "fa8072",
      "sandybrown": "f4a460",
      "seagreen": "2e8b57",
      "seashell": "fff5ee",
      "sienna": "a0522d",
      "silver": "c0c0c0",
      "skyblue": "87ceeb",
      "slateblue": "6a5acd",
      "slategray": "708090",
      "slategrey": "708090",
      "snow": "fffafa",
      "springgreen": "00ff7f",
      "steelblue": "4682b4",
      "tan": "d2b48c",
      "teal": "008080",
      "thistle": "d8bfd8",
      "tomato": "ff6347",
      "turquoise": "40e0d0",
      "violet": "ee82ee",
      "wheat": "f5deb3",
      "white": "fff",
      "whitesmoke": "f5f5f5",
      "yellow": "ff0",
      "yellowgreen": "9acd32"
    };
    var HEX_TO_NAME = {
      "800000": "maroon",
      "800080": "purple",
      "808000": "olive",
      "808080": "gray",
      "00ffff": "cyan",
      "f0ffff": "azure",
      "f5f5dc": "beige",
      "ffe4c4": "bisque",
      "000000": "black",
      "0000ff": "blue",
      "a52a2a": "brown",
      "ff7f50": "coral",
      "ffd700": "gold",
      "008000": "green",
      "4b0082": "indigo",
      "fffff0": "ivory",
      "f0e68c": "khaki",
      "00ff00": "lime",
      "faf0e6": "linen",
      "000080": "navy",
      "ffa500": "orange",
      "da70d6": "orchid",
      "cd853f": "peru",
      "ffc0cb": "pink",
      "dda0dd": "plum",
      "f00": "red",
      "ff0000": "red",
      "fa8072": "salmon",
      "a0522d": "sienna",
      "c0c0c0": "silver",
      "fffafa": "snow",
      "d2b48c": "tan",
      "008080": "teal",
      "ff6347": "tomato",
      "ee82ee": "violet",
      "f5deb3": "wheat",
      "ffffff": "white",
      "ffff00": "yellow"
    };
    function hueToRgb(p, q, t) {
      if (t < 0) {
        t += 1;
      }
      if (t > 1) {
        t -= 1;
      }
      if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
      }
      if (t < 1 / 2) {
        return q;
      }
      if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
      }
      return p;
    }
    function hslToRgb(h, s, l, a) {
      var r;
      var g;
      var b;
      if (s === 0) {
        r = g = b = l;
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
      }
      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        a
      ];
    }
    function toHex(value) {
      value = value.toString(16);
      return value.length === 1 ? "0" + value : value;
    }
    function parseFunctionArgs(functionArgs, count, rgb) {
      var cursor = functionArgs.head;
      var args = [];
      var wasValue = false;
      while (cursor !== null) {
        var node = cursor.data;
        var type = node.type;
        switch (type) {
          case "Number":
          case "Percentage":
            if (wasValue) {
              return;
            }
            wasValue = true;
            args.push({
              type,
              value: Number(node.value)
            });
            break;
          case "Operator":
            if (node.value === ",") {
              if (!wasValue) {
                return;
              }
              wasValue = false;
            } else if (wasValue || node.value !== "+") {
              return;
            }
            break;
          default:
            return;
        }
        cursor = cursor.next;
      }
      if (args.length !== count) {
        return;
      }
      if (args.length === 4) {
        if (args[3].type !== "Number") {
          return;
        }
        args[3].type = "Alpha";
      }
      if (rgb) {
        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
          return;
        }
      } else {
        if (args[0].type !== "Number" || args[1].type !== "Percentage" || args[2].type !== "Percentage") {
          return;
        }
        args[0].type = "Angle";
      }
      return args.map(function(arg) {
        var value = Math.max(0, arg.value);
        switch (arg.type) {
          case "Number":
            value = Math.min(value, 255);
            break;
          case "Percentage":
            value = Math.min(value, 100) / 100;
            if (!rgb) {
              return value;
            }
            value = 255 * value;
            break;
          case "Angle":
            return (value % 360 + 360) % 360 / 360;
          case "Alpha":
            return Math.min(value, 1);
        }
        return Math.round(value);
      });
    }
    function compressFunction(node, item, list) {
      var functionName = node.name;
      var args;
      if (functionName === "rgba" || functionName === "hsla") {
        args = parseFunctionArgs(node.children, 4, functionName === "rgba");
        if (!args) {
          return;
        }
        if (functionName === "hsla") {
          args = hslToRgb.apply(null, args);
          node.name = "rgba";
        }
        if (args[3] === 0) {
          var scopeFunctionName = this.function && this.function.name;
          if (args[0] === 0 && args[1] === 0 && args[2] === 0 || !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {
            item.data = {
              type: "Identifier",
              loc: node.loc,
              name: "transparent"
            };
            return;
          }
        }
        if (args[3] !== 1) {
          node.children.each(function(node2, item2, list2) {
            if (node2.type === "Operator") {
              if (node2.value !== ",") {
                list2.remove(item2);
              }
              return;
            }
            item2.data = {
              type: "Number",
              loc: node2.loc,
              value: packNumber(args.shift(), null)
            };
          });
          return;
        }
        functionName = "rgb";
      }
      if (functionName === "hsl") {
        args = args || parseFunctionArgs(node.children, 3, false);
        if (!args) {
          return;
        }
        args = hslToRgb.apply(null, args);
        functionName = "rgb";
      }
      if (functionName === "rgb") {
        args = args || parseFunctionArgs(node.children, 3, true);
        if (!args) {
          return;
        }
        var next = item.next;
        if (next && next.data.type !== "WhiteSpace") {
          list.insert(list.createItem({
            type: "WhiteSpace",
            value: " "
          }), next);
        }
        item.data = {
          type: "Hash",
          loc: node.loc,
          value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
        };
        compressHex(item.data, item);
      }
    }
    function compressIdent(node, item) {
      if (this.declaration === null) {
        return;
      }
      var color = node.name.toLowerCase();
      if (NAME_TO_HEX.hasOwnProperty(color) && lexer.matchDeclaration(this.declaration).isType(node, "color")) {
        var hex = NAME_TO_HEX[color];
        if (hex.length + 1 <= color.length) {
          item.data = {
            type: "Hash",
            loc: node.loc,
            value: hex
          };
        } else {
          if (color === "grey") {
            color = "gray";
          }
          node.name = color;
        }
      }
    }
    function compressHex(node, item) {
      var color = node.value.toLowerCase();
      if (color.length === 6 && color[0] === color[1] && color[2] === color[3] && color[4] === color[5]) {
        color = color[0] + color[2] + color[4];
      }
      if (HEX_TO_NAME[color]) {
        item.data = {
          type: "Identifier",
          loc: node.loc,
          name: HEX_TO_NAME[color]
        };
      } else {
        node.value = color;
      }
    }
    module2.exports = {
      compressFunction,
      compressIdent,
      compressHex
    };
  }
});

// node_modules/csso/lib/replace/index.js
var require_replace = __commonJS({
  "node_modules/csso/lib/replace/index.js"(exports2, module2) {
    var walk = require_lib10().walk;
    var handlers = {
      Atrule: require_Atrule3(),
      AttributeSelector: require_AttributeSelector2(),
      Value: require_Value2(),
      Dimension: require_Dimension2(),
      Percentage: require_Percentage2(),
      Number: require_Number2(),
      String: require_String2(),
      Url: require_Url2(),
      Hash: require_color().compressHex,
      Identifier: require_color().compressIdent,
      Function: require_color().compressFunction
    };
    module2.exports = function(ast) {
      walk(ast, {
        leave: function(node, item, list) {
          if (handlers.hasOwnProperty(node.type)) {
            handlers[node.type].call(this, node, item, list);
          }
        }
      });
    };
  }
});

// node_modules/csso/lib/restructure/prepare/createDeclarationIndexer.js
var require_createDeclarationIndexer = __commonJS({
  "node_modules/csso/lib/restructure/prepare/createDeclarationIndexer.js"(exports2, module2) {
    var generate = require_lib10().generate;
    function Index() {
      this.seed = 0;
      this.map = /* @__PURE__ */ Object.create(null);
    }
    Index.prototype.resolve = function(str) {
      var index = this.map[str];
      if (!index) {
        index = ++this.seed;
        this.map[str] = index;
      }
      return index;
    };
    module2.exports = function createDeclarationIndexer() {
      var ids = new Index();
      return function markDeclaration(node) {
        var id = generate(node);
        node.id = ids.resolve(id);
        node.length = id.length;
        node.fingerprint = null;
        return node;
      };
    };
  }
});

// node_modules/csso/lib/restructure/prepare/processSelector.js
var require_processSelector = __commonJS({
  "node_modules/csso/lib/restructure/prepare/processSelector.js"(exports2, module2) {
    var generate = require_lib10().generate;
    var specificity = require_specificity();
    var nonFreezePseudoElements = {
      "first-letter": true,
      "first-line": true,
      "after": true,
      "before": true
    };
    var nonFreezePseudoClasses = {
      "link": true,
      "visited": true,
      "hover": true,
      "active": true,
      "first-letter": true,
      "first-line": true,
      "after": true,
      "before": true
    };
    module2.exports = function freeze(node, usageData) {
      var pseudos = /* @__PURE__ */ Object.create(null);
      var hasPseudo = false;
      node.prelude.children.each(function(simpleSelector) {
        var tagName = "*";
        var scope = 0;
        simpleSelector.children.each(function(node2) {
          switch (node2.type) {
            case "ClassSelector":
              if (usageData && usageData.scopes) {
                var classScope = usageData.scopes[node2.name] || 0;
                if (scope !== 0 && classScope !== scope) {
                  throw new Error("Selector can't has classes from different scopes: " + generate(simpleSelector));
                }
                scope = classScope;
              }
              break;
            case "PseudoClassSelector":
              var name = node2.name.toLowerCase();
              if (!nonFreezePseudoClasses.hasOwnProperty(name)) {
                pseudos[":" + name] = true;
                hasPseudo = true;
              }
              break;
            case "PseudoElementSelector":
              var name = node2.name.toLowerCase();
              if (!nonFreezePseudoElements.hasOwnProperty(name)) {
                pseudos["::" + name] = true;
                hasPseudo = true;
              }
              break;
            case "TypeSelector":
              tagName = node2.name.toLowerCase();
              break;
            case "AttributeSelector":
              if (node2.flags) {
                pseudos["[" + node2.flags.toLowerCase() + "]"] = true;
                hasPseudo = true;
              }
              break;
            case "WhiteSpace":
            case "Combinator":
              tagName = "*";
              break;
          }
        });
        simpleSelector.compareMarker = specificity(simpleSelector).toString();
        simpleSelector.id = null;
        simpleSelector.id = generate(simpleSelector);
        if (scope) {
          simpleSelector.compareMarker += ":" + scope;
        }
        if (tagName !== "*") {
          simpleSelector.compareMarker += "," + tagName;
        }
      });
      node.pseudoSignature = hasPseudo && Object.keys(pseudos).sort().join(",");
    };
  }
});

// node_modules/csso/lib/restructure/prepare/index.js
var require_prepare = __commonJS({
  "node_modules/csso/lib/restructure/prepare/index.js"(exports2, module2) {
    var resolveKeyword = require_lib10().keyword;
    var walk = require_lib10().walk;
    var generate = require_lib10().generate;
    var createDeclarationIndexer = require_createDeclarationIndexer();
    var processSelector = require_processSelector();
    module2.exports = function prepare(ast, options) {
      var markDeclaration = createDeclarationIndexer();
      walk(ast, {
        visit: "Rule",
        enter: function processRule(node) {
          node.block.children.each(markDeclaration);
          processSelector(node, options.usage);
        }
      });
      walk(ast, {
        visit: "Atrule",
        enter: function(node) {
          if (node.prelude) {
            node.prelude.id = null;
            node.prelude.id = generate(node.prelude);
          }
          if (resolveKeyword(node.name).basename === "keyframes") {
            node.block.avoidRulesMerge = true;
            node.block.children.each(function(rule) {
              rule.prelude.children.each(function(simpleselector) {
                simpleselector.compareMarker = simpleselector.id;
              });
            });
          }
        }
      });
      return {
        declaration: markDeclaration
      };
    };
  }
});

// node_modules/csso/lib/restructure/1-mergeAtrule.js
var require_mergeAtrule = __commonJS({
  "node_modules/csso/lib/restructure/1-mergeAtrule.js"(exports2, module2) {
    var List = require_lib10().List;
    var resolveKeyword = require_lib10().keyword;
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    var walk = require_lib10().walk;
    function addRuleToMap(map, item, list, single) {
      var node = item.data;
      var name = resolveKeyword(node.name).basename;
      var id = node.name.toLowerCase() + "/" + (node.prelude ? node.prelude.id : null);
      if (!hasOwnProperty2.call(map, name)) {
        map[name] = /* @__PURE__ */ Object.create(null);
      }
      if (single) {
        delete map[name][id];
      }
      if (!hasOwnProperty2.call(map[name], id)) {
        map[name][id] = new List();
      }
      map[name][id].append(list.remove(item));
    }
    function relocateAtrules(ast, options) {
      var collected = /* @__PURE__ */ Object.create(null);
      var topInjectPoint = null;
      ast.children.each(function(node, item, list) {
        if (node.type === "Atrule") {
          var name = resolveKeyword(node.name).basename;
          switch (name) {
            case "keyframes":
              addRuleToMap(collected, item, list, true);
              return;
            case "media":
              if (options.forceMediaMerge) {
                addRuleToMap(collected, item, list, false);
                return;
              }
              break;
          }
          if (topInjectPoint === null && name !== "charset" && name !== "import") {
            topInjectPoint = item;
          }
        } else {
          if (topInjectPoint === null) {
            topInjectPoint = item;
          }
        }
      });
      for (var atrule in collected) {
        for (var id in collected[atrule]) {
          ast.children.insertList(
            collected[atrule][id],
            atrule === "media" ? null : topInjectPoint
          );
        }
      }
    }
    function isMediaRule(node) {
      return node.type === "Atrule" && node.name === "media";
    }
    function processAtrule(node, item, list) {
      if (!isMediaRule(node)) {
        return;
      }
      var prev = item.prev && item.prev.data;
      if (!prev || !isMediaRule(prev)) {
        return;
      }
      if (node.prelude && prev.prelude && node.prelude.id === prev.prelude.id) {
        prev.block.children.appendList(node.block.children);
        list.remove(item);
      }
    }
    module2.exports = function rejoinAtrule(ast, options) {
      relocateAtrules(ast, options);
      walk(ast, {
        visit: "Atrule",
        reverse: true,
        enter: processAtrule
      });
    };
  }
});

// node_modules/csso/lib/restructure/utils.js
var require_utils3 = __commonJS({
  "node_modules/csso/lib/restructure/utils.js"(exports2, module2) {
    var hasOwnProperty2 = Object.prototype.hasOwnProperty;
    function isEqualSelectors(a, b) {
      var cursor1 = a.head;
      var cursor2 = b.head;
      while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
      }
      return cursor1 === null && cursor2 === null;
    }
    function isEqualDeclarations(a, b) {
      var cursor1 = a.head;
      var cursor2 = b.head;
      while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
      }
      return cursor1 === null && cursor2 === null;
    }
    function compareDeclarations(declarations1, declarations2) {
      var result = {
        eq: [],
        ne1: [],
        ne2: [],
        ne2overrided: []
      };
      var fingerprints = /* @__PURE__ */ Object.create(null);
      var declarations2hash = /* @__PURE__ */ Object.create(null);
      for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
        declarations2hash[cursor.data.id] = true;
      }
      for (var cursor = declarations1.head; cursor; cursor = cursor.next) {
        var data = cursor.data;
        if (data.fingerprint) {
          fingerprints[data.fingerprint] = data.important;
        }
        if (declarations2hash[data.id]) {
          declarations2hash[data.id] = false;
          result.eq.push(data);
        } else {
          result.ne1.push(data);
        }
      }
      for (var cursor = declarations2.head; cursor; cursor = cursor.next) {
        var data = cursor.data;
        if (declarations2hash[data.id]) {
          if (!hasOwnProperty2.call(fingerprints, data.fingerprint) || !fingerprints[data.fingerprint] && data.important) {
            result.ne2.push(data);
          }
          result.ne2overrided.push(data);
        }
      }
      return result;
    }
    function addSelectors(dest, source) {
      source.each(function(sourceData) {
        var newStr = sourceData.id;
        var cursor = dest.head;
        while (cursor) {
          var nextStr = cursor.data.id;
          if (nextStr === newStr) {
            return;
          }
          if (nextStr > newStr) {
            break;
          }
          cursor = cursor.next;
        }
        dest.insert(dest.createItem(sourceData), cursor);
      });
      return dest;
    }
    function hasSimilarSelectors(selectors1, selectors2) {
      var cursor1 = selectors1.head;
      while (cursor1 !== null) {
        var cursor2 = selectors2.head;
        while (cursor2 !== null) {
          if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
            return true;
          }
          cursor2 = cursor2.next;
        }
        cursor1 = cursor1.next;
      }
      return false;
    }
    function unsafeToSkipNode(node) {
      switch (node.type) {
        case "Rule":
          return hasSimilarSelectors(node.prelude.children, this);
        case "Atrule":
          if (node.block) {
            return node.block.children.some(unsafeToSkipNode, this);
          }
          break;
        case "Declaration":
          return false;
      }
      return true;
    }
    module2.exports = {
      isEqualSelectors,
      isEqualDeclarations,
      compareDeclarations,
      addSelectors,
      hasSimilarSelectors,
      unsafeToSkipNode
    };
  }
});

// node_modules/csso/lib/restructure/2-initialMergeRuleset.js
var require_initialMergeRuleset = __commonJS({
  "node_modules/csso/lib/restructure/2-initialMergeRuleset.js"(exports2, module2) {
    var walk = require_lib10().walk;
    var utils = require_utils3();
    function processRule(node, item, list) {
      var selectors = node.prelude.children;
      var declarations = node.block.children;
      list.prevUntil(item.prev, function(prev) {
        if (prev.type !== "Rule") {
          return utils.unsafeToSkipNode.call(selectors, prev);
        }
        var prevSelectors = prev.prelude.children;
        var prevDeclarations = prev.block.children;
        if (node.pseudoSignature === prev.pseudoSignature) {
          if (utils.isEqualSelectors(prevSelectors, selectors)) {
            prevDeclarations.appendList(declarations);
            list.remove(item);
            return true;
          }
          if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
            utils.addSelectors(prevSelectors, selectors);
            list.remove(item);
            return true;
          }
        }
        return utils.hasSimilarSelectors(selectors, prevSelectors);
      });
    }
    module2.exports = function initialMergeRule(ast) {
      walk(ast, {
        visit: "Rule",
        enter: processRule
      });
    };
  }
});

// node_modules/csso/lib/restructure/3-disjoinRuleset.js
var require_disjoinRuleset = __commonJS({
  "node_modules/csso/lib/restructure/3-disjoinRuleset.js"(exports2, module2) {
    var List = require_lib10().List;
    var walk = require_lib10().walk;
    function processRule(node, item, list) {
      var selectors = node.prelude.children;
      while (selectors.head !== selectors.tail) {
        var newSelectors = new List();
        newSelectors.insert(selectors.remove(selectors.head));
        list.insert(list.createItem({
          type: "Rule",
          loc: node.loc,
          prelude: {
            type: "SelectorList",
            loc: node.prelude.loc,
            children: newSelectors
          },
          block: {
            type: "Block",
            loc: node.block.loc,
            children: node.block.children.copy()
          },
          pseudoSignature: node.pseudoSignature
        }), item);
      }
    }
    module2.exports = function disjoinRule(ast) {
      walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: processRule
      });
    };
  }
});

// node_modules/csso/lib/restructure/4-restructShorthand.js
var require_restructShorthand = __commonJS({
  "node_modules/csso/lib/restructure/4-restructShorthand.js"(exports2, module2) {
    var List = require_lib10().List;
    var generate = require_lib10().generate;
    var walk = require_lib10().walk;
    var REPLACE = 1;
    var REMOVE = 2;
    var TOP = 0;
    var RIGHT = 1;
    var BOTTOM = 2;
    var LEFT = 3;
    var SIDES = ["top", "right", "bottom", "left"];
    var SIDE = {
      "margin-top": "top",
      "margin-right": "right",
      "margin-bottom": "bottom",
      "margin-left": "left",
      "padding-top": "top",
      "padding-right": "right",
      "padding-bottom": "bottom",
      "padding-left": "left",
      "border-top-color": "top",
      "border-right-color": "right",
      "border-bottom-color": "bottom",
      "border-left-color": "left",
      "border-top-width": "top",
      "border-right-width": "right",
      "border-bottom-width": "bottom",
      "border-left-width": "left",
      "border-top-style": "top",
      "border-right-style": "right",
      "border-bottom-style": "bottom",
      "border-left-style": "left"
    };
    var MAIN_PROPERTY = {
      "margin": "margin",
      "margin-top": "margin",
      "margin-right": "margin",
      "margin-bottom": "margin",
      "margin-left": "margin",
      "padding": "padding",
      "padding-top": "padding",
      "padding-right": "padding",
      "padding-bottom": "padding",
      "padding-left": "padding",
      "border-color": "border-color",
      "border-top-color": "border-color",
      "border-right-color": "border-color",
      "border-bottom-color": "border-color",
      "border-left-color": "border-color",
      "border-width": "border-width",
      "border-top-width": "border-width",
      "border-right-width": "border-width",
      "border-bottom-width": "border-width",
      "border-left-width": "border-width",
      "border-style": "border-style",
      "border-top-style": "border-style",
      "border-right-style": "border-style",
      "border-bottom-style": "border-style",
      "border-left-style": "border-style"
    };
    function TRBL(name) {
      this.name = name;
      this.loc = null;
      this.iehack = void 0;
      this.sides = {
        "top": null,
        "right": null,
        "bottom": null,
        "left": null
      };
    }
    TRBL.prototype.getValueSequence = function(declaration, count) {
      var values = [];
      var iehack = "";
      var hasBadValues = declaration.value.type !== "Value" || declaration.value.children.some(function(child) {
        var special = false;
        switch (child.type) {
          case "Identifier":
            switch (child.name) {
              case "\\0":
              case "\\9":
                iehack = child.name;
                return;
              case "inherit":
              case "initial":
              case "unset":
              case "revert":
                special = child.name;
                break;
            }
            break;
          case "Dimension":
            switch (child.unit) {
              case "rem":
              case "vw":
              case "vh":
              case "vmin":
              case "vmax":
              case "vm":
                special = child.unit;
                break;
            }
            break;
          case "Hash":
          case "Number":
          case "Percentage":
            break;
          case "Function":
            if (child.name === "var") {
              return true;
            }
            special = child.name;
            break;
          case "WhiteSpace":
            return false;
          default:
            return true;
        }
        values.push({
          node: child,
          special,
          important: declaration.important
        });
      });
      if (hasBadValues || values.length > count) {
        return false;
      }
      if (typeof this.iehack === "string" && this.iehack !== iehack) {
        return false;
      }
      this.iehack = iehack;
      return values;
    };
    TRBL.prototype.canOverride = function(side, value) {
      var currentValue = this.sides[side];
      return !currentValue || value.important && !currentValue.important;
    };
    TRBL.prototype.add = function(name, declaration) {
      function attemptToAdd() {
        var sides = this.sides;
        var side = SIDE[name];
        if (side) {
          if (side in sides === false) {
            return false;
          }
          var values = this.getValueSequence(declaration, 1);
          if (!values || !values.length) {
            return false;
          }
          for (var key in sides) {
            if (sides[key] !== null && sides[key].special !== values[0].special) {
              return false;
            }
          }
          if (!this.canOverride(side, values[0])) {
            return true;
          }
          sides[side] = values[0];
          return true;
        } else if (name === this.name) {
          var values = this.getValueSequence(declaration, 4);
          if (!values || !values.length) {
            return false;
          }
          switch (values.length) {
            case 1:
              values[RIGHT] = values[TOP];
              values[BOTTOM] = values[TOP];
              values[LEFT] = values[TOP];
              break;
            case 2:
              values[BOTTOM] = values[TOP];
              values[LEFT] = values[RIGHT];
              break;
            case 3:
              values[LEFT] = values[RIGHT];
              break;
          }
          for (var i = 0; i < 4; i++) {
            for (var key in sides) {
              if (sides[key] !== null && sides[key].special !== values[i].special) {
                return false;
              }
            }
          }
          for (var i = 0; i < 4; i++) {
            if (this.canOverride(SIDES[i], values[i])) {
              sides[SIDES[i]] = values[i];
            }
          }
          return true;
        }
      }
      if (!attemptToAdd.call(this)) {
        return false;
      }
      if (!this.loc) {
        this.loc = declaration.loc;
      }
      return true;
    };
    TRBL.prototype.isOkToMinimize = function() {
      var top = this.sides.top;
      var right = this.sides.right;
      var bottom = this.sides.bottom;
      var left = this.sides.left;
      if (top && right && bottom && left) {
        var important = top.important + right.important + bottom.important + left.important;
        return important === 0 || important === 4;
      }
      return false;
    };
    TRBL.prototype.getValue = function() {
      var result = new List();
      var sides = this.sides;
      var values = [
        sides.top,
        sides.right,
        sides.bottom,
        sides.left
      ];
      var stringValues = [
        generate(sides.top.node),
        generate(sides.right.node),
        generate(sides.bottom.node),
        generate(sides.left.node)
      ];
      if (stringValues[LEFT] === stringValues[RIGHT]) {
        values.pop();
        if (stringValues[BOTTOM] === stringValues[TOP]) {
          values.pop();
          if (stringValues[RIGHT] === stringValues[TOP]) {
            values.pop();
          }
        }
      }
      for (var i = 0; i < values.length; i++) {
        if (i) {
          result.appendData({ type: "WhiteSpace", value: " " });
        }
        result.appendData(values[i].node);
      }
      if (this.iehack) {
        result.appendData({ type: "WhiteSpace", value: " " });
        result.appendData({
          type: "Identifier",
          loc: null,
          name: this.iehack
        });
      }
      return {
        type: "Value",
        loc: null,
        children: result
      };
    };
    TRBL.prototype.getDeclaration = function() {
      return {
        type: "Declaration",
        loc: this.loc,
        important: this.sides.top.important,
        property: this.name,
        value: this.getValue()
      };
    };
    function processRule(rule, shorts, shortDeclarations, lastShortSelector) {
      var declarations = rule.block.children;
      var selector = rule.prelude.children.first().id;
      rule.block.children.eachRight(function(declaration, item) {
        var property = declaration.property;
        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
          return;
        }
        var key = MAIN_PROPERTY[property];
        var shorthand;
        var operation;
        if (!lastShortSelector || selector === lastShortSelector) {
          if (key in shorts) {
            operation = REMOVE;
            shorthand = shorts[key];
          }
        }
        if (!shorthand || !shorthand.add(property, declaration)) {
          operation = REPLACE;
          shorthand = new TRBL(key);
          if (!shorthand.add(property, declaration)) {
            lastShortSelector = null;
            return;
          }
        }
        shorts[key] = shorthand;
        shortDeclarations.push({
          operation,
          block: declarations,
          item,
          shorthand
        });
        lastShortSelector = selector;
      });
      return lastShortSelector;
    }
    function processShorthands(shortDeclarations, markDeclaration) {
      shortDeclarations.forEach(function(item) {
        var shorthand = item.shorthand;
        if (!shorthand.isOkToMinimize()) {
          return;
        }
        if (item.operation === REPLACE) {
          item.item.data = markDeclaration(shorthand.getDeclaration());
        } else {
          item.block.remove(item.item);
        }
      });
    }
    module2.exports = function restructBlock(ast, indexer) {
      var stylesheetMap = {};
      var shortDeclarations = [];
      walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: function(node) {
          var stylesheet = this.block || this.stylesheet;
          var ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first().id;
          var ruleMap;
          var shorts;
          if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
            ruleMap = {
              lastShortSelector: null
            };
            stylesheetMap[stylesheet.id] = ruleMap;
          } else {
            ruleMap = stylesheetMap[stylesheet.id];
          }
          if (ruleMap.hasOwnProperty(ruleId)) {
            shorts = ruleMap[ruleId];
          } else {
            shorts = {};
            ruleMap[ruleId] = shorts;
          }
          ruleMap.lastShortSelector = processRule.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
        }
      });
      processShorthands(shortDeclarations, indexer.declaration);
    };
  }
});

// node_modules/csso/lib/restructure/6-restructBlock.js
var require_restructBlock = __commonJS({
  "node_modules/csso/lib/restructure/6-restructBlock.js"(exports2, module2) {
    var resolveProperty = require_lib10().property;
    var resolveKeyword = require_lib10().keyword;
    var walk = require_lib10().walk;
    var generate = require_lib10().generate;
    var fingerprintId = 1;
    var dontRestructure = {
      "src": 1
      // https://github.com/afelix/csso/issues/50
    };
    var DONT_MIX_VALUE = {
      // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
      "display": /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
      // https://developer.mozilla.org/en/docs/Web/CSS/text-align
      "text-align": /^(start|end|match-parent|justify-all)$/i
    };
    var SAFE_VALUES = {
      cursor: [
        "auto",
        "crosshair",
        "default",
        "move",
        "text",
        "wait",
        "help",
        "n-resize",
        "e-resize",
        "s-resize",
        "w-resize",
        "ne-resize",
        "nw-resize",
        "se-resize",
        "sw-resize",
        "pointer",
        "progress",
        "not-allowed",
        "no-drop",
        "vertical-text",
        "all-scroll",
        "col-resize",
        "row-resize"
      ],
      overflow: [
        "hidden",
        "visible",
        "scroll",
        "auto"
      ],
      position: [
        "static",
        "relative",
        "absolute",
        "fixed"
      ]
    };
    var NEEDLESS_TABLE = {
      "border-width": ["border"],
      "border-style": ["border"],
      "border-color": ["border"],
      "border-top": ["border"],
      "border-right": ["border"],
      "border-bottom": ["border"],
      "border-left": ["border"],
      "border-top-width": ["border-top", "border-width", "border"],
      "border-right-width": ["border-right", "border-width", "border"],
      "border-bottom-width": ["border-bottom", "border-width", "border"],
      "border-left-width": ["border-left", "border-width", "border"],
      "border-top-style": ["border-top", "border-style", "border"],
      "border-right-style": ["border-right", "border-style", "border"],
      "border-bottom-style": ["border-bottom", "border-style", "border"],
      "border-left-style": ["border-left", "border-style", "border"],
      "border-top-color": ["border-top", "border-color", "border"],
      "border-right-color": ["border-right", "border-color", "border"],
      "border-bottom-color": ["border-bottom", "border-color", "border"],
      "border-left-color": ["border-left", "border-color", "border"],
      "margin-top": ["margin"],
      "margin-right": ["margin"],
      "margin-bottom": ["margin"],
      "margin-left": ["margin"],
      "padding-top": ["padding"],
      "padding-right": ["padding"],
      "padding-bottom": ["padding"],
      "padding-left": ["padding"],
      "font-style": ["font"],
      "font-variant": ["font"],
      "font-weight": ["font"],
      "font-size": ["font"],
      "font-family": ["font"],
      "list-style-type": ["list-style"],
      "list-style-position": ["list-style"],
      "list-style-image": ["list-style"]
    };
    function getPropertyFingerprint(propertyName, declaration, fingerprints) {
      var realName = resolveProperty(propertyName).basename;
      if (realName === "background") {
        return propertyName + ":" + generate(declaration.value);
      }
      var declarationId = declaration.id;
      var fingerprint = fingerprints[declarationId];
      if (!fingerprint) {
        switch (declaration.value.type) {
          case "Value":
            var vendorId = "";
            var iehack = "";
            var special = {};
            var raw = false;
            declaration.value.children.each(function walk2(node) {
              switch (node.type) {
                case "Value":
                case "Brackets":
                case "Parentheses":
                  node.children.each(walk2);
                  break;
                case "Raw":
                  raw = true;
                  break;
                case "Identifier":
                  var name = node.name;
                  if (!vendorId) {
                    vendorId = resolveKeyword(name).vendor;
                  }
                  if (/\\[09]/.test(name)) {
                    iehack = RegExp.lastMatch;
                  }
                  if (SAFE_VALUES.hasOwnProperty(realName)) {
                    if (SAFE_VALUES[realName].indexOf(name) === -1) {
                      special[name] = true;
                    }
                  } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                    if (DONT_MIX_VALUE[realName].test(name)) {
                      special[name] = true;
                    }
                  }
                  break;
                case "Function":
                  var name = node.name;
                  if (!vendorId) {
                    vendorId = resolveKeyword(name).vendor;
                  }
                  if (name === "rect") {
                    var hasComma = node.children.some(function(node2) {
                      return node2.type === "Operator" && node2.value === ",";
                    });
                    if (!hasComma) {
                      name = "rect-backward";
                    }
                  }
                  special[name + "()"] = true;
                  node.children.each(walk2);
                  break;
                case "Dimension":
                  var unit = node.unit;
                  if (/\\[09]/.test(unit)) {
                    iehack = RegExp.lastMatch;
                  }
                  switch (unit) {
                    case "rem":
                    case "vw":
                    case "vh":
                    case "vmin":
                    case "vmax":
                    case "vm":
                      special[unit] = true;
                      break;
                  }
                  break;
              }
            });
            fingerprint = raw ? "!" + fingerprintId++ : "!" + Object.keys(special).sort() + "|" + iehack + vendorId;
            break;
          case "Raw":
            fingerprint = "!" + declaration.value.value;
            break;
          default:
            fingerprint = generate(declaration.value);
        }
        fingerprints[declarationId] = fingerprint;
      }
      return propertyName + fingerprint;
    }
    function needless(props, declaration, fingerprints) {
      var property = resolveProperty(declaration.property);
      if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
        var table = NEEDLESS_TABLE[property.basename];
        for (var i = 0; i < table.length; i++) {
          var ppre = getPropertyFingerprint(property.prefix + table[i], declaration, fingerprints);
          var prev = props.hasOwnProperty(ppre) ? props[ppre] : null;
          if (prev && (!declaration.important || prev.item.data.important)) {
            return prev;
          }
        }
      }
    }
    function processRule(rule, item, list, props, fingerprints) {
      var declarations = rule.block.children;
      declarations.eachRight(function(declaration, declarationItem) {
        var property = declaration.property;
        var fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
        var prev = props[fingerprint];
        if (prev && !dontRestructure.hasOwnProperty(property)) {
          if (declaration.important && !prev.item.data.important) {
            props[fingerprint] = {
              block: declarations,
              item: declarationItem
            };
            prev.block.remove(prev.item);
          } else {
            declarations.remove(declarationItem);
          }
        } else {
          var prev = needless(props, declaration, fingerprints);
          if (prev) {
            declarations.remove(declarationItem);
          } else {
            declaration.fingerprint = fingerprint;
            props[fingerprint] = {
              block: declarations,
              item: declarationItem
            };
          }
        }
      });
      if (declarations.isEmpty()) {
        list.remove(item);
      }
    }
    module2.exports = function restructBlock(ast) {
      var stylesheetMap = {};
      var fingerprints = /* @__PURE__ */ Object.create(null);
      walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: function(node, item, list) {
          var stylesheet = this.block || this.stylesheet;
          var ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first().id;
          var ruleMap;
          var props;
          if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
            ruleMap = {};
            stylesheetMap[stylesheet.id] = ruleMap;
          } else {
            ruleMap = stylesheetMap[stylesheet.id];
          }
          if (ruleMap.hasOwnProperty(ruleId)) {
            props = ruleMap[ruleId];
          } else {
            props = {};
            ruleMap[ruleId] = props;
          }
          processRule.call(this, node, item, list, props, fingerprints);
        }
      });
    };
  }
});

// node_modules/csso/lib/restructure/7-mergeRuleset.js
var require_mergeRuleset = __commonJS({
  "node_modules/csso/lib/restructure/7-mergeRuleset.js"(exports2, module2) {
    var walk = require_lib10().walk;
    var utils = require_utils3();
    function processRule(node, item, list) {
      var selectors = node.prelude.children;
      var declarations = node.block.children;
      var nodeCompareMarker = selectors.first().compareMarker;
      var skippedCompareMarkers = {};
      list.nextUntil(item.next, function(next, nextItem) {
        if (next.type !== "Rule") {
          return utils.unsafeToSkipNode.call(selectors, next);
        }
        if (node.pseudoSignature !== next.pseudoSignature) {
          return true;
        }
        var nextFirstSelector = next.prelude.children.head;
        var nextDeclarations = next.block.children;
        var nextCompareMarker = nextFirstSelector.data.compareMarker;
        if (nextCompareMarker in skippedCompareMarkers) {
          return true;
        }
        if (selectors.head === selectors.tail) {
          if (selectors.first().id === nextFirstSelector.data.id) {
            declarations.appendList(nextDeclarations);
            list.remove(nextItem);
            return;
          }
        }
        if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
          var nextStr = nextFirstSelector.data.id;
          selectors.some(function(data, item2) {
            var curStr = data.id;
            if (nextStr < curStr) {
              selectors.insert(nextFirstSelector, item2);
              return true;
            }
            if (!item2.next) {
              selectors.insert(nextFirstSelector);
              return true;
            }
          });
          list.remove(nextItem);
          return;
        }
        if (nextCompareMarker === nodeCompareMarker) {
          return true;
        }
        skippedCompareMarkers[nextCompareMarker] = true;
      });
    }
    module2.exports = function mergeRule(ast) {
      walk(ast, {
        visit: "Rule",
        enter: processRule
      });
    };
  }
});

// node_modules/csso/lib/restructure/8-restructRuleset.js
var require_restructRuleset = __commonJS({
  "node_modules/csso/lib/restructure/8-restructRuleset.js"(exports2, module2) {
    var List = require_lib10().List;
    var walk = require_lib10().walk;
    var utils = require_utils3();
    function calcSelectorLength(list) {
      var length = 0;
      list.each(function(data) {
        length += data.id.length + 1;
      });
      return length - 1;
    }
    function calcDeclarationsLength(tokens) {
      var length = 0;
      for (var i = 0; i < tokens.length; i++) {
        length += tokens[i].length;
      }
      return length + // declarations
      tokens.length - 1;
    }
    function processRule(node, item, list) {
      var avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
      var selectors = node.prelude.children;
      var block = node.block;
      var disallowDownMarkers = /* @__PURE__ */ Object.create(null);
      var allowMergeUp = true;
      var allowMergeDown = true;
      list.prevUntil(item.prev, function(prev, prevItem) {
        var prevBlock = prev.block;
        var prevType = prev.type;
        if (prevType !== "Rule") {
          var unsafe = utils.unsafeToSkipNode.call(selectors, prev);
          if (!unsafe && prevType === "Atrule" && prevBlock) {
            walk(prevBlock, {
              visit: "Rule",
              enter: function(node2) {
                node2.prelude.children.each(function(data) {
                  disallowDownMarkers[data.compareMarker] = true;
                });
              }
            });
          }
          return unsafe;
        }
        var prevSelectors = prev.prelude.children;
        if (node.pseudoSignature !== prev.pseudoSignature) {
          return true;
        }
        allowMergeDown = !prevSelectors.some(function(selector) {
          return selector.compareMarker in disallowDownMarkers;
        });
        if (!allowMergeDown && !allowMergeUp) {
          return true;
        }
        if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {
          prevBlock.children.appendList(block.children);
          list.remove(item);
          return true;
        }
        var diff = utils.compareDeclarations(block.children, prevBlock.children);
        if (diff.eq.length) {
          if (!diff.ne1.length && !diff.ne2.length) {
            if (allowMergeDown) {
              utils.addSelectors(selectors, prevSelectors);
              list.remove(prevItem);
            }
            return true;
          } else if (!avoidRulesMerge) {
            if (diff.ne1.length && !diff.ne2.length) {
              var selectorLength = calcSelectorLength(selectors);
              var blockLength = calcDeclarationsLength(diff.eq);
              if (allowMergeUp && selectorLength < blockLength) {
                utils.addSelectors(prevSelectors, selectors);
                block.children = new List().fromArray(diff.ne1);
              }
            } else if (!diff.ne1.length && diff.ne2.length) {
              var selectorLength = calcSelectorLength(prevSelectors);
              var blockLength = calcDeclarationsLength(diff.eq);
              if (allowMergeDown && selectorLength < blockLength) {
                utils.addSelectors(selectors, prevSelectors);
                prevBlock.children = new List().fromArray(diff.ne2);
              }
            } else {
              var newSelector = {
                type: "SelectorList",
                loc: null,
                children: utils.addSelectors(prevSelectors.copy(), selectors)
              };
              var newBlockLength = calcSelectorLength(newSelector.children) + 2;
              var blockLength = calcDeclarationsLength(diff.eq);
              if (blockLength >= newBlockLength) {
                var newItem = list.createItem({
                  type: "Rule",
                  loc: null,
                  prelude: newSelector,
                  block: {
                    type: "Block",
                    loc: null,
                    children: new List().fromArray(diff.eq)
                  },
                  pseudoSignature: node.pseudoSignature
                });
                block.children = new List().fromArray(diff.ne1);
                prevBlock.children = new List().fromArray(diff.ne2overrided);
                if (allowMergeUp) {
                  list.insert(newItem, prevItem);
                } else {
                  list.insert(newItem, item);
                }
                return true;
              }
            }
          }
        }
        if (allowMergeUp) {
          allowMergeUp = !prevSelectors.some(function(prevSelector) {
            return selectors.some(function(selector) {
              return selector.compareMarker === prevSelector.compareMarker;
            });
          });
        }
        prevSelectors.each(function(data) {
          disallowDownMarkers[data.compareMarker] = true;
        });
      });
    }
    module2.exports = function restructRule(ast) {
      walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: processRule
      });
    };
  }
});

// node_modules/csso/lib/restructure/index.js
var require_restructure = __commonJS({
  "node_modules/csso/lib/restructure/index.js"(exports2, module2) {
    var prepare = require_prepare();
    var mergeAtrule = require_mergeAtrule();
    var initialMergeRuleset = require_initialMergeRuleset();
    var disjoinRuleset = require_disjoinRuleset();
    var restructShorthand = require_restructShorthand();
    var restructBlock = require_restructBlock();
    var mergeRuleset = require_mergeRuleset();
    var restructRuleset = require_restructRuleset();
    module2.exports = function(ast, options) {
      var indexer = prepare(ast, options);
      options.logger("prepare", ast);
      mergeAtrule(ast, options);
      options.logger("mergeAtrule", ast);
      initialMergeRuleset(ast);
      options.logger("initialMergeRuleset", ast);
      disjoinRuleset(ast);
      options.logger("disjoinRuleset", ast);
      restructShorthand(ast, indexer);
      options.logger("restructShorthand", ast);
      restructBlock(ast);
      options.logger("restructBlock", ast);
      mergeRuleset(ast);
      options.logger("mergeRuleset", ast);
      restructRuleset(ast);
      options.logger("restructRuleset", ast);
    };
  }
});

// node_modules/csso/lib/compress.js
var require_compress = __commonJS({
  "node_modules/csso/lib/compress.js"(exports2, module2) {
    var List = require_lib10().List;
    var clone = require_lib10().clone;
    var usageUtils = require_usage();
    var clean = require_clean();
    var replace = require_replace();
    var restructure = require_restructure();
    var walk = require_lib10().walk;
    function readChunk(children, specialComments) {
      var buffer = new List();
      var nonSpaceTokenInBuffer = false;
      var protectedComment;
      children.nextUntil(children.head, function(node, item, list) {
        if (node.type === "Comment") {
          if (!specialComments || node.value.charAt(0) !== "!") {
            list.remove(item);
            return;
          }
          if (nonSpaceTokenInBuffer || protectedComment) {
            return true;
          }
          list.remove(item);
          protectedComment = node;
          return;
        }
        if (node.type !== "WhiteSpace") {
          nonSpaceTokenInBuffer = true;
        }
        buffer.insert(list.remove(item));
      });
      return {
        comment: protectedComment,
        stylesheet: {
          type: "StyleSheet",
          loc: null,
          children: buffer
        }
      };
    }
    function compressChunk(ast, firstAtrulesAllowed, num, options) {
      options.logger("Compress block #" + num, null, true);
      var seed = 1;
      if (ast.type === "StyleSheet") {
        ast.firstAtrulesAllowed = firstAtrulesAllowed;
        ast.id = seed++;
      }
      walk(ast, {
        visit: "Atrule",
        enter: function markScopes(node) {
          if (node.block !== null) {
            node.block.id = seed++;
          }
        }
      });
      options.logger("init", ast);
      clean(ast, options);
      options.logger("clean", ast);
      replace(ast, options);
      options.logger("replace", ast);
      if (options.restructuring) {
        restructure(ast, options);
      }
      return ast;
    }
    function getCommentsOption(options) {
      var comments = "comments" in options ? options.comments : "exclamation";
      if (typeof comments === "boolean") {
        comments = comments ? "exclamation" : false;
      } else if (comments !== "exclamation" && comments !== "first-exclamation") {
        comments = false;
      }
      return comments;
    }
    function getRestructureOption(options) {
      if ("restructure" in options) {
        return options.restructure;
      }
      return "restructuring" in options ? options.restructuring : true;
    }
    function wrapBlock(block) {
      return new List().appendData({
        type: "Rule",
        loc: null,
        prelude: {
          type: "SelectorList",
          loc: null,
          children: new List().appendData({
            type: "Selector",
            loc: null,
            children: new List().appendData({
              type: "TypeSelector",
              loc: null,
              name: "x"
            })
          })
        },
        block
      });
    }
    module2.exports = function compress(ast, options) {
      ast = ast || { type: "StyleSheet", loc: null, children: new List() };
      options = options || {};
      var compressOptions = {
        logger: typeof options.logger === "function" ? options.logger : function() {
        },
        restructuring: getRestructureOption(options),
        forceMediaMerge: Boolean(options.forceMediaMerge),
        usage: options.usage ? usageUtils.buildIndex(options.usage) : false
      };
      var specialComments = getCommentsOption(options);
      var firstAtrulesAllowed = true;
      var input;
      var output = new List();
      var chunk;
      var chunkNum = 1;
      var chunkChildren;
      if (options.clone) {
        ast = clone(ast);
      }
      if (ast.type === "StyleSheet") {
        input = ast.children;
        ast.children = output;
      } else {
        input = wrapBlock(ast);
      }
      do {
        chunk = readChunk(input, Boolean(specialComments));
        compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
        chunkChildren = chunk.stylesheet.children;
        if (chunk.comment) {
          if (!output.isEmpty()) {
            output.insert(List.createItem({
              type: "Raw",
              value: "\n"
            }));
          }
          output.insert(List.createItem(chunk.comment));
          if (!chunkChildren.isEmpty()) {
            output.insert(List.createItem({
              type: "Raw",
              value: "\n"
            }));
          }
        }
        if (firstAtrulesAllowed && !chunkChildren.isEmpty()) {
          var lastRule = chunkChildren.last();
          if (lastRule.type !== "Atrule" || lastRule.name !== "import" && lastRule.name !== "charset") {
            firstAtrulesAllowed = false;
          }
        }
        if (specialComments !== "exclamation") {
          specialComments = false;
        }
        output.appendList(chunkChildren);
      } while (!input.isEmpty());
      return {
        ast
      };
    };
  }
});

// node_modules/csso/package.json
var require_package2 = __commonJS({
  "node_modules/csso/package.json"(exports2, module2) {
    module2.exports = {
      name: "csso",
      version: "4.2.0",
      description: "CSS minifier with structural optimisations",
      homepage: "https://github.com/css/csso",
      author: "Sergey Kryzhanovsky <skryzhanovsky@ya.ru> (https://github.com/afelix)",
      maintainers: [
        {
          name: "Roman Dvornov",
          email: "rdvornov@gmail.com",
          "github-username": "lahmatiy"
        }
      ],
      license: "MIT",
      repository: "css/csso",
      bugs: {
        url: "https://github.com/css/csso/issues"
      },
      keywords: [
        "css",
        "compress",
        "minifier",
        "minify",
        "optimise",
        "optimisation",
        "csstree"
      ],
      main: "./lib/index",
      scripts: {
        test: "mocha --reporter dot",
        lint: "eslint lib test",
        "lint-and-test": "npm run lint && npm test",
        build: "rollup --config && terser dist/csso.js --compress --mangle -o dist/csso.min.js",
        coverage: "nyc npm test",
        coveralls: "nyc report --reporter=text-lcov | coveralls",
        travis: "nyc npm run lint-and-test && npm run coveralls",
        hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null",
        prepublishOnly: "npm run build"
      },
      dependencies: {
        "css-tree": "^1.1.2"
      },
      browser: {
        "css-tree": "css-tree/dist/csstree.min.js"
      },
      devDependencies: {
        "@rollup/plugin-commonjs": "^11.0.1",
        "@rollup/plugin-json": "^4.0.1",
        "@rollup/plugin-node-resolve": "^7.0.0",
        coveralls: "^3.0.11",
        eslint: "^6.8.0",
        mocha: "^7.1.1",
        nyc: "^15.0.0",
        rollup: "^1.29.0",
        "source-map": "^0.6.1",
        terser: "^4.6.3"
      },
      engines: {
        node: ">=8.0.0"
      },
      files: [
        "dist",
        "lib"
      ]
    };
  }
});

// node_modules/csso/lib/index.js
var require_lib11 = __commonJS({
  "node_modules/csso/lib/index.js"(exports2, module2) {
    var csstree = require_lib10();
    var parse = csstree.parse;
    var compress = require_compress();
    var generate = csstree.generate;
    function debugOutput(name, options, startTime, data) {
      if (options.debug) {
        console.error("## " + name + " done in %d ms\n", Date.now() - startTime);
      }
      return data;
    }
    function createDefaultLogger(level) {
      var lastDebug;
      return function logger(title, ast) {
        var line = title;
        if (ast) {
          line = "[" + ((Date.now() - lastDebug) / 1e3).toFixed(3) + "s] " + line;
        }
        if (level > 1 && ast) {
          var css = generate(ast);
          if (level === 2 && css.length > 256) {
            css = css.substr(0, 256) + "...";
          }
          line += "\n  " + css + "\n";
        }
        console.error(line);
        lastDebug = Date.now();
      };
    }
    function copy(obj) {
      var result = {};
      for (var key in obj) {
        result[key] = obj[key];
      }
      return result;
    }
    function buildCompressOptions(options) {
      options = copy(options);
      if (typeof options.logger !== "function" && options.debug) {
        options.logger = createDefaultLogger(options.debug);
      }
      return options;
    }
    function runHandler(ast, options, handlers) {
      if (!Array.isArray(handlers)) {
        handlers = [handlers];
      }
      handlers.forEach(function(fn) {
        fn(ast, options);
      });
    }
    function minify(context, source, options) {
      options = options || {};
      var filename = options.filename || "<unknown>";
      var result;
      var ast = debugOutput(
        "parsing",
        options,
        Date.now(),
        parse(source, {
          context,
          filename,
          positions: Boolean(options.sourceMap)
        })
      );
      if (options.beforeCompress) {
        debugOutput(
          "beforeCompress",
          options,
          Date.now(),
          runHandler(ast, options, options.beforeCompress)
        );
      }
      var compressResult = debugOutput(
        "compress",
        options,
        Date.now(),
        compress(ast, buildCompressOptions(options))
      );
      if (options.afterCompress) {
        debugOutput(
          "afterCompress",
          options,
          Date.now(),
          runHandler(compressResult, options, options.afterCompress)
        );
      }
      if (options.sourceMap) {
        result = debugOutput("generate(sourceMap: true)", options, Date.now(), function() {
          var tmp = generate(compressResult.ast, { sourceMap: true });
          tmp.map._file = filename;
          tmp.map.setSourceContent(filename, source);
          return tmp;
        }());
      } else {
        result = debugOutput("generate", options, Date.now(), {
          css: generate(compressResult.ast),
          map: null
        });
      }
      return result;
    }
    function minifyStylesheet(source, options) {
      return minify("stylesheet", source, options);
    }
    function minifyBlock(source, options) {
      return minify("declarationList", source, options);
    }
    module2.exports = {
      version: require_package2().version,
      // main methods
      minify: minifyStylesheet,
      minifyBlock,
      // css syntax parser/walkers/generator/etc
      syntax: Object.assign({
        compress
      }, csstree)
    };
  }
});

// node_modules/svgo/plugins/minifyStyles.js
var require_minifyStyles = __commonJS({
  "node_modules/svgo/plugins/minifyStyles.js"(exports2) {
    "use strict";
    var csso = require_lib11();
    exports2.type = "visitor";
    exports2.name = "minifyStyles";
    exports2.active = true;
    exports2.description = "minifies styles and removes unused styles based on usage data";
    exports2.fn = (_root, { usage, ...params }) => {
      let enableTagsUsage = true;
      let enableIdsUsage = true;
      let enableClassesUsage = true;
      let forceUsageDeoptimized = false;
      if (typeof usage === "boolean") {
        enableTagsUsage = usage;
        enableIdsUsage = usage;
        enableClassesUsage = usage;
      } else if (usage) {
        enableTagsUsage = usage.tags == null ? true : usage.tags;
        enableIdsUsage = usage.ids == null ? true : usage.ids;
        enableClassesUsage = usage.classes == null ? true : usage.classes;
        forceUsageDeoptimized = usage.force == null ? false : usage.force;
      }
      const styleElements = [];
      const elementsWithStyleAttributes = [];
      let deoptimized = false;
      const tagsUsage = /* @__PURE__ */ new Set();
      const idsUsage = /* @__PURE__ */ new Set();
      const classesUsage = /* @__PURE__ */ new Set();
      return {
        element: {
          enter: (node) => {
            if (node.name === "script") {
              deoptimized = true;
            }
            for (const name of Object.keys(node.attributes)) {
              if (name.startsWith("on")) {
                deoptimized = true;
              }
            }
            tagsUsage.add(node.name);
            if (node.attributes.id != null) {
              idsUsage.add(node.attributes.id);
            }
            if (node.attributes.class != null) {
              for (const className of node.attributes.class.split(/\s+/)) {
                classesUsage.add(className);
              }
            }
            if (node.name === "style" && node.children.length !== 0) {
              styleElements.push(node);
            } else if (node.attributes.style != null) {
              elementsWithStyleAttributes.push(node);
            }
          }
        },
        root: {
          exit: () => {
            const cssoUsage = {};
            if (deoptimized === false || forceUsageDeoptimized === true) {
              if (enableTagsUsage && tagsUsage.size !== 0) {
                cssoUsage.tags = Array.from(tagsUsage);
              }
              if (enableIdsUsage && idsUsage.size !== 0) {
                cssoUsage.ids = Array.from(idsUsage);
              }
              if (enableClassesUsage && classesUsage.size !== 0) {
                cssoUsage.classes = Array.from(classesUsage);
              }
            }
            for (const node of styleElements) {
              if (node.children[0].type === "text" || node.children[0].type === "cdata") {
                const cssText = node.children[0].value;
                const minified = csso.minify(cssText, {
                  ...params,
                  usage: cssoUsage
                }).css;
                if (cssText.indexOf(">") >= 0 || cssText.indexOf("<") >= 0) {
                  node.children[0].type = "cdata";
                  node.children[0].value = minified;
                } else {
                  node.children[0].type = "text";
                  node.children[0].value = minified;
                }
              }
            }
            for (const node of elementsWithStyleAttributes) {
              const elemStyle = node.attributes.style;
              node.attributes.style = csso.minifyBlock(elemStyle, {
                ...params
              }).css;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupIDs.js
var require_cleanupIDs = __commonJS({
  "node_modules/svgo/plugins/cleanupIDs.js"(exports2) {
    "use strict";
    var { visitSkip } = require_xast();
    var { referencesProps } = require_collections();
    exports2.type = "visitor";
    exports2.name = "cleanupIDs";
    exports2.active = true;
    exports2.description = "removes unused IDs and minifies used";
    var regReferencesUrl = /\burl\(("|')?#(.+?)\1\)/;
    var regReferencesHref = /^#(.+?)$/;
    var regReferencesBegin = /(\w+)\./;
    var generateIDchars = [
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ];
    var maxIDindex = generateIDchars.length - 1;
    var hasStringPrefix = (string, prefixes) => {
      for (const prefix of prefixes) {
        if (string.startsWith(prefix)) {
          return true;
        }
      }
      return false;
    };
    var generateID = (currentID) => {
      if (currentID == null) {
        return [0];
      }
      currentID[currentID.length - 1] += 1;
      for (let i = currentID.length - 1; i > 0; i--) {
        if (currentID[i] > maxIDindex) {
          currentID[i] = 0;
          if (currentID[i - 1] !== void 0) {
            currentID[i - 1]++;
          }
        }
      }
      if (currentID[0] > maxIDindex) {
        currentID[0] = 0;
        currentID.unshift(0);
      }
      return currentID;
    };
    var getIDstring = (arr, prefix) => {
      return prefix + arr.map((i) => generateIDchars[i]).join("");
    };
    exports2.fn = (_root, params) => {
      const {
        remove = true,
        minify = true,
        prefix = "",
        preserve = [],
        preservePrefixes = [],
        force = false
      } = params;
      const preserveIDs = new Set(
        Array.isArray(preserve) ? preserve : preserve ? [preserve] : []
      );
      const preserveIDPrefixes = Array.isArray(preservePrefixes) ? preservePrefixes : preservePrefixes ? [preservePrefixes] : [];
      const nodeById = /* @__PURE__ */ new Map();
      const referencesById = /* @__PURE__ */ new Map();
      let deoptimized = false;
      return {
        element: {
          enter: (node) => {
            if (force == false) {
              if ((node.name === "style" || node.name === "script") && node.children.length !== 0) {
                deoptimized = true;
                return;
              }
              if (node.name === "svg") {
                let hasDefsOnly = true;
                for (const child of node.children) {
                  if (child.type !== "element" || child.name !== "defs") {
                    hasDefsOnly = false;
                    break;
                  }
                }
                if (hasDefsOnly) {
                  return visitSkip;
                }
              }
            }
            for (const [name, value] of Object.entries(node.attributes)) {
              if (name === "id") {
                const id = value;
                if (nodeById.has(id)) {
                  delete node.attributes.id;
                } else {
                  nodeById.set(id, node);
                }
              } else {
                let id = null;
                if (referencesProps.includes(name)) {
                  const match = value.match(regReferencesUrl);
                  if (match != null) {
                    id = match[2];
                  }
                }
                if (name === "href" || name.endsWith(":href")) {
                  const match = value.match(regReferencesHref);
                  if (match != null) {
                    id = match[1];
                  }
                }
                if (name === "begin") {
                  const match = value.match(regReferencesBegin);
                  if (match != null) {
                    id = match[1];
                  }
                }
                if (id != null) {
                  let refs = referencesById.get(id);
                  if (refs == null) {
                    refs = [];
                    referencesById.set(id, refs);
                  }
                  refs.push({ element: node, name, value });
                }
              }
            }
          }
        },
        root: {
          exit: () => {
            if (deoptimized) {
              return;
            }
            const isIdPreserved = (id) => preserveIDs.has(id) || hasStringPrefix(id, preserveIDPrefixes);
            let currentID = null;
            for (const [id, refs] of referencesById) {
              const node = nodeById.get(id);
              if (node != null) {
                if (minify && isIdPreserved(id) === false) {
                  let currentIDString = null;
                  do {
                    currentID = generateID(currentID);
                    currentIDString = getIDstring(currentID, prefix);
                  } while (isIdPreserved(currentIDString));
                  node.attributes.id = currentIDString;
                  for (const { element, name, value } of refs) {
                    if (value.includes("#")) {
                      element.attributes[name] = value.replace(
                        `#${id}`,
                        `#${currentIDString}`
                      );
                    } else {
                      element.attributes[name] = value.replace(
                        `${id}.`,
                        `${currentIDString}.`
                      );
                    }
                  }
                }
                nodeById.delete(id);
              }
            }
            if (remove) {
              for (const [id, node] of nodeById) {
                if (isIdPreserved(id) === false) {
                  delete node.attributes.id;
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeUselessDefs.js
var require_removeUselessDefs = __commonJS({
  "node_modules/svgo/plugins/removeUselessDefs.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { elemsGroups } = require_collections();
    exports2.type = "visitor";
    exports2.name = "removeUselessDefs";
    exports2.active = true;
    exports2.description = "removes elements in <defs> without id";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "defs") {
              const usefulNodes = [];
              collectUsefulNodes(node, usefulNodes);
              if (usefulNodes.length === 0) {
                detachNodeFromParent(node, parentNode);
              }
              for (const usefulNode of usefulNodes) {
                usefulNode.parentNode = node;
              }
              node.children = usefulNodes;
            } else if (elemsGroups.nonRendering.includes(node.name) && node.attributes.id == null) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
    var collectUsefulNodes = (node, usefulNodes) => {
      for (const child of node.children) {
        if (child.type === "element") {
          if (child.attributes.id != null || child.name === "style") {
            usefulNodes.push(child);
          } else {
            collectUsefulNodes(child, usefulNodes);
          }
        }
      }
    };
  }
});

// node_modules/svgo/lib/svgo/tools.js
var require_tools = __commonJS({
  "node_modules/svgo/lib/svgo/tools.js"(exports2) {
    "use strict";
    exports2.encodeSVGDatauri = (str, type) => {
      var prefix = "data:image/svg+xml";
      if (!type || type === "base64") {
        prefix += ";base64,";
        str = prefix + Buffer.from(str).toString("base64");
      } else if (type === "enc") {
        str = prefix + "," + encodeURIComponent(str);
      } else if (type === "unenc") {
        str = prefix + "," + str;
      }
      return str;
    };
    exports2.decodeSVGDatauri = (str) => {
      var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
      var match = regexp.exec(str);
      if (!match) return str;
      var data = match[3];
      if (match[2]) {
        str = Buffer.from(data, "base64").toString("utf8");
      } else if (data.charAt(0) === "%") {
        str = decodeURIComponent(data);
      } else if (data.charAt(0) === "<") {
        str = data;
      }
      return str;
    };
    exports2.cleanupOutData = (data, params, command) => {
      let str = "";
      let delimiter;
      let prev;
      data.forEach((item, i) => {
        delimiter = " ";
        if (i == 0) delimiter = "";
        if (params.noSpaceAfterFlags && (command == "A" || command == "a")) {
          var pos = i % 7;
          if (pos == 4 || pos == 5) delimiter = "";
        }
        const itemStr = params.leadingZero ? removeLeadingZero(item) : item.toString();
        if (params.negativeExtraSpace && delimiter != "" && (item < 0 || itemStr.charAt(0) === "." && prev % 1 !== 0)) {
          delimiter = "";
        }
        prev = item;
        str += delimiter + itemStr;
      });
      return str;
    };
    var removeLeadingZero = (num) => {
      var strNum = num.toString();
      if (0 < num && num < 1 && strNum.charAt(0) === "0") {
        strNum = strNum.slice(1);
      } else if (-1 < num && num < 0 && strNum.charAt(1) === "0") {
        strNum = strNum.charAt(0) + strNum.slice(2);
      }
      return strNum;
    };
    exports2.removeLeadingZero = removeLeadingZero;
  }
});

// node_modules/svgo/plugins/cleanupNumericValues.js
var require_cleanupNumericValues = __commonJS({
  "node_modules/svgo/plugins/cleanupNumericValues.js"(exports2) {
    "use strict";
    var { removeLeadingZero } = require_tools();
    exports2.name = "cleanupNumericValues";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "rounds numeric values to the fixed precision, removes default \u2018px\u2019 units";
    var regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
    var absoluteLengths = {
      // relative to px
      cm: 96 / 2.54,
      mm: 96 / 25.4,
      in: 96,
      pt: 4 / 3,
      pc: 16,
      px: 1
    };
    exports2.fn = (_root, params) => {
      const {
        floatPrecision = 3,
        leadingZero = true,
        defaultPx = true,
        convertToPx = true
      } = params;
      return {
        element: {
          enter: (node) => {
            if (node.attributes.viewBox != null) {
              const nums = node.attributes.viewBox.split(/\s,?\s*|,\s*/g);
              node.attributes.viewBox = nums.map((value) => {
                const num = Number(value);
                return Number.isNaN(num) ? value : Number(num.toFixed(floatPrecision));
              }).join(" ");
            }
            for (const [name, value] of Object.entries(node.attributes)) {
              if (name === "version") {
                continue;
              }
              const match = value.match(regNumericValues);
              if (match) {
                let num = Number(Number(match[1]).toFixed(floatPrecision));
                let matchedUnit = match[3] || "";
                let units = matchedUnit;
                if (convertToPx && units !== "" && units in absoluteLengths) {
                  const pxNum = Number(
                    (absoluteLengths[units] * Number(match[1])).toFixed(
                      floatPrecision
                    )
                  );
                  if (pxNum.toString().length < match[0].length) {
                    num = pxNum;
                    units = "px";
                  }
                }
                let str;
                if (leadingZero) {
                  str = removeLeadingZero(num);
                } else {
                  str = num.toString();
                }
                if (defaultPx && units === "px") {
                  units = "";
                }
                node.attributes[name] = str + units;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertColors.js
var require_convertColors = __commonJS({
  "node_modules/svgo/plugins/convertColors.js"(exports2) {
    "use strict";
    var collections = require_collections();
    exports2.type = "visitor";
    exports2.name = "convertColors";
    exports2.active = true;
    exports2.description = "converts colors: rgb() to #rrggbb and #rrggbb to #rgb";
    var rNumber = "([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)";
    var rComma = "\\s*,\\s*";
    var regRGB = new RegExp(
      "^rgb\\(\\s*" + rNumber + rComma + rNumber + rComma + rNumber + "\\s*\\)$"
    );
    var regHEX = /^#(([a-fA-F0-9])\2){3}$/;
    var convertRgbToHex = ([r, g, b]) => {
      const hexNumber = (
        // operator precedence is (+) > (<<) > (|)
        (256 + // [1][0]
        r << // [1][r]
        8 | // [1][r][0]
        g) << // [1][r][g]
        8 | // [1][r][g][0]
        b
      );
      return "#" + hexNumber.toString(16).slice(1).toUpperCase();
    };
    exports2.fn = (_root, params) => {
      const {
        currentColor = false,
        names2hex = true,
        rgb2hex = true,
        shorthex = true,
        shortname = true
      } = params;
      return {
        element: {
          enter: (node) => {
            for (const [name, value] of Object.entries(node.attributes)) {
              if (collections.colorsProps.includes(name)) {
                let val = value;
                if (currentColor) {
                  let matched;
                  if (typeof currentColor === "string") {
                    matched = val === currentColor;
                  } else if (currentColor instanceof RegExp) {
                    matched = currentColor.exec(val) != null;
                  } else {
                    matched = val !== "none";
                  }
                  if (matched) {
                    val = "currentColor";
                  }
                }
                if (names2hex) {
                  const colorName = val.toLowerCase();
                  if (collections.colorsNames[colorName] != null) {
                    val = collections.colorsNames[colorName];
                  }
                }
                if (rgb2hex) {
                  let match = val.match(regRGB);
                  if (match != null) {
                    let nums = match.slice(1, 4).map((m) => {
                      let n;
                      if (m.indexOf("%") > -1) {
                        n = Math.round(parseFloat(m) * 2.55);
                      } else {
                        n = Number(m);
                      }
                      return Math.max(0, Math.min(n, 255));
                    });
                    val = convertRgbToHex(nums);
                  }
                }
                if (shorthex) {
                  let match = val.match(regHEX);
                  if (match != null) {
                    val = "#" + match[0][1] + match[0][3] + match[0][5];
                  }
                }
                if (shortname) {
                  const colorName = val.toLowerCase();
                  if (collections.colorsShortNames[colorName] != null) {
                    val = collections.colorsShortNames[colorName];
                  }
                }
                node.attributes[name] = val;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/lib/style.js
var require_style = __commonJS({
  "node_modules/svgo/lib/style.js"(exports2) {
    "use strict";
    var stable = require_stable();
    var csstree = require_lib10();
    var specificity = require_specificity();
    var { visit, matches } = require_xast();
    var {
      attrsGroups,
      inheritableAttrs,
      presentationNonInheritableGroupAttrs
    } = require_collections();
    var csstreeWalkSkip = csstree.walk.skip;
    var parseRule = (ruleNode, dynamic) => {
      let selectors;
      let selectorsSpecificity;
      const declarations = [];
      csstree.walk(ruleNode, (cssNode) => {
        if (cssNode.type === "SelectorList") {
          selectorsSpecificity = specificity(cssNode);
          const newSelectorsNode = csstree.clone(cssNode);
          csstree.walk(newSelectorsNode, (pseudoClassNode, item, list) => {
            if (pseudoClassNode.type === "PseudoClassSelector") {
              dynamic = true;
              list.remove(item);
            }
          });
          selectors = csstree.generate(newSelectorsNode);
          return csstreeWalkSkip;
        }
        if (cssNode.type === "Declaration") {
          declarations.push({
            name: cssNode.property,
            value: csstree.generate(cssNode.value),
            important: cssNode.important === true
          });
          return csstreeWalkSkip;
        }
      });
      if (selectors == null || selectorsSpecificity == null) {
        throw Error("assert");
      }
      return {
        dynamic,
        selectors,
        specificity: selectorsSpecificity,
        declarations
      };
    };
    var parseStylesheet = (css, dynamic) => {
      const rules = [];
      const ast = csstree.parse(css, {
        parseValue: false,
        parseAtrulePrelude: false
      });
      csstree.walk(ast, (cssNode) => {
        if (cssNode.type === "Rule") {
          rules.push(parseRule(cssNode, dynamic || false));
          return csstreeWalkSkip;
        }
        if (cssNode.type === "Atrule") {
          if (cssNode.name === "keyframes") {
            return csstreeWalkSkip;
          }
          csstree.walk(cssNode, (ruleNode) => {
            if (ruleNode.type === "Rule") {
              rules.push(parseRule(ruleNode, dynamic || true));
              return csstreeWalkSkip;
            }
          });
          return csstreeWalkSkip;
        }
      });
      return rules;
    };
    var parseStyleDeclarations = (css) => {
      const declarations = [];
      const ast = csstree.parse(css, {
        context: "declarationList",
        parseValue: false
      });
      csstree.walk(ast, (cssNode) => {
        if (cssNode.type === "Declaration") {
          declarations.push({
            name: cssNode.property,
            value: csstree.generate(cssNode.value),
            important: cssNode.important === true
          });
        }
      });
      return declarations;
    };
    var computeOwnStyle = (stylesheet, node) => {
      const computedStyle = {};
      const importantStyles = /* @__PURE__ */ new Map();
      for (const [name, value] of Object.entries(node.attributes)) {
        if (attrsGroups.presentation.includes(name)) {
          computedStyle[name] = { type: "static", inherited: false, value };
          importantStyles.set(name, false);
        }
      }
      for (const { selectors, declarations, dynamic } of stylesheet.rules) {
        if (matches(node, selectors)) {
          for (const { name, value, important } of declarations) {
            const computed = computedStyle[name];
            if (computed && computed.type === "dynamic") {
              continue;
            }
            if (dynamic) {
              computedStyle[name] = { type: "dynamic", inherited: false };
              continue;
            }
            if (computed == null || important === true || importantStyles.get(name) === false) {
              computedStyle[name] = { type: "static", inherited: false, value };
              importantStyles.set(name, important);
            }
          }
        }
      }
      const styleDeclarations = node.attributes.style == null ? [] : parseStyleDeclarations(node.attributes.style);
      for (const { name, value, important } of styleDeclarations) {
        const computed = computedStyle[name];
        if (computed && computed.type === "dynamic") {
          continue;
        }
        if (computed == null || important === true || importantStyles.get(name) === false) {
          computedStyle[name] = { type: "static", inherited: false, value };
          importantStyles.set(name, important);
        }
      }
      return computedStyle;
    };
    var compareSpecificity = (a, b) => {
      for (var i = 0; i < 4; i += 1) {
        if (a[i] < b[i]) {
          return -1;
        } else if (a[i] > b[i]) {
          return 1;
        }
      }
      return 0;
    };
    var collectStylesheet = (root) => {
      const rules = [];
      const parents = /* @__PURE__ */ new Map();
      visit(root, {
        element: {
          enter: (node, parentNode) => {
            parents.set(node, parentNode);
            if (node.name === "style") {
              const dynamic = node.attributes.media != null && node.attributes.media !== "all";
              if (node.attributes.type == null || node.attributes.type === "" || node.attributes.type === "text/css") {
                const children = node.children;
                for (const child of children) {
                  if (child.type === "text" || child.type === "cdata") {
                    rules.push(...parseStylesheet(child.value, dynamic));
                  }
                }
              }
            }
          }
        }
      });
      stable.inplace(
        rules,
        (a, b) => compareSpecificity(a.specificity, b.specificity)
      );
      return { rules, parents };
    };
    exports2.collectStylesheet = collectStylesheet;
    var computeStyle = (stylesheet, node) => {
      const { parents } = stylesheet;
      const computedStyles = computeOwnStyle(stylesheet, node);
      let parent = parents.get(node);
      while (parent != null && parent.type !== "root") {
        const inheritedStyles = computeOwnStyle(stylesheet, parent);
        for (const [name, computed] of Object.entries(inheritedStyles)) {
          if (computedStyles[name] == null && // ignore not inheritable styles
          inheritableAttrs.includes(name) === true && presentationNonInheritableGroupAttrs.includes(name) === false) {
            computedStyles[name] = { ...computed, inherited: true };
          }
        }
        parent = parents.get(parent);
      }
      return computedStyles;
    };
    exports2.computeStyle = computeStyle;
  }
});

// node_modules/svgo/plugins/removeUnknownsAndDefaults.js
var require_removeUnknownsAndDefaults = __commonJS({
  "node_modules/svgo/plugins/removeUnknownsAndDefaults.js"(exports2) {
    "use strict";
    var { visitSkip, detachNodeFromParent } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var {
      elems,
      attrsGroups,
      elemsGroups,
      attrsGroupsDefaults,
      presentationNonInheritableGroupAttrs
    } = require_collections();
    exports2.type = "visitor";
    exports2.name = "removeUnknownsAndDefaults";
    exports2.active = true;
    exports2.description = "removes unknown elements content and attributes, removes attrs with default values";
    var allowedChildrenPerElement = /* @__PURE__ */ new Map();
    var allowedAttributesPerElement = /* @__PURE__ */ new Map();
    var attributesDefaultsPerElement = /* @__PURE__ */ new Map();
    for (const [name, config] of Object.entries(elems)) {
      const allowedChildren = /* @__PURE__ */ new Set();
      if (config.content) {
        for (const elementName of config.content) {
          allowedChildren.add(elementName);
        }
      }
      if (config.contentGroups) {
        for (const contentGroupName of config.contentGroups) {
          const elemsGroup = elemsGroups[contentGroupName];
          if (elemsGroup) {
            for (const elementName of elemsGroup) {
              allowedChildren.add(elementName);
            }
          }
        }
      }
      const allowedAttributes = /* @__PURE__ */ new Set();
      if (config.attrs) {
        for (const attrName of config.attrs) {
          allowedAttributes.add(attrName);
        }
      }
      const attributesDefaults = /* @__PURE__ */ new Map();
      if (config.defaults) {
        for (const [attrName, defaultValue] of Object.entries(config.defaults)) {
          attributesDefaults.set(attrName, defaultValue);
        }
      }
      for (const attrsGroupName of config.attrsGroups) {
        const attrsGroup = attrsGroups[attrsGroupName];
        if (attrsGroup) {
          for (const attrName of attrsGroup) {
            allowedAttributes.add(attrName);
          }
        }
        const groupDefaults = attrsGroupsDefaults[attrsGroupName];
        if (groupDefaults) {
          for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {
            attributesDefaults.set(attrName, defaultValue);
          }
        }
      }
      allowedChildrenPerElement.set(name, allowedChildren);
      allowedAttributesPerElement.set(name, allowedAttributes);
      attributesDefaultsPerElement.set(name, attributesDefaults);
    }
    exports2.fn = (root, params) => {
      const {
        unknownContent = true,
        unknownAttrs = true,
        defaultAttrs = true,
        uselessOverrides = true,
        keepDataAttrs = true,
        keepAriaAttrs = true,
        keepRoleAttr = false
      } = params;
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name.includes(":")) {
              return;
            }
            if (node.name === "foreignObject") {
              return visitSkip;
            }
            if (unknownContent && parentNode.type === "element") {
              const allowedChildren = allowedChildrenPerElement.get(
                parentNode.name
              );
              if (allowedChildren == null || allowedChildren.size === 0) {
                if (allowedChildrenPerElement.get(node.name) == null) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
              } else {
                if (allowedChildren.has(node.name) === false) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
              }
            }
            const allowedAttributes = allowedAttributesPerElement.get(node.name);
            const attributesDefaults = attributesDefaultsPerElement.get(node.name);
            const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
            for (const [name, value] of Object.entries(node.attributes)) {
              if (keepDataAttrs && name.startsWith("data-")) {
                continue;
              }
              if (keepAriaAttrs && name.startsWith("aria-")) {
                continue;
              }
              if (keepRoleAttr && name === "role") {
                continue;
              }
              if (name === "xmlns") {
                continue;
              }
              if (name.includes(":")) {
                const [prefix] = name.split(":");
                if (prefix !== "xml" && prefix !== "xlink") {
                  continue;
                }
              }
              if (unknownAttrs && allowedAttributes && allowedAttributes.has(name) === false) {
                delete node.attributes[name];
              }
              if (defaultAttrs && node.attributes.id == null && attributesDefaults && attributesDefaults.get(name) === value) {
                if (computedParentStyle == null || computedParentStyle[name] == null) {
                  delete node.attributes[name];
                }
              }
              if (uselessOverrides && node.attributes.id == null) {
                const style = computedParentStyle == null ? null : computedParentStyle[name];
                if (presentationNonInheritableGroupAttrs.includes(name) === false && style != null && style.type === "static" && style.value === value) {
                  delete node.attributes[name];
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeNonInheritableGroupAttrs.js
var require_removeNonInheritableGroupAttrs = __commonJS({
  "node_modules/svgo/plugins/removeNonInheritableGroupAttrs.js"(exports2) {
    "use strict";
    exports2.name = "removeNonInheritableGroupAttrs";
    exports2.type = "perItem";
    exports2.active = true;
    exports2.description = "removes non-inheritable group\u2019s presentational attributes";
    var {
      inheritableAttrs,
      attrsGroups,
      presentationNonInheritableGroupAttrs
    } = require_collections();
    exports2.fn = function(item) {
      if (item.type === "element" && item.name === "g") {
        for (const name of Object.keys(item.attributes)) {
          if (attrsGroups.presentation.includes(name) === true && inheritableAttrs.includes(name) === false && presentationNonInheritableGroupAttrs.includes(name) === false) {
            delete item.attributes[name];
          }
        }
      }
    };
  }
});

// node_modules/svgo/plugins/removeUselessStrokeAndFill.js
var require_removeUselessStrokeAndFill = __commonJS({
  "node_modules/svgo/plugins/removeUselessStrokeAndFill.js"(exports2) {
    "use strict";
    var { visit, visitSkip, detachNodeFromParent } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var { elemsGroups } = require_collections();
    exports2.type = "visitor";
    exports2.name = "removeUselessStrokeAndFill";
    exports2.active = true;
    exports2.description = "removes useless stroke and fill attributes";
    exports2.fn = (root, params) => {
      const {
        stroke: removeStroke = true,
        fill: removeFill = true,
        removeNone = false
      } = params;
      let hasStyleOrScript = false;
      visit(root, {
        element: {
          enter: (node) => {
            if (node.name === "style" || node.name === "script") {
              hasStyleOrScript = true;
            }
          }
        }
      });
      if (hasStyleOrScript) {
        return null;
      }
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.attributes.id != null) {
              return visitSkip;
            }
            if (elemsGroups.shape.includes(node.name) == false) {
              return;
            }
            const computedStyle = computeStyle(stylesheet, node);
            const stroke = computedStyle.stroke;
            const strokeOpacity = computedStyle["stroke-opacity"];
            const strokeWidth = computedStyle["stroke-width"];
            const markerEnd = computedStyle["marker-end"];
            const fill = computedStyle.fill;
            const fillOpacity = computedStyle["fill-opacity"];
            const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
            const parentStroke = computedParentStyle == null ? null : computedParentStyle.stroke;
            if (removeStroke) {
              if (stroke == null || stroke.type === "static" && stroke.value == "none" || strokeOpacity != null && strokeOpacity.type === "static" && strokeOpacity.value === "0" || strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0") {
                if (strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0" || markerEnd == null) {
                  for (const name of Object.keys(node.attributes)) {
                    if (name.startsWith("stroke")) {
                      delete node.attributes[name];
                    }
                  }
                  if (parentStroke != null && parentStroke.type === "static" && parentStroke.value !== "none") {
                    node.attributes.stroke = "none";
                  }
                }
              }
            }
            if (removeFill) {
              if (fill != null && fill.type === "static" && fill.value === "none" || fillOpacity != null && fillOpacity.type === "static" && fillOpacity.value === "0") {
                for (const name of Object.keys(node.attributes)) {
                  if (name.startsWith("fill-")) {
                    delete node.attributes[name];
                  }
                }
                if (fill == null || fill.type === "static" && fill.value !== "none") {
                  node.attributes.fill = "none";
                }
              }
            }
            if (removeNone) {
              if ((stroke == null || node.attributes.stroke === "none") && (fill != null && fill.type === "static" && fill.value === "none" || node.attributes.fill === "none")) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeViewBox.js
var require_removeViewBox = __commonJS({
  "node_modules/svgo/plugins/removeViewBox.js"(exports2) {
    "use strict";
    exports2.type = "visitor";
    exports2.name = "removeViewBox";
    exports2.active = true;
    exports2.description = "removes viewBox attribute when possible";
    var viewBoxElems = ["svg", "pattern", "symbol"];
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (viewBoxElems.includes(node.name) && node.attributes.viewBox != null && node.attributes.width != null && node.attributes.height != null) {
              if (node.name === "svg" && parentNode.type !== "root") {
                return;
              }
              const nums = node.attributes.viewBox.split(/[ ,]+/g);
              if (nums[0] === "0" && nums[1] === "0" && node.attributes.width.replace(/px$/, "") === nums[2] && // could use parseFloat too
              node.attributes.height.replace(/px$/, "") === nums[3]) {
                delete node.attributes.viewBox;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupEnableBackground.js
var require_cleanupEnableBackground = __commonJS({
  "node_modules/svgo/plugins/cleanupEnableBackground.js"(exports2) {
    "use strict";
    var { visit } = require_xast();
    exports2.type = "visitor";
    exports2.name = "cleanupEnableBackground";
    exports2.active = true;
    exports2.description = "remove or cleanup enable-background attribute when possible";
    exports2.fn = (root) => {
      const regEnableBackground = /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;
      let hasFilter = false;
      visit(root, {
        element: {
          enter: (node) => {
            if (node.name === "filter") {
              hasFilter = true;
            }
          }
        }
      });
      return {
        element: {
          enter: (node) => {
            if (node.attributes["enable-background"] == null) {
              return;
            }
            if (hasFilter) {
              if ((node.name === "svg" || node.name === "mask" || node.name === "pattern") && node.attributes.width != null && node.attributes.height != null) {
                const match = node.attributes["enable-background"].match(regEnableBackground);
                if (match != null && node.attributes.width === match[1] && node.attributes.height === match[3]) {
                  if (node.name === "svg") {
                    delete node.attributes["enable-background"];
                  } else {
                    node.attributes["enable-background"] = "new";
                  }
                }
              }
            } else {
              delete node.attributes["enable-background"];
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/lib/path.js
var require_path = __commonJS({
  "node_modules/svgo/lib/path.js"(exports2) {
    "use strict";
    var argsCountPerCommand = {
      M: 2,
      m: 2,
      Z: 0,
      z: 0,
      L: 2,
      l: 2,
      H: 1,
      h: 1,
      V: 1,
      v: 1,
      C: 6,
      c: 6,
      S: 4,
      s: 4,
      Q: 4,
      q: 4,
      T: 2,
      t: 2,
      A: 7,
      a: 7
    };
    var isCommand = (c) => {
      return c in argsCountPerCommand;
    };
    var isWsp = (c) => {
      const codePoint = c.codePointAt(0);
      return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
    };
    var isDigit = (c) => {
      const codePoint = c.codePointAt(0);
      if (codePoint == null) {
        return false;
      }
      return 48 <= codePoint && codePoint <= 57;
    };
    var readNumber = (string, cursor) => {
      let i = cursor;
      let value = "";
      let state = (
        /** @type {ReadNumberState} */
        "none"
      );
      for (; i < string.length; i += 1) {
        const c = string[i];
        if (c === "+" || c === "-") {
          if (state === "none") {
            state = "sign";
            value += c;
            continue;
          }
          if (state === "e") {
            state = "exponent_sign";
            value += c;
            continue;
          }
        }
        if (isDigit(c)) {
          if (state === "none" || state === "sign" || state === "whole") {
            state = "whole";
            value += c;
            continue;
          }
          if (state === "decimal_point" || state === "decimal") {
            state = "decimal";
            value += c;
            continue;
          }
          if (state === "e" || state === "exponent_sign" || state === "exponent") {
            state = "exponent";
            value += c;
            continue;
          }
        }
        if (c === ".") {
          if (state === "none" || state === "sign" || state === "whole") {
            state = "decimal_point";
            value += c;
            continue;
          }
        }
        if (c === "E" || c == "e") {
          if (state === "whole" || state === "decimal_point" || state === "decimal") {
            state = "e";
            value += c;
            continue;
          }
        }
        break;
      }
      const number = Number.parseFloat(value);
      if (Number.isNaN(number)) {
        return [cursor, null];
      } else {
        return [i - 1, number];
      }
    };
    var parsePathData = (string) => {
      const pathData = [];
      let command = null;
      let args = (
        /** @type {number[]} */
        []
      );
      let argsCount = 0;
      let canHaveComma = false;
      let hadComma = false;
      for (let i = 0; i < string.length; i += 1) {
        const c = string.charAt(i);
        if (isWsp(c)) {
          continue;
        }
        if (canHaveComma && c === ",") {
          if (hadComma) {
            break;
          }
          hadComma = true;
          continue;
        }
        if (isCommand(c)) {
          if (hadComma) {
            return pathData;
          }
          if (command == null) {
            if (c !== "M" && c !== "m") {
              return pathData;
            }
          } else {
            if (args.length !== 0) {
              return pathData;
            }
          }
          command = c;
          args = [];
          argsCount = argsCountPerCommand[command];
          canHaveComma = false;
          if (argsCount === 0) {
            pathData.push({ command, args });
          }
          continue;
        }
        if (command == null) {
          return pathData;
        }
        let newCursor = i;
        let number = null;
        if (command === "A" || command === "a") {
          const position = args.length;
          if (position === 0 || position === 1) {
            if (c !== "+" && c !== "-") {
              [newCursor, number] = readNumber(string, i);
            }
          }
          if (position === 2 || position === 5 || position === 6) {
            [newCursor, number] = readNumber(string, i);
          }
          if (position === 3 || position === 4) {
            if (c === "0") {
              number = 0;
            }
            if (c === "1") {
              number = 1;
            }
          }
        } else {
          [newCursor, number] = readNumber(string, i);
        }
        if (number == null) {
          return pathData;
        }
        args.push(number);
        canHaveComma = true;
        hadComma = false;
        i = newCursor;
        if (args.length === argsCount) {
          pathData.push({ command, args });
          if (command === "M") {
            command = "L";
          }
          if (command === "m") {
            command = "l";
          }
          args = [];
        }
      }
      return pathData;
    };
    exports2.parsePathData = parsePathData;
    var stringifyNumber = (number, precision) => {
      if (precision != null) {
        const ratio = 10 ** precision;
        number = Math.round(number * ratio) / ratio;
      }
      return number.toString().replace(/^0\./, ".").replace(/^-0\./, "-.");
    };
    var stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {
      let result = "";
      let prev = "";
      for (let i = 0; i < args.length; i += 1) {
        const number = args[i];
        const numberString = stringifyNumber(number, precision);
        if (disableSpaceAfterFlags && (command === "A" || command === "a") && // consider combined arcs
        (i % 7 === 4 || i % 7 === 5)) {
          result += numberString;
        } else if (i === 0 || numberString.startsWith("-")) {
          result += numberString;
        } else if (prev.includes(".") && numberString.startsWith(".")) {
          result += numberString;
        } else {
          result += ` ${numberString}`;
        }
        prev = numberString;
      }
      return result;
    };
    var stringifyPathData = ({ pathData, precision, disableSpaceAfterFlags }) => {
      let combined = [];
      for (let i = 0; i < pathData.length; i += 1) {
        const { command, args } = pathData[i];
        if (i === 0) {
          combined.push({ command, args });
        } else {
          const last = combined[combined.length - 1];
          if (i === 1) {
            if (command === "L") {
              last.command = "M";
            }
            if (command === "l") {
              last.command = "m";
            }
          }
          if (last.command === command && last.command !== "M" && last.command !== "m" || // combine matching moveto and lineto sequences
          last.command === "M" && command === "L" || last.command === "m" && command === "l") {
            last.args = [...last.args, ...args];
          } else {
            combined.push({ command, args });
          }
        }
      }
      let result = "";
      for (const { command, args } of combined) {
        result += command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);
      }
      return result;
    };
    exports2.stringifyPathData = stringifyPathData;
  }
});

// node_modules/svgo/plugins/removeHiddenElems.js
var require_removeHiddenElems = __commonJS({
  "node_modules/svgo/plugins/removeHiddenElems.js"(exports2) {
    "use strict";
    var {
      querySelector,
      closestByName,
      detachNodeFromParent
    } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var { parsePathData } = require_path();
    exports2.name = "removeHiddenElems";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "removes hidden elements (zero sized, with absent attributes)";
    exports2.fn = (root, params) => {
      const {
        isHidden = true,
        displayNone = true,
        opacity0 = true,
        circleR0 = true,
        ellipseRX0 = true,
        ellipseRY0 = true,
        rectWidth0 = true,
        rectHeight0 = true,
        patternWidth0 = true,
        patternHeight0 = true,
        imageWidth0 = true,
        imageHeight0 = true,
        pathEmptyD = true,
        polylineEmptyPoints = true,
        polygonEmptyPoints = true
      } = params;
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node, parentNode) => {
            const computedStyle = computeStyle(stylesheet, node);
            if (isHidden && computedStyle.visibility && computedStyle.visibility.type === "static" && computedStyle.visibility.value === "hidden" && // keep if any descendant enables visibility
            querySelector(node, "[visibility=visible]") == null) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (displayNone && computedStyle.display && computedStyle.display.type === "static" && computedStyle.display.value === "none" && // markers with display: none still rendered
            node.name !== "marker") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (opacity0 && computedStyle.opacity && computedStyle.opacity.type === "static" && computedStyle.opacity.value === "0" && // transparent element inside clipPath still affect clipped elements
            closestByName(node, "clipPath") == null) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (circleR0 && node.name === "circle" && node.children.length === 0 && node.attributes.r === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (ellipseRX0 && node.name === "ellipse" && node.children.length === 0 && node.attributes.rx === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (ellipseRY0 && node.name === "ellipse" && node.children.length === 0 && node.attributes.ry === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (rectWidth0 && node.name === "rect" && node.children.length === 0 && node.attributes.width === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (rectHeight0 && rectWidth0 && node.name === "rect" && node.children.length === 0 && node.attributes.height === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (patternWidth0 && node.name === "pattern" && node.attributes.width === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (patternHeight0 && node.name === "pattern" && node.attributes.height === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (imageWidth0 && node.name === "image" && node.attributes.width === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (imageHeight0 && node.name === "image" && node.attributes.height === "0") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (pathEmptyD && node.name === "path") {
              if (node.attributes.d == null) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              const pathData = parsePathData(node.attributes.d);
              if (pathData.length === 0) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              if (pathData.length === 1 && computedStyle["marker-start"] == null && computedStyle["marker-end"] == null) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              return;
            }
            if (polylineEmptyPoints && node.name === "polyline" && node.attributes.points == null) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (polygonEmptyPoints && node.name === "polygon" && node.attributes.points == null) {
              detachNodeFromParent(node, parentNode);
              return;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeEmptyText.js
var require_removeEmptyText = __commonJS({
  "node_modules/svgo/plugins/removeEmptyText.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeEmptyText";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "removes empty <text> elements";
    exports2.fn = (root, params) => {
      const { text = true, tspan = true, tref = true } = params;
      return {
        element: {
          enter: (node, parentNode) => {
            if (text && node.name === "text" && node.children.length === 0) {
              detachNodeFromParent(node, parentNode);
            }
            if (tspan && node.name === "tspan" && node.children.length === 0) {
              detachNodeFromParent(node, parentNode);
            }
            if (tref && node.name === "tref" && node.attributes["xlink:href"] == null) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertShapeToPath.js
var require_convertShapeToPath = __commonJS({
  "node_modules/svgo/plugins/convertShapeToPath.js"(exports2) {
    "use strict";
    var { stringifyPathData } = require_path();
    var { detachNodeFromParent } = require_xast();
    exports2.name = "convertShapeToPath";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "converts basic shapes to more compact path form";
    var regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
    exports2.fn = (root, params) => {
      const { convertArcs = false, floatPrecision: precision } = params;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "rect" && node.attributes.width != null && node.attributes.height != null && node.attributes.rx == null && node.attributes.ry == null) {
              const x = Number(node.attributes.x || "0");
              const y = Number(node.attributes.y || "0");
              const width = Number(node.attributes.width);
              const height = Number(node.attributes.height);
              if (Number.isNaN(x - y + width - height)) return;
              const pathData = [
                { command: "M", args: [x, y] },
                { command: "H", args: [x + width] },
                { command: "V", args: [y + height] },
                { command: "H", args: [x] },
                { command: "z", args: [] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.x;
              delete node.attributes.y;
              delete node.attributes.width;
              delete node.attributes.height;
            }
            if (node.name === "line") {
              const x1 = Number(node.attributes.x1 || "0");
              const y1 = Number(node.attributes.y1 || "0");
              const x2 = Number(node.attributes.x2 || "0");
              const y2 = Number(node.attributes.y2 || "0");
              if (Number.isNaN(x1 - y1 + x2 - y2)) return;
              const pathData = [
                { command: "M", args: [x1, y1] },
                { command: "L", args: [x2, y2] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.x1;
              delete node.attributes.y1;
              delete node.attributes.x2;
              delete node.attributes.y2;
            }
            if ((node.name === "polyline" || node.name === "polygon") && node.attributes.points != null) {
              const coords = (node.attributes.points.match(regNumber) || []).map(
                Number
              );
              if (coords.length < 4) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              const pathData = [];
              for (let i = 0; i < coords.length; i += 2) {
                pathData.push({
                  command: i === 0 ? "M" : "L",
                  args: coords.slice(i, i + 2)
                });
              }
              if (node.name === "polygon") {
                pathData.push({ command: "z", args: [] });
              }
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.points;
            }
            if (node.name === "circle" && convertArcs) {
              const cx = Number(node.attributes.cx || "0");
              const cy = Number(node.attributes.cy || "0");
              const r = Number(node.attributes.r || "0");
              if (Number.isNaN(cx - cy + r)) {
                return;
              }
              const pathData = [
                { command: "M", args: [cx, cy - r] },
                { command: "A", args: [r, r, 0, 1, 0, cx, cy + r] },
                { command: "A", args: [r, r, 0, 1, 0, cx, cy - r] },
                { command: "z", args: [] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.cx;
              delete node.attributes.cy;
              delete node.attributes.r;
            }
            if (node.name === "ellipse" && convertArcs) {
              const ecx = Number(node.attributes.cx || "0");
              const ecy = Number(node.attributes.cy || "0");
              const rx = Number(node.attributes.rx || "0");
              const ry = Number(node.attributes.ry || "0");
              if (Number.isNaN(ecx - ecy + rx - ry)) {
                return;
              }
              const pathData = [
                { command: "M", args: [ecx, ecy - ry] },
                { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
                { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
                { command: "z", args: [] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.cx;
              delete node.attributes.cy;
              delete node.attributes.rx;
              delete node.attributes.ry;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertEllipseToCircle.js
var require_convertEllipseToCircle = __commonJS({
  "node_modules/svgo/plugins/convertEllipseToCircle.js"(exports2) {
    "use strict";
    exports2.name = "convertEllipseToCircle";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "converts non-eccentric <ellipse>s to <circle>s";
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "ellipse") {
              const rx = node.attributes.rx || "0";
              const ry = node.attributes.ry || "0";
              if (rx === ry || rx === "auto" || ry === "auto") {
                node.name = "circle";
                const radius = rx === "auto" ? ry : rx;
                delete node.attributes.rx;
                delete node.attributes.ry;
                node.attributes.r = radius;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/moveElemsAttrsToGroup.js
var require_moveElemsAttrsToGroup = __commonJS({
  "node_modules/svgo/plugins/moveElemsAttrsToGroup.js"(exports2) {
    "use strict";
    var { visit } = require_xast();
    var { inheritableAttrs, pathElems } = require_collections();
    exports2.type = "visitor";
    exports2.name = "moveElemsAttrsToGroup";
    exports2.active = true;
    exports2.description = "Move common attributes of group children to the group";
    exports2.fn = (root) => {
      let deoptimizedWithStyles = false;
      visit(root, {
        element: {
          enter: (node) => {
            if (node.name === "style") {
              deoptimizedWithStyles = true;
            }
          }
        }
      });
      return {
        element: {
          exit: (node) => {
            if (node.name !== "g" || node.children.length <= 1) {
              return;
            }
            if (deoptimizedWithStyles) {
              return;
            }
            const commonAttributes = /* @__PURE__ */ new Map();
            let initial = true;
            let everyChildIsPath = true;
            for (const child of node.children) {
              if (child.type === "element") {
                if (pathElems.includes(child.name) === false) {
                  everyChildIsPath = false;
                }
                if (initial) {
                  initial = false;
                  for (const [name, value] of Object.entries(child.attributes)) {
                    if (inheritableAttrs.includes(name)) {
                      commonAttributes.set(name, value);
                    }
                  }
                } else {
                  for (const [name, value] of commonAttributes) {
                    if (child.attributes[name] !== value) {
                      commonAttributes.delete(name);
                    }
                  }
                }
              }
            }
            if (node.attributes["clip-path"] != null || node.attributes.mask != null) {
              commonAttributes.delete("transform");
            }
            if (everyChildIsPath) {
              commonAttributes.delete("transform");
            }
            for (const [name, value] of commonAttributes) {
              if (name === "transform") {
                if (node.attributes.transform != null) {
                  node.attributes.transform = `${node.attributes.transform} ${value}`;
                } else {
                  node.attributes.transform = value;
                }
              } else {
                node.attributes[name] = value;
              }
            }
            for (const child of node.children) {
              if (child.type === "element") {
                for (const [name] of commonAttributes) {
                  delete child.attributes[name];
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/moveGroupAttrsToElems.js
var require_moveGroupAttrsToElems = __commonJS({
  "node_modules/svgo/plugins/moveGroupAttrsToElems.js"(exports2) {
    "use strict";
    var { pathElems, referencesProps } = require_collections();
    exports2.name = "moveGroupAttrsToElems";
    exports2.type = "perItem";
    exports2.active = true;
    exports2.description = "moves some group attributes to the content elements";
    var pathElemsWithGroupsAndText = [...pathElems, "g", "text"];
    exports2.fn = function(item) {
      if (item.type === "element" && item.name === "g" && item.children.length !== 0 && item.attributes.transform != null && Object.entries(item.attributes).some(
        ([name, value]) => referencesProps.includes(name) && value.includes("url(")
      ) === false && item.children.every(
        (inner) => pathElemsWithGroupsAndText.includes(inner.name) && inner.attributes.id == null
      )) {
        for (const inner of item.children) {
          const value = item.attributes.transform;
          if (inner.attributes.transform != null) {
            inner.attributes.transform = value + " " + inner.attributes.transform;
          } else {
            inner.attributes.transform = value;
          }
        }
        delete item.attributes.transform;
      }
    };
  }
});

// node_modules/svgo/plugins/collapseGroups.js
var require_collapseGroups = __commonJS({
  "node_modules/svgo/plugins/collapseGroups.js"(exports2) {
    "use strict";
    var { inheritableAttrs, elemsGroups } = require_collections();
    exports2.type = "visitor";
    exports2.name = "collapseGroups";
    exports2.active = true;
    exports2.description = "collapses useless groups";
    var hasAnimatedAttr = (node, name) => {
      if (node.type === "element") {
        if (elemsGroups.animation.includes(node.name) && node.attributes.attributeName === name) {
          return true;
        }
        for (const child of node.children) {
          if (hasAnimatedAttr(child, name)) {
            return true;
          }
        }
      }
      return false;
    };
    exports2.fn = () => {
      return {
        element: {
          exit: (node, parentNode) => {
            if (parentNode.type === "root" || parentNode.name === "switch") {
              return;
            }
            if (node.name !== "g" || node.children.length === 0) {
              return;
            }
            if (Object.keys(node.attributes).length !== 0 && node.children.length === 1) {
              const firstChild = node.children[0];
              if (firstChild.type === "element" && firstChild.attributes.id == null && node.attributes.filter == null && (node.attributes.class == null || firstChild.attributes.class == null) && (node.attributes["clip-path"] == null && node.attributes.mask == null || firstChild.name === "g" && node.attributes.transform == null && firstChild.attributes.transform == null)) {
                for (const [name, value] of Object.entries(node.attributes)) {
                  if (hasAnimatedAttr(firstChild, name)) {
                    return;
                  }
                  if (firstChild.attributes[name] == null) {
                    firstChild.attributes[name] = value;
                  } else if (name === "transform") {
                    firstChild.attributes[name] = value + " " + firstChild.attributes[name];
                  } else if (firstChild.attributes[name] === "inherit") {
                    firstChild.attributes[name] = value;
                  } else if (inheritableAttrs.includes(name) === false && firstChild.attributes[name] !== value) {
                    return;
                  }
                  delete node.attributes[name];
                }
              }
            }
            if (Object.keys(node.attributes).length === 0) {
              for (const child of node.children) {
                if (child.type === "element" && elemsGroups.animation.includes(child.name)) {
                  return;
                }
              }
              const index = parentNode.children.indexOf(node);
              parentNode.children.splice(index, 1, ...node.children);
              for (const child of node.children) {
                child.parentNode = parentNode;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/_path.js
var require_path2 = __commonJS({
  "node_modules/svgo/plugins/_path.js"(exports2) {
    "use strict";
    var { parsePathData, stringifyPathData } = require_path();
    var prevCtrlPoint;
    var path2js = (path) => {
      if (path.pathJS) return path.pathJS;
      const pathData = [];
      const newPathData = parsePathData(path.attributes.d);
      for (const { command, args } of newPathData) {
        pathData.push({ command, args });
      }
      if (pathData.length && pathData[0].command == "m") {
        pathData[0].command = "M";
      }
      path.pathJS = pathData;
      return pathData;
    };
    exports2.path2js = path2js;
    var convertRelativeToAbsolute = (data) => {
      const newData = [];
      let start = [0, 0];
      let cursor = [0, 0];
      for (let { command, args } of data) {
        args = args.slice();
        if (command === "m") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          command = "M";
        }
        if (command === "M") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
        }
        if (command === "h") {
          args[0] += cursor[0];
          command = "H";
        }
        if (command === "H") {
          cursor[0] = args[0];
        }
        if (command === "v") {
          args[0] += cursor[1];
          command = "V";
        }
        if (command === "V") {
          cursor[1] = args[0];
        }
        if (command === "l") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          command = "L";
        }
        if (command === "L") {
          cursor[0] = args[0];
          cursor[1] = args[1];
        }
        if (command === "c") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          args[2] += cursor[0];
          args[3] += cursor[1];
          args[4] += cursor[0];
          args[5] += cursor[1];
          command = "C";
        }
        if (command === "C") {
          cursor[0] = args[4];
          cursor[1] = args[5];
        }
        if (command === "s") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          args[2] += cursor[0];
          args[3] += cursor[1];
          command = "S";
        }
        if (command === "S") {
          cursor[0] = args[2];
          cursor[1] = args[3];
        }
        if (command === "q") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          args[2] += cursor[0];
          args[3] += cursor[1];
          command = "Q";
        }
        if (command === "Q") {
          cursor[0] = args[2];
          cursor[1] = args[3];
        }
        if (command === "t") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          command = "T";
        }
        if (command === "T") {
          cursor[0] = args[0];
          cursor[1] = args[1];
        }
        if (command === "a") {
          args[5] += cursor[0];
          args[6] += cursor[1];
          command = "A";
        }
        if (command === "A") {
          cursor[0] = args[5];
          cursor[1] = args[6];
        }
        if (command === "z" || command === "Z") {
          cursor[0] = start[0];
          cursor[1] = start[1];
          command = "z";
        }
        newData.push({ command, args });
      }
      return newData;
    };
    exports2.js2path = function(path, data, params) {
      path.pathJS = data;
      const pathData = [];
      for (const item of data) {
        if (pathData.length !== 0 && (item.command === "M" || item.command === "m")) {
          const last = pathData[pathData.length - 1];
          if (last.command === "M" || last.command === "m") {
            pathData.pop();
          }
        }
        pathData.push({
          command: item.command,
          args: item.args
        });
      }
      path.attributes.d = stringifyPathData({
        pathData,
        precision: params.floatPrecision,
        disableSpaceAfterFlags: params.noSpaceAfterFlags
      });
    };
    function set(dest, source) {
      dest[0] = source[source.length - 2];
      dest[1] = source[source.length - 1];
      return dest;
    }
    exports2.intersects = function(path1, path2) {
      const points1 = gatherPoints(convertRelativeToAbsolute(path1));
      const points2 = gatherPoints(convertRelativeToAbsolute(path2));
      if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.list.every((set1) => {
        return points2.list.every((set2) => {
          return set1.list[set1.maxX][0] <= set2.list[set2.minX][0] || set2.list[set2.maxX][0] <= set1.list[set1.minX][0] || set1.list[set1.maxY][1] <= set2.list[set2.minY][1] || set2.list[set2.maxY][1] <= set1.list[set1.minY][1];
        });
      }))
        return false;
      const hullNest1 = points1.list.map(convexHull);
      const hullNest2 = points2.list.map(convexHull);
      return hullNest1.some(function(hull1) {
        if (hull1.list.length < 3) return false;
        return hullNest2.some(function(hull2) {
          if (hull2.list.length < 3) return false;
          var simplex = [getSupport(hull1, hull2, [1, 0])], direction = minus(simplex[0]);
          var iterations = 1e4;
          while (true) {
            if (iterations-- == 0) {
              console.error(
                "Error: infinite loop while processing mergePaths plugin."
              );
              return true;
            }
            simplex.push(getSupport(hull1, hull2, direction));
            if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;
            if (processSimplex(simplex, direction)) return true;
          }
        });
      });
      function getSupport(a, b, direction) {
        return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));
      }
      function supportPoint(polygon, direction) {
        var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY, max = -Infinity, value;
        while ((value = dot(polygon.list[index], direction)) > max) {
          max = value;
          index = ++index % polygon.list.length;
        }
        return polygon.list[(index || polygon.list.length) - 1];
      }
    };
    function processSimplex(simplex, direction) {
      if (simplex.length == 2) {
        let a = simplex[1], b = simplex[0], AO = minus(simplex[1]), AB = sub(b, a);
        if (dot(AO, AB) > 0) {
          set(direction, orth(AB, a));
        } else {
          set(direction, AO);
          simplex.shift();
        }
      } else {
        let a = simplex[2], b = simplex[1], c = simplex[0], AB = sub(b, a), AC = sub(c, a), AO = minus(a), ACB = orth(AB, AC), ABC = orth(AC, AB);
        if (dot(ACB, AO) > 0) {
          if (dot(AB, AO) > 0) {
            set(direction, ACB);
            simplex.shift();
          } else {
            set(direction, AO);
            simplex.splice(0, 2);
          }
        } else if (dot(ABC, AO) > 0) {
          if (dot(AC, AO) > 0) {
            set(direction, ABC);
            simplex.splice(1, 1);
          } else {
            set(direction, AO);
            simplex.splice(0, 2);
          }
        } else return true;
      }
      return false;
    }
    function minus(v) {
      return [-v[0], -v[1]];
    }
    function sub(v1, v2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    }
    function dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    function orth(v, from) {
      var o = [-v[1], v[0]];
      return dot(o, minus(from)) < 0 ? minus(o) : o;
    }
    function gatherPoints(pathData) {
      const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
      const addPoint = (path, point) => {
        if (!path.list.length || point[1] > path.list[path.maxY][1]) {
          path.maxY = path.list.length;
          points.maxY = points.list.length ? Math.max(point[1], points.maxY) : point[1];
        }
        if (!path.list.length || point[0] > path.list[path.maxX][0]) {
          path.maxX = path.list.length;
          points.maxX = points.list.length ? Math.max(point[0], points.maxX) : point[0];
        }
        if (!path.list.length || point[1] < path.list[path.minY][1]) {
          path.minY = path.list.length;
          points.minY = points.list.length ? Math.min(point[1], points.minY) : point[1];
        }
        if (!path.list.length || point[0] < path.list[path.minX][0]) {
          path.minX = path.list.length;
          points.minX = points.list.length ? Math.min(point[0], points.minX) : point[0];
        }
        path.list.push(point);
      };
      for (let i = 0; i < pathData.length; i += 1) {
        const pathDataItem = pathData[i];
        let subPath = points.list.length === 0 ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 } : points.list[points.list.length - 1];
        let prev = i === 0 ? null : pathData[i - 1];
        let basePoint = subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];
        let data = pathDataItem.args;
        let ctrlPoint = basePoint;
        const toAbsolute = (n, i2) => n + (basePoint == null ? 0 : basePoint[i2 % 2]);
        switch (pathDataItem.command) {
          case "M":
            subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
            points.list.push(subPath);
            break;
          case "H":
            if (basePoint != null) {
              addPoint(subPath, [data[0], basePoint[1]]);
            }
            break;
          case "V":
            if (basePoint != null) {
              addPoint(subPath, [basePoint[0], data[0]]);
            }
            break;
          case "Q":
            addPoint(subPath, data.slice(0, 2));
            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
            break;
          case "T":
            if (basePoint != null && prev != null && (prev.command == "Q" || prev.command == "T")) {
              ctrlPoint = [
                basePoint[0] + prevCtrlPoint[0],
                basePoint[1] + prevCtrlPoint[1]
              ];
              addPoint(subPath, ctrlPoint);
              prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
            }
            break;
          case "C":
            if (basePoint != null) {
              addPoint(subPath, [
                0.5 * (basePoint[0] + data[0]),
                0.5 * (basePoint[1] + data[1])
              ]);
            }
            addPoint(subPath, [
              0.5 * (data[0] + data[2]),
              0.5 * (data[1] + data[3])
            ]);
            addPoint(subPath, [
              0.5 * (data[2] + data[4]),
              0.5 * (data[3] + data[5])
            ]);
            prevCtrlPoint = [data[4] - data[2], data[5] - data[3]];
            break;
          case "S":
            if (basePoint != null && prev != null && (prev.command == "C" || prev.command == "S")) {
              addPoint(subPath, [
                basePoint[0] + 0.5 * prevCtrlPoint[0],
                basePoint[1] + 0.5 * prevCtrlPoint[1]
              ]);
              ctrlPoint = [
                basePoint[0] + prevCtrlPoint[0],
                basePoint[1] + prevCtrlPoint[1]
              ];
            }
            if (ctrlPoint != null) {
              addPoint(subPath, [
                0.5 * (ctrlPoint[0] + data[0]),
                0.5 * (ctrlPoint[1] + data[1])
              ]);
            }
            addPoint(subPath, [
              0.5 * (data[0] + data[2]),
              0.5 * (data[1] + data[3])
            ]);
            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
            break;
          case "A":
            if (basePoint != null) {
              var curves = a2c.apply(0, basePoint.concat(data));
              for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length; ) {
                if (basePoint != null) {
                  addPoint(subPath, [
                    0.5 * (basePoint[0] + cData[0]),
                    0.5 * (basePoint[1] + cData[1])
                  ]);
                }
                addPoint(subPath, [
                  0.5 * (cData[0] + cData[2]),
                  0.5 * (cData[1] + cData[3])
                ]);
                addPoint(subPath, [
                  0.5 * (cData[2] + cData[4]),
                  0.5 * (cData[3] + cData[5])
                ]);
                if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));
              }
            }
            break;
        }
        if (data.length >= 2) addPoint(subPath, data.slice(-2));
      }
      return points;
    }
    function convexHull(points) {
      points.list.sort(function(a, b) {
        return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
      });
      var lower = [], minY = 0, bottom = 0;
      for (let i = 0; i < points.list.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <= 0) {
          lower.pop();
        }
        if (points.list[i][1] < points.list[minY][1]) {
          minY = i;
          bottom = lower.length;
        }
        lower.push(points.list[i]);
      }
      var upper = [], maxY = points.list.length - 1, top = 0;
      for (let i = points.list.length; i--; ) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <= 0) {
          upper.pop();
        }
        if (points.list[i][1] > points.list[maxY][1]) {
          maxY = i;
          top = upper.length;
        }
        upper.push(points.list[i]);
      }
      upper.pop();
      lower.pop();
      const hullList = lower.concat(upper);
      const hull = {
        list: hullList,
        minX: 0,
        // by sorting
        maxX: lower.length,
        minY: bottom,
        maxY: (lower.length + top) % hullList.length
      };
      return hull;
    }
    function cross(o, a, b) {
      return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
    }
    var a2c = (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) => {
      const _120 = Math.PI * 120 / 180;
      const rad = Math.PI / 180 * (+angle || 0);
      let res = [];
      const rotateX = (x3, y3, rad2) => {
        return x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
      };
      const rotateY = (x3, y3, rad2) => {
        return x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
      };
      if (!recursive) {
        x1 = rotateX(x1, y1, -rad);
        y1 = rotateY(x1, y1, -rad);
        x2 = rotateX(x2, y2, -rad);
        y2 = rotateY(x2, y2, -rad);
        var x = (x1 - x2) / 2, y = (y1 - y2) / 2;
        var h = x * x / (rx * rx) + y * y / (ry * ry);
        if (h > 1) {
          h = Math.sqrt(h);
          rx = h * rx;
          ry = h * ry;
        }
        var rx2 = rx * rx;
        var ry2 = ry * ry;
        var k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(
          Math.abs(
            (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)
          )
        );
        var cx = k * rx * y / ry + (x1 + x2) / 2;
        var cy = k * -ry * x / rx + (y1 + y2) / 2;
        var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
        var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));
        f1 = x1 < cx ? Math.PI - f1 : f1;
        f2 = x2 < cx ? Math.PI - f2 : f2;
        f1 < 0 && (f1 = Math.PI * 2 + f1);
        f2 < 0 && (f2 = Math.PI * 2 + f2);
        if (sweep_flag && f1 > f2) {
          f1 = f1 - Math.PI * 2;
        }
        if (!sweep_flag && f2 > f1) {
          f2 = f2 - Math.PI * 2;
        }
      } else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
      }
      var df = f2 - f1;
      if (Math.abs(df) > _120) {
        var f2old = f2, x2old = x2, y2old = y2;
        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * Math.cos(f2);
        y2 = cy + ry * Math.sin(f2);
        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
          f2,
          f2old,
          cx,
          cy
        ]);
      }
      df = f2 - f1;
      var c1 = Math.cos(f1), s1 = Math.sin(f1), c2 = Math.cos(f2), s2 = Math.sin(f2), t = Math.tan(df / 4), hx = 4 / 3 * rx * t, hy = 4 / 3 * ry * t, m = [
        -hx * s1,
        hy * c1,
        x2 + hx * s2 - x1,
        y2 - hy * c2 - y1,
        x2 - x1,
        y2 - y1
      ];
      if (recursive) {
        return m.concat(res);
      } else {
        res = m.concat(res);
        var newres = [];
        for (var i = 0, n = res.length; i < n; i++) {
          newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);
        }
        return newres;
      }
    };
  }
});

// node_modules/svgo/plugins/_transforms.js
var require_transforms = __commonJS({
  "node_modules/svgo/plugins/_transforms.js"(exports2) {
    "use strict";
    var regTransformTypes = /matrix|translate|scale|rotate|skewX|skewY/;
    var regTransformSplit = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
    var regNumericValues = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
    exports2.transform2js = (transformString) => {
      const transforms = [];
      let current = null;
      for (const item of transformString.split(regTransformSplit)) {
        var num;
        if (item) {
          if (regTransformTypes.test(item)) {
            current = { name: item, data: [] };
            transforms.push(current);
          } else {
            while (num = regNumericValues.exec(item)) {
              num = Number(num);
              if (current != null) {
                current.data.push(num);
              }
            }
          }
        }
      }
      return current == null || current.data.length == 0 ? [] : transforms;
    };
    exports2.transformsMultiply = (transforms) => {
      const matrixData = transforms.map((transform) => {
        if (transform.name === "matrix") {
          return transform.data;
        }
        return transformToMatrix(transform);
      });
      const matrixTransform = {
        name: "matrix",
        data: matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : []
      };
      return matrixTransform;
    };
    var mth = {
      /**
       * @type {(deg: number) => number}
       */
      rad: (deg) => {
        return deg * Math.PI / 180;
      },
      /**
       * @type {(rad: number) => number}
       */
      deg: (rad) => {
        return rad * 180 / Math.PI;
      },
      /**
       * @type {(deg: number) => number}
       */
      cos: (deg) => {
        return Math.cos(mth.rad(deg));
      },
      /**
       * @type {(val: number, floatPrecision: number) => number}
       */
      acos: (val, floatPrecision) => {
        return Number(mth.deg(Math.acos(val)).toFixed(floatPrecision));
      },
      /**
       * @type {(deg: number) => number}
       */
      sin: (deg) => {
        return Math.sin(mth.rad(deg));
      },
      /**
       * @type {(val: number, floatPrecision: number) => number}
       */
      asin: (val, floatPrecision) => {
        return Number(mth.deg(Math.asin(val)).toFixed(floatPrecision));
      },
      /**
       * @type {(deg: number) => number}
       */
      tan: (deg) => {
        return Math.tan(mth.rad(deg));
      },
      /**
       * @type {(val: number, floatPrecision: number) => number}
       */
      atan: (val, floatPrecision) => {
        return Number(mth.deg(Math.atan(val)).toFixed(floatPrecision));
      }
    };
    exports2.matrixToTransform = (transform, params) => {
      let floatPrecision = params.floatPrecision;
      let data = transform.data;
      let transforms = [];
      let sx = Number(
        Math.hypot(data[0], data[1]).toFixed(params.transformPrecision)
      );
      let sy = Number(
        ((data[0] * data[3] - data[1] * data[2]) / sx).toFixed(
          params.transformPrecision
        )
      );
      let colsSum = data[0] * data[2] + data[1] * data[3];
      let rowsSum = data[0] * data[1] + data[2] * data[3];
      let scaleBefore = rowsSum != 0 || sx == sy;
      if (data[4] || data[5]) {
        transforms.push({
          name: "translate",
          data: data.slice(4, data[5] ? 6 : 5)
        });
      }
      if (!data[1] && data[2]) {
        transforms.push({
          name: "skewX",
          data: [mth.atan(data[2] / sy, floatPrecision)]
        });
      } else if (data[1] && !data[2]) {
        transforms.push({
          name: "skewY",
          data: [mth.atan(data[1] / data[0], floatPrecision)]
        });
        sx = data[0];
        sy = data[3];
      } else if (!colsSum || sx == 1 && sy == 1 || !scaleBefore) {
        if (!scaleBefore) {
          sx = (data[0] < 0 ? -1 : 1) * Math.hypot(data[0], data[2]);
          sy = (data[3] < 0 ? -1 : 1) * Math.hypot(data[1], data[3]);
          transforms.push({ name: "scale", data: [sx, sy] });
        }
        var angle = Math.min(Math.max(-1, data[0] / sx), 1), rotate = [
          mth.acos(angle, floatPrecision) * ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1)
        ];
        if (rotate[0]) transforms.push({ name: "rotate", data: rotate });
        if (rowsSum && colsSum)
          transforms.push({
            name: "skewX",
            data: [mth.atan(colsSum / (sx * sx), floatPrecision)]
          });
        if (rotate[0] && (data[4] || data[5])) {
          transforms.shift();
          var cos = data[0] / sx, sin = data[1] / (scaleBefore ? sx : sy), x = data[4] * (scaleBefore ? 1 : sy), y = data[5] * (scaleBefore ? 1 : sx), denom = (Math.pow(1 - cos, 2) + Math.pow(sin, 2)) * (scaleBefore ? 1 : sx * sy);
          rotate.push(((1 - cos) * x - sin * y) / denom);
          rotate.push(((1 - cos) * y + sin * x) / denom);
        }
      } else if (data[1] || data[2]) {
        return [transform];
      }
      if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length)
        transforms.push({
          name: "scale",
          data: sx == sy ? [sx] : [sx, sy]
        });
      return transforms;
    };
    var transformToMatrix = (transform) => {
      if (transform.name === "matrix") {
        return transform.data;
      }
      switch (transform.name) {
        case "translate":
          return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
        case "scale":
          return [
            transform.data[0],
            0,
            0,
            transform.data[1] || transform.data[0],
            0,
            0
          ];
        case "rotate":
          var cos = mth.cos(transform.data[0]), sin = mth.sin(transform.data[0]), cx = transform.data[1] || 0, cy = transform.data[2] || 0;
          return [
            cos,
            sin,
            -sin,
            cos,
            (1 - cos) * cx + sin * cy,
            (1 - cos) * cy - sin * cx
          ];
        case "skewX":
          return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
        case "skewY":
          return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
        default:
          throw Error(`Unknown transform ${transform.name}`);
      }
    };
    exports2.transformArc = (cursor, arc, transform) => {
      const x = arc[5] - cursor[0];
      const y = arc[6] - cursor[1];
      let a = arc[0];
      let b = arc[1];
      const rot = arc[2] * Math.PI / 180;
      const cos = Math.cos(rot);
      const sin = Math.sin(rot);
      if (a > 0 && b > 0) {
        let h = Math.pow(x * cos + y * sin, 2) / (4 * a * a) + Math.pow(y * cos - x * sin, 2) / (4 * b * b);
        if (h > 1) {
          h = Math.sqrt(h);
          a *= h;
          b *= h;
        }
      }
      const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];
      const m = multiplyTransformMatrices(transform, ellipse);
      const lastCol = m[2] * m[2] + m[3] * m[3];
      const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;
      const root = Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);
      if (!root) {
        arc[0] = arc[1] = Math.sqrt(squareSum / 2);
        arc[2] = 0;
      } else {
        const majorAxisSqr = (squareSum + root) / 2;
        const minorAxisSqr = (squareSum - root) / 2;
        const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;
        const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
        const rowsSum = m[0] * m[2] + m[1] * m[3];
        const term1 = m[0] * sub + m[2] * rowsSum;
        const term2 = m[1] * sub + m[3] * rowsSum;
        arc[0] = Math.sqrt(majorAxisSqr);
        arc[1] = Math.sqrt(minorAxisSqr);
        arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) * 180 / Math.PI;
      }
      if (transform[0] < 0 !== transform[3] < 0) {
        arc[4] = 1 - arc[4];
      }
      return arc;
    };
    var multiplyTransformMatrices = (a, b) => {
      return [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5]
      ];
    };
  }
});

// node_modules/svgo/plugins/_applyTransforms.js
var require_applyTransforms = __commonJS({
  "node_modules/svgo/plugins/_applyTransforms.js"(exports2) {
    "use strict";
    var {
      transformsMultiply,
      transform2js,
      transformArc
    } = require_transforms();
    var { removeLeadingZero } = require_tools();
    var { referencesProps, attrsGroupsDefaults } = require_collections();
    var regNumericValues = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
    var defaultStrokeWidth = attrsGroupsDefaults.presentation["stroke-width"];
    var applyTransforms = (elem, pathData, params) => {
      if (elem.attributes.transform == null || elem.attributes.transform === "" || // styles are not considered when applying transform
      // can be fixed properly with new style engine
      elem.attributes.style != null || Object.entries(elem.attributes).some(
        ([name, value]) => referencesProps.includes(name) && value.includes("url(")
      )) {
        return;
      }
      const matrix = transformsMultiply(transform2js(elem.attributes.transform));
      const stroke = elem.computedAttr("stroke");
      const id = elem.computedAttr("id");
      const transformPrecision = params.transformPrecision;
      if (stroke && stroke != "none") {
        if (!params.applyTransformsStroked || (matrix.data[0] != matrix.data[3] || matrix.data[1] != -matrix.data[2]) && (matrix.data[0] != -matrix.data[3] || matrix.data[1] != matrix.data[2]))
          return;
        if (id) {
          let idElem = elem;
          let hasStrokeWidth = false;
          do {
            if (idElem.attributes["stroke-width"]) {
              hasStrokeWidth = true;
            }
          } while (idElem.attributes.id !== id && !hasStrokeWidth && (idElem = idElem.parentNode));
          if (!hasStrokeWidth) return;
        }
        const scale = +Math.sqrt(
          matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]
        ).toFixed(transformPrecision);
        if (scale !== 1) {
          const strokeWidth = elem.computedAttr("stroke-width") || defaultStrokeWidth;
          if (elem.attributes["vector-effect"] == null || elem.attributes["vector-effect"] !== "non-scaling-stroke") {
            if (elem.attributes["stroke-width"] != null) {
              elem.attributes["stroke-width"] = elem.attributes["stroke-width"].trim().replace(regNumericValues, (num) => removeLeadingZero(num * scale));
            } else {
              elem.attributes["stroke-width"] = strokeWidth.replace(
                regNumericValues,
                (num) => removeLeadingZero(num * scale)
              );
            }
            if (elem.attributes["stroke-dashoffset"] != null) {
              elem.attributes["stroke-dashoffset"] = elem.attributes["stroke-dashoffset"].trim().replace(regNumericValues, (num) => removeLeadingZero(num * scale));
            }
            if (elem.attributes["stroke-dasharray"] != null) {
              elem.attributes["stroke-dasharray"] = elem.attributes["stroke-dasharray"].trim().replace(regNumericValues, (num) => removeLeadingZero(num * scale));
            }
          }
        }
      } else if (id) {
        return;
      }
      applyMatrixToPathData(pathData, matrix.data);
      delete elem.attributes.transform;
      return;
    };
    exports2.applyTransforms = applyTransforms;
    var transformAbsolutePoint = (matrix, x, y) => {
      const newX = matrix[0] * x + matrix[2] * y + matrix[4];
      const newY = matrix[1] * x + matrix[3] * y + matrix[5];
      return [newX, newY];
    };
    var transformRelativePoint = (matrix, x, y) => {
      const newX = matrix[0] * x + matrix[2] * y;
      const newY = matrix[1] * x + matrix[3] * y;
      return [newX, newY];
    };
    var applyMatrixToPathData = (pathData, matrix) => {
      const start = [0, 0];
      const cursor = [0, 0];
      for (const pathItem of pathData) {
        let { command, args } = pathItem;
        if (command === "M") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
          const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "m") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
          const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "H") {
          command = "L";
          args = [args[0], cursor[1]];
        }
        if (command === "h") {
          command = "l";
          args = [args[0], 0];
        }
        if (command === "V") {
          command = "L";
          args = [cursor[0], args[0]];
        }
        if (command === "v") {
          command = "l";
          args = [0, args[0]];
        }
        if (command === "L") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "l") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "C") {
          cursor[0] = args[4];
          cursor[1] = args[5];
          const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
          const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
          const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x2;
          args[3] = y2;
          args[4] = x;
          args[5] = y;
        }
        if (command === "c") {
          cursor[0] += args[4];
          cursor[1] += args[5];
          const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
          const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
          const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x2;
          args[3] = y2;
          args[4] = x;
          args[5] = y;
        }
        if (command === "S") {
          cursor[0] = args[2];
          cursor[1] = args[3];
          const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
          const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
          args[0] = x2;
          args[1] = y2;
          args[2] = x;
          args[3] = y;
        }
        if (command === "s") {
          cursor[0] += args[2];
          cursor[1] += args[3];
          const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
          const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
          args[0] = x2;
          args[1] = y2;
          args[2] = x;
          args[3] = y;
        }
        if (command === "Q") {
          cursor[0] = args[2];
          cursor[1] = args[3];
          const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
          const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x;
          args[3] = y;
        }
        if (command === "q") {
          cursor[0] += args[2];
          cursor[1] += args[3];
          const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
          const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x;
          args[3] = y;
        }
        if (command === "T") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "t") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "A") {
          transformArc(cursor, args, matrix);
          cursor[0] = args[5];
          cursor[1] = args[6];
          if (Math.abs(args[2]) > 80) {
            const a = args[0];
            const rotation = args[2];
            args[0] = args[1];
            args[1] = a;
            args[2] = rotation + (rotation > 0 ? -90 : 90);
          }
          const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
          args[5] = x;
          args[6] = y;
        }
        if (command === "a") {
          transformArc([0, 0], args, matrix);
          cursor[0] += args[5];
          cursor[1] += args[6];
          if (Math.abs(args[2]) > 80) {
            const a = args[0];
            const rotation = args[2];
            args[0] = args[1];
            args[1] = a;
            args[2] = rotation + (rotation > 0 ? -90 : 90);
          }
          const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
          args[5] = x;
          args[6] = y;
        }
        if (command === "z" || command === "Z") {
          cursor[0] = start[0];
          cursor[1] = start[1];
        }
        pathItem.command = command;
        pathItem.args = args;
      }
    };
  }
});

// node_modules/svgo/plugins/convertPathData.js
var require_convertPathData = __commonJS({
  "node_modules/svgo/plugins/convertPathData.js"(exports2) {
    "use strict";
    var { collectStylesheet, computeStyle } = require_style();
    var { pathElems } = require_collections();
    var { path2js, js2path } = require_path2();
    var { applyTransforms } = require_applyTransforms();
    var { cleanupOutData } = require_tools();
    exports2.name = "convertPathData";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "optimizes path data: writes in shorter form, applies transformations";
    exports2.params = {
      applyTransforms: true,
      applyTransformsStroked: true,
      makeArcs: {
        threshold: 2.5,
        // coefficient of rounding error
        tolerance: 0.5
        // percentage of radius
      },
      straightCurves: true,
      lineShorthands: true,
      curveSmoothShorthands: true,
      floatPrecision: 3,
      transformPrecision: 5,
      removeUseless: true,
      collapseRepeated: true,
      utilizeAbsolute: true,
      leadingZero: true,
      negativeExtraSpace: true,
      noSpaceAfterFlags: false,
      // a20 60 45 0 1 30 20 → a20 60 45 0130 20
      forceAbsolutePath: false
    };
    var roundData;
    var precision;
    var error;
    var arcThreshold;
    var arcTolerance;
    exports2.fn = (root, params) => {
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node) => {
            if (pathElems.includes(node.name) && node.attributes.d != null) {
              const computedStyle = computeStyle(stylesheet, node);
              precision = params.floatPrecision;
              error = precision !== false ? +Math.pow(0.1, precision).toFixed(precision) : 0.01;
              roundData = precision > 0 && precision < 20 ? strongRound : round;
              if (params.makeArcs) {
                arcThreshold = params.makeArcs.threshold;
                arcTolerance = params.makeArcs.tolerance;
              }
              const hasMarkerMid = computedStyle["marker-mid"] != null;
              const maybeHasStroke = computedStyle.stroke && (computedStyle.stroke.type === "dynamic" || computedStyle.stroke.value !== "none");
              const maybeHasLinecap = computedStyle["stroke-linecap"] && (computedStyle["stroke-linecap"].type === "dynamic" || computedStyle["stroke-linecap"].value !== "butt");
              const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;
              var data = path2js(node);
              if (data.length) {
                if (params.applyTransforms) {
                  applyTransforms(node, data, params);
                }
                convertToRelative(data);
                data = filters(data, params, {
                  maybeHasStrokeAndLinecap,
                  hasMarkerMid
                });
                if (params.utilizeAbsolute) {
                  data = convertToMixed(data, params);
                }
                js2path(node, data, params);
              }
            }
          }
        }
      };
    };
    var convertToRelative = (pathData) => {
      let start = [0, 0];
      let cursor = [0, 0];
      let prevCoords = [0, 0];
      for (let i = 0; i < pathData.length; i += 1) {
        const pathItem = pathData[i];
        let { command, args } = pathItem;
        if (command === "m") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
        }
        if (command === "M") {
          if (i !== 0) {
            command = "m";
          }
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          cursor[0] += args[0];
          cursor[1] += args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
        }
        if (command === "l") {
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "L") {
          command = "l";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "h") {
          cursor[0] += args[0];
        }
        if (command === "H") {
          command = "h";
          args[0] -= cursor[0];
          cursor[0] += args[0];
        }
        if (command === "v") {
          cursor[1] += args[0];
        }
        if (command === "V") {
          command = "v";
          args[0] -= cursor[1];
          cursor[1] += args[0];
        }
        if (command === "c") {
          cursor[0] += args[4];
          cursor[1] += args[5];
        }
        if (command === "C") {
          command = "c";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          args[2] -= cursor[0];
          args[3] -= cursor[1];
          args[4] -= cursor[0];
          args[5] -= cursor[1];
          cursor[0] += args[4];
          cursor[1] += args[5];
        }
        if (command === "s") {
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "S") {
          command = "s";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          args[2] -= cursor[0];
          args[3] -= cursor[1];
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "q") {
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "Q") {
          command = "q";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          args[2] -= cursor[0];
          args[3] -= cursor[1];
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "t") {
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "T") {
          command = "t";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "a") {
          cursor[0] += args[5];
          cursor[1] += args[6];
        }
        if (command === "A") {
          command = "a";
          args[5] -= cursor[0];
          args[6] -= cursor[1];
          cursor[0] += args[5];
          cursor[1] += args[6];
        }
        if (command === "Z" || command === "z") {
          cursor[0] = start[0];
          cursor[1] = start[1];
        }
        pathItem.command = command;
        pathItem.args = args;
        pathItem.base = prevCoords;
        pathItem.coords = [cursor[0], cursor[1]];
        prevCoords = pathItem.coords;
      }
      return pathData;
    };
    function filters(path, params, { maybeHasStrokeAndLinecap, hasMarkerMid }) {
      var stringify = data2Path.bind(null, params), relSubpoint = [0, 0], pathBase = [0, 0], prev = {};
      path = path.filter(function(item, index, path2) {
        let command = item.command;
        let data = item.args;
        let next = path2[index + 1];
        if (command !== "Z" && command !== "z") {
          var sdata = data, circle;
          if (command === "s") {
            sdata = [0, 0].concat(data);
            if (command === "c" || command === "s") {
              var pdata = prev.args, n = pdata.length;
              sdata[0] = pdata[n - 2] - pdata[n - 4];
              sdata[1] = pdata[n - 1] - pdata[n - 3];
            }
          }
          if (params.makeArcs && (command == "c" || command == "s") && isConvex(sdata) && (circle = findCircle(sdata))) {
            var r = roundData([circle.radius])[0], angle = findArcAngle(sdata, circle), sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0, arc = {
              command: "a",
              args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
              coords: item.coords.slice(),
              base: item.base
            }, output = [arc], relCenter = [
              circle.center[0] - sdata[4],
              circle.center[1] - sdata[5]
            ], relCircle = { center: relCenter, radius: circle.radius }, arcCurves = [item], hasPrev = 0, suffix = "", nextLonghand;
            if (prev.command == "c" && isConvex(prev.args) && isArcPrev(prev.args, circle) || prev.command == "a" && prev.sdata && isArcPrev(prev.sdata, circle)) {
              arcCurves.unshift(prev);
              arc.base = prev.base;
              arc.args[5] = arc.coords[0] - arc.base[0];
              arc.args[6] = arc.coords[1] - arc.base[1];
              var prevData = prev.command == "a" ? prev.sdata : prev.args;
              var prevAngle = findArcAngle(prevData, {
                center: [
                  prevData[4] + circle.center[0],
                  prevData[5] + circle.center[1]
                ],
                radius: circle.radius
              });
              angle += prevAngle;
              if (angle > Math.PI) arc.args[3] = 1;
              hasPrev = 1;
            }
            for (var j = index; (next = path2[++j]) && ~"cs".indexOf(next.command); ) {
              var nextData = next.args;
              if (next.command == "s") {
                nextLonghand = makeLonghand(
                  { command: "s", args: next.args.slice() },
                  path2[j - 1].args
                );
                nextData = nextLonghand.args;
                nextLonghand.args = nextData.slice(0, 2);
                suffix = stringify([nextLonghand]);
              }
              if (isConvex(nextData) && isArc(nextData, relCircle)) {
                angle += findArcAngle(nextData, relCircle);
                if (angle - 2 * Math.PI > 1e-3) break;
                if (angle > Math.PI) arc.args[3] = 1;
                arcCurves.push(next);
                if (2 * Math.PI - angle > 1e-3) {
                  arc.coords = next.coords;
                  arc.args[5] = arc.coords[0] - arc.base[0];
                  arc.args[6] = arc.coords[1] - arc.base[1];
                } else {
                  arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
                  arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
                  arc.coords = [
                    arc.base[0] + arc.args[5],
                    arc.base[1] + arc.args[6]
                  ];
                  arc = {
                    command: "a",
                    args: [
                      r,
                      r,
                      0,
                      0,
                      sweep,
                      next.coords[0] - arc.coords[0],
                      next.coords[1] - arc.coords[1]
                    ],
                    coords: next.coords,
                    base: arc.coords
                  };
                  output.push(arc);
                  j++;
                  break;
                }
                relCenter[0] -= nextData[4];
                relCenter[1] -= nextData[5];
              } else break;
            }
            if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
              if (path2[j] && path2[j].command == "s") {
                makeLonghand(path2[j], path2[j - 1].args);
              }
              if (hasPrev) {
                var prevArc = output.shift();
                roundData(prevArc.args);
                relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];
                relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];
                prev.command = "a";
                prev.args = prevArc.args;
                item.base = prev.coords = prevArc.coords;
              }
              arc = output.shift();
              if (arcCurves.length == 1) {
                item.sdata = sdata.slice();
              } else if (arcCurves.length - 1 - hasPrev > 0) {
                path2.splice.apply(
                  path2,
                  [index + 1, arcCurves.length - 1 - hasPrev].concat(output)
                );
              }
              if (!arc) return false;
              command = "a";
              data = arc.args;
              item.coords = arc.coords;
            }
          }
          if (precision !== false) {
            if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
              for (var i = data.length; i--; ) {
                data[i] += item.base[i % 2] - relSubpoint[i % 2];
              }
            } else if (command == "h") {
              data[0] += item.base[0] - relSubpoint[0];
            } else if (command == "v") {
              data[0] += item.base[1] - relSubpoint[1];
            } else if (command == "a") {
              data[5] += item.base[0] - relSubpoint[0];
              data[6] += item.base[1] - relSubpoint[1];
            }
            roundData(data);
            if (command == "h") relSubpoint[0] += data[0];
            else if (command == "v") relSubpoint[1] += data[0];
            else {
              relSubpoint[0] += data[data.length - 2];
              relSubpoint[1] += data[data.length - 1];
            }
            roundData(relSubpoint);
            if (command === "M" || command === "m") {
              pathBase[0] = relSubpoint[0];
              pathBase[1] = relSubpoint[1];
            }
          }
          if (params.straightCurves) {
            if (command === "c" && isCurveStraightLine(data) || command === "s" && isCurveStraightLine(sdata)) {
              if (next && next.command == "s") makeLonghand(next, data);
              command = "l";
              data = data.slice(-2);
            } else if (command === "q" && isCurveStraightLine(data)) {
              if (next && next.command == "t") makeLonghand(next, data);
              command = "l";
              data = data.slice(-2);
            } else if (command === "t" && prev.command !== "q" && prev.command !== "t") {
              command = "l";
              data = data.slice(-2);
            } else if (command === "a" && (data[0] === 0 || data[1] === 0)) {
              command = "l";
              data = data.slice(-2);
            }
          }
          if (params.lineShorthands && command === "l") {
            if (data[1] === 0) {
              command = "h";
              data.pop();
            } else if (data[0] === 0) {
              command = "v";
              data.shift();
            }
          }
          if (params.collapseRepeated && hasMarkerMid === false && (command === "m" || command === "h" || command === "v") && prev.command && command == prev.command.toLowerCase() && (command != "h" && command != "v" || prev.args[0] >= 0 == data[0] >= 0)) {
            prev.args[0] += data[0];
            if (command != "h" && command != "v") {
              prev.args[1] += data[1];
            }
            prev.coords = item.coords;
            path2[index] = prev;
            return false;
          }
          if (params.curveSmoothShorthands && prev.command) {
            if (command === "c") {
              if (prev.command === "c" && data[0] === -(prev.args[2] - prev.args[4]) && data[1] === -(prev.args[3] - prev.args[5])) {
                command = "s";
                data = data.slice(2);
              } else if (prev.command === "s" && data[0] === -(prev.args[0] - prev.args[2]) && data[1] === -(prev.args[1] - prev.args[3])) {
                command = "s";
                data = data.slice(2);
              } else if (prev.command !== "c" && prev.command !== "s" && data[0] === 0 && data[1] === 0) {
                command = "s";
                data = data.slice(2);
              }
            } else if (command === "q") {
              if (prev.command === "q" && data[0] === prev.args[2] - prev.args[0] && data[1] === prev.args[3] - prev.args[1]) {
                command = "t";
                data = data.slice(2);
              } else if (prev.command === "t" && data[2] === prev.args[0] && data[3] === prev.args[1]) {
                command = "t";
                data = data.slice(2);
              }
            }
          }
          if (params.removeUseless && !maybeHasStrokeAndLinecap) {
            if ((command === "l" || command === "h" || command === "v" || command === "q" || command === "t" || command === "c" || command === "s") && data.every(function(i2) {
              return i2 === 0;
            })) {
              path2[index] = prev;
              return false;
            }
            if (command === "a" && data[5] === 0 && data[6] === 0) {
              path2[index] = prev;
              return false;
            }
          }
          item.command = command;
          item.args = data;
          prev = item;
        } else {
          relSubpoint[0] = pathBase[0];
          relSubpoint[1] = pathBase[1];
          if (prev.command === "Z" || prev.command === "z") return false;
          prev = item;
        }
        return true;
      });
      return path;
    }
    function convertToMixed(path, params) {
      var prev = path[0];
      path = path.filter(function(item, index) {
        if (index == 0) return true;
        if (item.command === "Z" || item.command === "z") {
          prev = item;
          return true;
        }
        var command = item.command, data = item.args, adata = data.slice();
        if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
          for (var i = adata.length; i--; ) {
            adata[i] += item.base[i % 2];
          }
        } else if (command == "h") {
          adata[0] += item.base[0];
        } else if (command == "v") {
          adata[0] += item.base[1];
        } else if (command == "a") {
          adata[5] += item.base[0];
          adata[6] += item.base[1];
        }
        roundData(adata);
        var absoluteDataStr = cleanupOutData(adata, params), relativeDataStr = cleanupOutData(data, params);
        if (params.forceAbsolutePath || absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && command == prev.command && prev.command.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || /^0\./.test(data[0]) && prev.args[prev.args.length - 1] % 1))) {
          item.command = command.toUpperCase();
          item.args = adata;
        }
        prev = item;
        return true;
      });
      return path;
    }
    function isConvex(data) {
      var center = getIntersection([
        0,
        0,
        data[2],
        data[3],
        data[0],
        data[1],
        data[4],
        data[5]
      ]);
      return center && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];
    }
    function getIntersection(coords) {
      var a1 = coords[1] - coords[3], b1 = coords[2] - coords[0], c1 = coords[0] * coords[3] - coords[2] * coords[1], a2 = coords[5] - coords[7], b2 = coords[6] - coords[4], c2 = coords[4] * coords[7] - coords[5] * coords[6], denom = a1 * b2 - a2 * b1;
      if (!denom) return;
      var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
      if (!isNaN(cross[0]) && !isNaN(cross[1]) && isFinite(cross[0]) && isFinite(cross[1])) {
        return cross;
      }
    }
    function strongRound(data) {
      for (var i = data.length; i-- > 0; ) {
        if (data[i].toFixed(precision) != data[i]) {
          var rounded = +data[i].toFixed(precision - 1);
          data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= error ? +data[i].toFixed(precision) : rounded;
        }
      }
      return data;
    }
    function round(data) {
      for (var i = data.length; i-- > 0; ) {
        data[i] = Math.round(data[i]);
      }
      return data;
    }
    function isCurveStraightLine(data) {
      var i = data.length - 2, a = -data[i + 1], b = data[i], d = 1 / (a * a + b * b);
      if (i <= 1 || !isFinite(d)) return false;
      while ((i -= 2) >= 0) {
        if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
          return false;
      }
      return true;
    }
    function makeLonghand(item, data) {
      switch (item.command) {
        case "s":
          item.command = "c";
          break;
        case "t":
          item.command = "q";
          break;
      }
      item.args.unshift(
        data[data.length - 2] - data[data.length - 4],
        data[data.length - 1] - data[data.length - 3]
      );
      return item;
    }
    function getDistance(point1, point2) {
      return Math.hypot(point1[0] - point2[0], point1[1] - point2[1]);
    }
    function getCubicBezierPoint(curve, t) {
      var sqrT = t * t, cubT = sqrT * t, mt = 1 - t, sqrMt = mt * mt;
      return [
        3 * sqrMt * t * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
        3 * sqrMt * t * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]
      ];
    }
    function findCircle(curve) {
      var midPoint = getCubicBezierPoint(curve, 1 / 2), m1 = [midPoint[0] / 2, midPoint[1] / 2], m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2], center = getIntersection([
        m1[0],
        m1[1],
        m1[0] + m1[1],
        m1[1] - m1[0],
        m2[0],
        m2[1],
        m2[0] + (m2[1] - midPoint[1]),
        m2[1] - (m2[0] - midPoint[0])
      ]), radius = center && getDistance([0, 0], center), tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);
      if (center && radius < 1e15 && [1 / 4, 3 / 4].every(function(point) {
        return Math.abs(
          getDistance(getCubicBezierPoint(curve, point), center) - radius
        ) <= tolerance;
      }))
        return { center, radius };
    }
    function isArc(curve, circle) {
      var tolerance = Math.min(
        arcThreshold * error,
        arcTolerance * circle.radius / 100
      );
      return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function(point) {
        return Math.abs(
          getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius
        ) <= tolerance;
      });
    }
    function isArcPrev(curve, circle) {
      return isArc(curve, {
        center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
        radius: circle.radius
      });
    }
    function findArcAngle(curve, relCircle) {
      var x1 = -relCircle.center[0], y1 = -relCircle.center[1], x2 = curve[4] - relCircle.center[0], y2 = curve[5] - relCircle.center[1];
      return Math.acos(
        (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
      );
    }
    function data2Path(params, pathData) {
      return pathData.reduce(function(pathString, item) {
        var strData = "";
        if (item.args) {
          strData = cleanupOutData(roundData(item.args.slice()), params);
        }
        return pathString + item.command + strData;
      }, "");
    }
  }
});

// node_modules/svgo/plugins/convertTransform.js
var require_convertTransform = __commonJS({
  "node_modules/svgo/plugins/convertTransform.js"(exports2) {
    "use strict";
    var { cleanupOutData } = require_tools();
    var {
      transform2js,
      transformsMultiply,
      matrixToTransform
    } = require_transforms();
    exports2.type = "visitor";
    exports2.name = "convertTransform";
    exports2.active = true;
    exports2.description = "collapses multiple transformations and optimizes it";
    exports2.fn = (_root, params) => {
      const {
        convertToShorts: convertToShorts2 = true,
        // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default
        degPrecision,
        floatPrecision = 3,
        transformPrecision = 5,
        matrixToTransform: matrixToTransform2 = true,
        shortTranslate = true,
        shortScale = true,
        shortRotate = true,
        removeUseless: removeUseless2 = true,
        collapseIntoOne = true,
        leadingZero = true,
        negativeExtraSpace = false
      } = params;
      const newParams = {
        convertToShorts: convertToShorts2,
        degPrecision,
        floatPrecision,
        transformPrecision,
        matrixToTransform: matrixToTransform2,
        shortTranslate,
        shortScale,
        shortRotate,
        removeUseless: removeUseless2,
        collapseIntoOne,
        leadingZero,
        negativeExtraSpace
      };
      return {
        element: {
          enter: (node) => {
            if (node.attributes.transform != null) {
              convertTransform(node, "transform", newParams);
            }
            if (node.attributes.gradientTransform != null) {
              convertTransform(node, "gradientTransform", newParams);
            }
            if (node.attributes.patternTransform != null) {
              convertTransform(node, "patternTransform", newParams);
            }
          }
        }
      };
    };
    var convertTransform = (item, attrName, params) => {
      let data = transform2js(item.attributes[attrName]);
      params = definePrecision(data, params);
      if (params.collapseIntoOne && data.length > 1) {
        data = [transformsMultiply(data)];
      }
      if (params.convertToShorts) {
        data = convertToShorts(data, params);
      } else {
        data.forEach((item2) => roundTransform(item2, params));
      }
      if (params.removeUseless) {
        data = removeUseless(data);
      }
      if (data.length) {
        item.attributes[attrName] = js2transform(data, params);
      } else {
        delete item.attributes[attrName];
      }
    };
    var definePrecision = (data, { ...newParams }) => {
      const matrixData = [];
      for (const item of data) {
        if (item.name == "matrix") {
          matrixData.push(...item.data.slice(0, 4));
        }
      }
      let significantDigits = newParams.transformPrecision;
      if (matrixData.length) {
        newParams.transformPrecision = Math.min(
          newParams.transformPrecision,
          Math.max.apply(Math, matrixData.map(floatDigits)) || newParams.transformPrecision
        );
        significantDigits = Math.max.apply(
          Math,
          matrixData.map(
            (n) => n.toString().replace(/\D+/g, "").length
            // Number of digits in a number. 123.45 → 5
          )
        );
      }
      if (newParams.degPrecision == null) {
        newParams.degPrecision = Math.max(
          0,
          Math.min(newParams.floatPrecision, significantDigits - 2)
        );
      }
      return newParams;
    };
    var degRound = (data, params) => {
      if (params.degPrecision != null && params.degPrecision >= 1 && params.floatPrecision < 20) {
        return smartRound(params.degPrecision, data);
      } else {
        return round(data);
      }
    };
    var floatRound = (data, params) => {
      if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
        return smartRound(params.floatPrecision, data);
      } else {
        return round(data);
      }
    };
    var transformRound = (data, params) => {
      if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
        return smartRound(params.transformPrecision, data);
      } else {
        return round(data);
      }
    };
    var floatDigits = (n) => {
      const str = n.toString();
      return str.slice(str.indexOf(".")).length - 1;
    };
    var convertToShorts = (transforms, params) => {
      for (var i = 0; i < transforms.length; i++) {
        var transform = transforms[i];
        if (params.matrixToTransform && transform.name === "matrix") {
          var decomposed = matrixToTransform(transform, params);
          if (js2transform(decomposed, params).length <= js2transform([transform], params).length) {
            transforms.splice(i, 1, ...decomposed);
          }
          transform = transforms[i];
        }
        roundTransform(transform, params);
        if (params.shortTranslate && transform.name === "translate" && transform.data.length === 2 && !transform.data[1]) {
          transform.data.pop();
        }
        if (params.shortScale && transform.name === "scale" && transform.data.length === 2 && transform.data[0] === transform.data[1]) {
          transform.data.pop();
        }
        if (params.shortRotate && transforms[i - 2] && transforms[i - 2].name === "translate" && transforms[i - 1].name === "rotate" && transforms[i].name === "translate" && transforms[i - 2].data[0] === -transforms[i].data[0] && transforms[i - 2].data[1] === -transforms[i].data[1]) {
          transforms.splice(i - 2, 3, {
            name: "rotate",
            data: [
              transforms[i - 1].data[0],
              transforms[i - 2].data[0],
              transforms[i - 2].data[1]
            ]
          });
          i -= 2;
        }
      }
      return transforms;
    };
    var removeUseless = (transforms) => {
      return transforms.filter((transform) => {
        if (["translate", "rotate", "skewX", "skewY"].indexOf(transform.name) > -1 && (transform.data.length == 1 || transform.name == "rotate") && !transform.data[0] || // translate(0, 0)
        transform.name == "translate" && !transform.data[0] && !transform.data[1] || // scale(1)
        transform.name == "scale" && transform.data[0] == 1 && (transform.data.length < 2 || transform.data[1] == 1) || // matrix(1 0 0 1 0 0)
        transform.name == "matrix" && transform.data[0] == 1 && transform.data[3] == 1 && !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])) {
          return false;
        }
        return true;
      });
    };
    var js2transform = (transformJS, params) => {
      var transformString = "";
      transformJS.forEach((transform) => {
        roundTransform(transform, params);
        transformString += (transformString && " ") + transform.name + "(" + cleanupOutData(transform.data, params) + ")";
      });
      return transformString;
    };
    var roundTransform = (transform, params) => {
      switch (transform.name) {
        case "translate":
          transform.data = floatRound(transform.data, params);
          break;
        case "rotate":
          transform.data = [
            ...degRound(transform.data.slice(0, 1), params),
            ...floatRound(transform.data.slice(1), params)
          ];
          break;
        case "skewX":
        case "skewY":
          transform.data = degRound(transform.data, params);
          break;
        case "scale":
          transform.data = transformRound(transform.data, params);
          break;
        case "matrix":
          transform.data = [
            ...transformRound(transform.data.slice(0, 4), params),
            ...floatRound(transform.data.slice(4), params)
          ];
          break;
      }
      return transform;
    };
    var round = (data) => {
      return data.map(Math.round);
    };
    var smartRound = (precision, data) => {
      for (var i = data.length, tolerance = +Math.pow(0.1, precision).toFixed(precision); i--; ) {
        if (Number(data[i].toFixed(precision)) !== data[i]) {
          var rounded = +data[i].toFixed(precision - 1);
          data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance ? +data[i].toFixed(precision) : rounded;
        }
      }
      return data;
    };
  }
});

// node_modules/svgo/plugins/removeEmptyAttrs.js
var require_removeEmptyAttrs = __commonJS({
  "node_modules/svgo/plugins/removeEmptyAttrs.js"(exports2) {
    "use strict";
    var { attrsGroups } = require_collections();
    exports2.type = "visitor";
    exports2.name = "removeEmptyAttrs";
    exports2.active = true;
    exports2.description = "removes empty attributes";
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            for (const [name, value] of Object.entries(node.attributes)) {
              if (value === "" && // empty conditional processing attributes prevents elements from rendering
              attrsGroups.conditionalProcessing.includes(name) === false) {
                delete node.attributes[name];
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeEmptyContainers.js
var require_removeEmptyContainers = __commonJS({
  "node_modules/svgo/plugins/removeEmptyContainers.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { elemsGroups } = require_collections();
    exports2.type = "visitor";
    exports2.name = "removeEmptyContainers";
    exports2.active = true;
    exports2.description = "removes empty container elements";
    exports2.fn = () => {
      return {
        element: {
          exit: (node, parentNode) => {
            if (node.name === "svg" || elemsGroups.container.includes(node.name) === false || node.children.length !== 0) {
              return;
            }
            if (node.name === "pattern" && Object.keys(node.attributes).length !== 0) {
              return;
            }
            if (node.name === "g" && node.attributes.filter != null) {
              return;
            }
            if (node.name === "mask" && node.attributes.id != null) {
              return;
            }
            detachNodeFromParent(node, parentNode);
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/mergePaths.js
var require_mergePaths = __commonJS({
  "node_modules/svgo/plugins/mergePaths.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var { path2js, js2path, intersects } = require_path2();
    exports2.type = "visitor";
    exports2.name = "mergePaths";
    exports2.active = true;
    exports2.description = "merges multiple paths in one if possible";
    exports2.fn = (root, params) => {
      const {
        force = false,
        floatPrecision,
        noSpaceAfterFlags = false
        // a20 60 45 0 1 30 20 → a20 60 45 0130 20
      } = params;
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node) => {
            let prevChild = null;
            for (const child of node.children) {
              if (prevChild == null || prevChild.type !== "element" || prevChild.name !== "path" || prevChild.children.length !== 0 || prevChild.attributes.d == null) {
                prevChild = child;
                continue;
              }
              if (child.type !== "element" || child.name !== "path" || child.children.length !== 0 || child.attributes.d == null) {
                prevChild = child;
                continue;
              }
              const computedStyle = computeStyle(stylesheet, child);
              if (computedStyle["marker-start"] || computedStyle["marker-mid"] || computedStyle["marker-end"]) {
                prevChild = child;
                continue;
              }
              const prevChildAttrs = Object.keys(prevChild.attributes);
              const childAttrs = Object.keys(child.attributes);
              let attributesAreEqual = prevChildAttrs.length === childAttrs.length;
              for (const name of childAttrs) {
                if (name !== "d") {
                  if (prevChild.attributes[name] == null || prevChild.attributes[name] !== child.attributes[name]) {
                    attributesAreEqual = false;
                  }
                }
              }
              const prevPathJS = path2js(prevChild);
              const curPathJS = path2js(child);
              if (attributesAreEqual && (force || !intersects(prevPathJS, curPathJS))) {
                js2path(prevChild, prevPathJS.concat(curPathJS), {
                  floatPrecision,
                  noSpaceAfterFlags
                });
                detachNodeFromParent(child, node);
                continue;
              }
              prevChild = child;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeUnusedNS.js
var require_removeUnusedNS = __commonJS({
  "node_modules/svgo/plugins/removeUnusedNS.js"(exports2) {
    "use strict";
    exports2.type = "visitor";
    exports2.name = "removeUnusedNS";
    exports2.active = true;
    exports2.description = "removes unused namespaces declaration";
    exports2.fn = () => {
      const unusedNamespaces = /* @__PURE__ */ new Set();
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              for (const name of Object.keys(node.attributes)) {
                if (name.startsWith("xmlns:")) {
                  const local = name.slice("xmlns:".length);
                  unusedNamespaces.add(local);
                }
              }
            }
            if (unusedNamespaces.size !== 0) {
              if (node.name.includes(":")) {
                const [ns] = node.name.split(":");
                if (unusedNamespaces.has(ns)) {
                  unusedNamespaces.delete(ns);
                }
              }
              for (const name of Object.keys(node.attributes)) {
                if (name.includes(":")) {
                  const [ns] = name.split(":");
                  unusedNamespaces.delete(ns);
                }
              }
            }
          },
          exit: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              for (const name of unusedNamespaces) {
                delete node.attributes[`xmlns:${name}`];
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/sortDefsChildren.js
var require_sortDefsChildren = __commonJS({
  "node_modules/svgo/plugins/sortDefsChildren.js"(exports2) {
    "use strict";
    exports2.type = "visitor";
    exports2.name = "sortDefsChildren";
    exports2.active = true;
    exports2.description = "Sorts children of <defs> to improve compression";
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "defs") {
              const frequencies = /* @__PURE__ */ new Map();
              for (const child of node.children) {
                if (child.type === "element") {
                  const frequency = frequencies.get(child.name);
                  if (frequency == null) {
                    frequencies.set(child.name, 1);
                  } else {
                    frequencies.set(child.name, frequency + 1);
                  }
                }
              }
              node.children.sort((a, b) => {
                if (a.type !== "element" || b.type !== "element") {
                  return 0;
                }
                const aFrequency = frequencies.get(a.name);
                const bFrequency = frequencies.get(b.name);
                if (aFrequency != null && bFrequency != null) {
                  const frequencyComparison = bFrequency - aFrequency;
                  if (frequencyComparison !== 0) {
                    return frequencyComparison;
                  }
                }
                const lengthComparison = b.name.length - a.name.length;
                if (lengthComparison !== 0) {
                  return lengthComparison;
                }
                if (a.name !== b.name) {
                  return a.name > b.name ? -1 : 1;
                }
                return 0;
              });
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeTitle.js
var require_removeTitle = __commonJS({
  "node_modules/svgo/plugins/removeTitle.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeTitle";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "removes <title>";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "title") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeDesc.js
var require_removeDesc = __commonJS({
  "node_modules/svgo/plugins/removeDesc.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeDesc";
    exports2.type = "visitor";
    exports2.active = true;
    exports2.description = "removes <desc>";
    var standardDescs = /^(Created with|Created using)/;
    exports2.fn = (root, params) => {
      const { removeAny = true } = params;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "desc") {
              if (removeAny || node.children.length === 0 || node.children[0].type === "text" && standardDescs.test(node.children[0].value)) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/preset-default.js
var require_preset_default = __commonJS({
  "node_modules/svgo/plugins/preset-default.js"(exports2, module2) {
    "use strict";
    var { createPreset } = require_plugins();
    var removeDoctype = require_removeDoctype();
    var removeXMLProcInst = require_removeXMLProcInst();
    var removeComments = require_removeComments();
    var removeMetadata = require_removeMetadata();
    var removeEditorsNSData = require_removeEditorsNSData();
    var cleanupAttrs = require_cleanupAttrs();
    var mergeStyles = require_mergeStyles();
    var inlineStyles = require_inlineStyles();
    var minifyStyles = require_minifyStyles();
    var cleanupIDs = require_cleanupIDs();
    var removeUselessDefs = require_removeUselessDefs();
    var cleanupNumericValues = require_cleanupNumericValues();
    var convertColors = require_convertColors();
    var removeUnknownsAndDefaults = require_removeUnknownsAndDefaults();
    var removeNonInheritableGroupAttrs = require_removeNonInheritableGroupAttrs();
    var removeUselessStrokeAndFill = require_removeUselessStrokeAndFill();
    var removeViewBox = require_removeViewBox();
    var cleanupEnableBackground = require_cleanupEnableBackground();
    var removeHiddenElems = require_removeHiddenElems();
    var removeEmptyText = require_removeEmptyText();
    var convertShapeToPath = require_convertShapeToPath();
    var convertEllipseToCircle = require_convertEllipseToCircle();
    var moveElemsAttrsToGroup = require_moveElemsAttrsToGroup();
    var moveGroupAttrsToElems = require_moveGroupAttrsToElems();
    var collapseGroups = require_collapseGroups();
    var convertPathData = require_convertPathData();
    var convertTransform = require_convertTransform();
    var removeEmptyAttrs = require_removeEmptyAttrs();
    var removeEmptyContainers = require_removeEmptyContainers();
    var mergePaths = require_mergePaths();
    var removeUnusedNS = require_removeUnusedNS();
    var sortDefsChildren = require_sortDefsChildren();
    var removeTitle = require_removeTitle();
    var removeDesc = require_removeDesc();
    var presetDefault = createPreset({
      name: "presetDefault",
      plugins: [
        removeDoctype,
        removeXMLProcInst,
        removeComments,
        removeMetadata,
        removeEditorsNSData,
        cleanupAttrs,
        mergeStyles,
        inlineStyles,
        minifyStyles,
        cleanupIDs,
        removeUselessDefs,
        cleanupNumericValues,
        convertColors,
        removeUnknownsAndDefaults,
        removeNonInheritableGroupAttrs,
        removeUselessStrokeAndFill,
        removeViewBox,
        cleanupEnableBackground,
        removeHiddenElems,
        removeEmptyText,
        convertShapeToPath,
        convertEllipseToCircle,
        moveElemsAttrsToGroup,
        moveGroupAttrsToElems,
        collapseGroups,
        convertPathData,
        convertTransform,
        removeEmptyAttrs,
        removeEmptyContainers,
        mergePaths,
        removeUnusedNS,
        sortDefsChildren,
        removeTitle,
        removeDesc
      ]
    });
    module2.exports = presetDefault;
  }
});

// node_modules/svgo/plugins/addAttributesToSVGElement.js
var require_addAttributesToSVGElement = __commonJS({
  "node_modules/svgo/plugins/addAttributesToSVGElement.js"(exports2) {
    "use strict";
    exports2.name = "addAttributesToSVGElement";
    exports2.type = "visitor";
    exports2.active = false;
    exports2.description = "adds attributes to an outer <svg> element";
    var ENOCLS = `Error in plugin "addAttributesToSVGElement": absent parameters.
It should have a list of "attributes" or one "attribute".
Config example:

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attribute: "mySvg"
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: ["mySvg", "size-big"]
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: [
        {
          focusable: false
        },
        {
          'data-image': icon
        }
      ]
    }
  }
]
`;
    exports2.fn = (root, params) => {
      if (!Array.isArray(params.attributes) && !params.attribute) {
        console.error(ENOCLS);
        return null;
      }
      const attributes = params.attributes || [params.attribute];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              for (const attribute of attributes) {
                if (typeof attribute === "string") {
                  if (node.attributes[attribute] == null) {
                    node.attributes[attribute] = void 0;
                  }
                }
                if (typeof attribute === "object") {
                  for (const key of Object.keys(attribute)) {
                    if (node.attributes[key] == null) {
                      node.attributes[key] = attribute[key];
                    }
                  }
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/addClassesToSVGElement.js
var require_addClassesToSVGElement = __commonJS({
  "node_modules/svgo/plugins/addClassesToSVGElement.js"(exports2) {
    "use strict";
    exports2.name = "addClassesToSVGElement";
    exports2.type = "visitor";
    exports2.active = false;
    exports2.description = "adds classnames to an outer <svg> element";
    var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.
It should have a list of classes in "classNames" or one "className".
Config example:

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      className: "mySvg"
    }
  }
]

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      classNames: ["mySvg", "size-big"]
    }
  }
]
`;
    exports2.fn = (root, params) => {
      if (!(Array.isArray(params.classNames) && params.classNames.some(String)) && !params.className) {
        console.error(ENOCLS);
        return null;
      }
      const classNames = params.classNames || [params.className];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              const classList = new Set(
                node.attributes.class == null ? null : node.attributes.class.split(" ")
              );
              for (const className of classNames) {
                if (className != null) {
                  classList.add(className);
                }
              }
              node.attributes.class = Array.from(classList).join(" ");
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupListOfValues.js
var require_cleanupListOfValues = __commonJS({
  "node_modules/svgo/plugins/cleanupListOfValues.js"(exports2) {
    "use strict";
    var { removeLeadingZero } = require_tools();
    exports2.name = "cleanupListOfValues";
    exports2.type = "visitor";
    exports2.active = false;
    exports2.description = "rounds list of values to the fixed precision";
    var regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
    var regSeparator = /\s+,?\s*|,\s*/;
    var absoluteLengths = {
      // relative to px
      cm: 96 / 2.54,
      mm: 96 / 25.4,
      in: 96,
      pt: 4 / 3,
      pc: 16,
      px: 1
    };
    exports2.fn = (_root, params) => {
      const {
        floatPrecision = 3,
        leadingZero = true,
        defaultPx = true,
        convertToPx = true
      } = params;
      const roundValues = (lists) => {
        const roundedList = [];
        for (const elem of lists.split(regSeparator)) {
          const match = elem.match(regNumericValues);
          const matchNew = elem.match(/new/);
          if (match) {
            let num = Number(Number(match[1]).toFixed(floatPrecision));
            let matchedUnit = match[3] || "";
            let units = matchedUnit;
            if (convertToPx && units && units in absoluteLengths) {
              const pxNum = Number(
                (absoluteLengths[units] * Number(match[1])).toFixed(floatPrecision)
              );
              if (pxNum.toString().length < match[0].length) {
                num = pxNum;
                units = "px";
              }
            }
            let str;
            if (leadingZero) {
              str = removeLeadingZero(num);
            } else {
              str = num.toString();
            }
            if (defaultPx && units === "px") {
              units = "";
            }
            roundedList.push(str + units);
          } else if (matchNew) {
            roundedList.push("new");
          } else if (elem) {
            roundedList.push(elem);
          }
        }
        return roundedList.join(" ");
      };
      return {
        element: {
          enter: (node) => {
            if (node.attributes.points != null) {
              node.attributes.points = roundValues(node.attributes.points);
            }
            if (node.attributes["enable-background"] != null) {
              node.attributes["enable-background"] = roundValues(
                node.attributes["enable-background"]
              );
            }
            if (node.attributes.viewBox != null) {
              node.attributes.viewBox = roundValues(node.attributes.viewBox);
            }
            if (node.attributes["stroke-dasharray"] != null) {
              node.attributes["stroke-dasharray"] = roundValues(
                node.attributes["stroke-dasharray"]
              );
            }
            if (node.attributes.dx != null) {
              node.attributes.dx = roundValues(node.attributes.dx);
            }
            if (node.attributes.dy != null) {
              node.attributes.dy = roundValues(node.attributes.dy);
            }
            if (node.attributes.x != null) {
              node.attributes.x = roundValues(node.attributes.x);
            }
            if (node.attributes.y != null) {
              node.attributes.y = roundValues(node.attributes.y);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertStyleToAttrs.js
var require_convertStyleToAttrs = __commonJS({
  "node_modules/svgo/plugins/convertStyleToAttrs.js"(exports2) {
    "use strict";
    exports2.name = "convertStyleToAttrs";
    exports2.type = "perItem";
    exports2.active = false;
    exports2.description = "converts style to attributes";
    exports2.params = {
      keepImportant: false
    };
    var stylingProps = require_collections().attrsGroups.presentation;
    var rEscape = "\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)";
    var rAttr = "\\s*(" + g("[^:;\\\\]", rEscape) + "*?)\\s*";
    var rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)";
    var rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)';
    var rQuotedString = new RegExp("^" + g(rSingleQuotes, rQuotes) + "$");
    var rParenthesis = "\\(" + g(`[^'"()\\\\]+`, rEscape, rSingleQuotes, rQuotes) + "*?\\)";
    var rValue = "\\s*(" + g(
      `[^!'"();\\\\]+?`,
      rEscape,
      rSingleQuotes,
      rQuotes,
      rParenthesis,
      "[^;]*?"
    ) + "*?)";
    var rDeclEnd = "\\s*(?:;\\s*|$)";
    var rImportant = "(\\s*!important(?![-(\\w]))?";
    var regDeclarationBlock = new RegExp(
      rAttr + ":" + rValue + rImportant + rDeclEnd,
      "ig"
    );
    var regStripComments = new RegExp(
      g(rEscape, rSingleQuotes, rQuotes, "/\\*[^]*?\\*/"),
      "ig"
    );
    exports2.fn = function(item, params) {
      if (item.type === "element" && item.attributes.style != null) {
        let styles = [];
        const newAttributes = {};
        const styleValue = item.attributes.style.replace(
          regStripComments,
          (match) => {
            return match[0] == "/" ? "" : match[0] == "\\" && /[-g-z]/i.test(match[1]) ? match[1] : match;
          }
        );
        regDeclarationBlock.lastIndex = 0;
        for (var rule; rule = regDeclarationBlock.exec(styleValue); ) {
          if (!params.keepImportant || !rule[3]) {
            styles.push([rule[1], rule[2]]);
          }
        }
        if (styles.length) {
          styles = styles.filter(function(style) {
            if (style[0]) {
              var prop = style[0].toLowerCase(), val = style[1];
              if (rQuotedString.test(val)) {
                val = val.slice(1, -1);
              }
              if (stylingProps.includes(prop)) {
                newAttributes[prop] = val;
                return false;
              }
            }
            return true;
          });
          Object.assign(item.attributes, newAttributes);
          if (styles.length) {
            item.attributes.style = styles.map((declaration) => declaration.join(":")).join(";");
          } else {
            delete item.attributes.style;
          }
        }
      }
    };
    function g() {
      return "(?:" + Array.prototype.join.call(arguments, "|") + ")";
    }
  }
});

// node_modules/svgo/plugins/prefixIds.js
var require_prefixIds = __commonJS({
  "node_modules/svgo/plugins/prefixIds.js"(exports2) {
    "use strict";
    var csstree = require_lib10();
    var { referencesProps } = require_collections();
    exports2.type = "visitor";
    exports2.name = "prefixIds";
    exports2.active = false;
    exports2.description = "prefix IDs";
    var getBasename = (path) => {
      const matched = path.match(/[/\\]?([^/\\]+)$/);
      if (matched) {
        return matched[1];
      }
      return "";
    };
    var escapeIdentifierName = (str) => {
      return str.replace(/[. ]/g, "_");
    };
    var unquote = (string) => {
      if (string.startsWith('"') && string.endsWith('"') || string.startsWith("'") && string.endsWith("'")) {
        return string.slice(1, -1);
      }
      return string;
    };
    var prefixId = (prefix, value) => {
      if (value.startsWith(prefix)) {
        return value;
      }
      return prefix + value;
    };
    var prefixReference = (prefix, value) => {
      if (value.startsWith("#")) {
        return "#" + prefixId(prefix, value.slice(1));
      }
      return null;
    };
    exports2.fn = (_root, params, info) => {
      const { delim = "__", prefixIds = true, prefixClassNames = true } = params;
      return {
        element: {
          enter: (node) => {
            let prefix = "prefix" + delim;
            if (typeof params.prefix === "function") {
              prefix = params.prefix(node, info) + delim;
            } else if (typeof params.prefix === "string") {
              prefix = params.prefix + delim;
            } else if (params.prefix === false) {
              prefix = "";
            } else if (info.path != null && info.path.length > 0) {
              prefix = escapeIdentifierName(getBasename(info.path)) + delim;
            }
            if (node.name === "style") {
              if (node.children.length === 0) {
                return;
              }
              let cssText = "";
              if (node.children[0].type === "text" || node.children[0].type === "cdata") {
                cssText = node.children[0].value;
              }
              let cssAst = null;
              try {
                cssAst = csstree.parse(cssText, {
                  parseValue: true,
                  parseCustomProperty: false
                });
              } catch {
                return;
              }
              csstree.walk(cssAst, (node2) => {
                if (prefixIds && node2.type === "IdSelector" || prefixClassNames && node2.type === "ClassSelector") {
                  node2.name = prefixId(prefix, node2.name);
                  return;
                }
                if (node2.type === "Url" && node2.value.value && node2.value.value.length > 0) {
                  const prefixed = prefixReference(
                    prefix,
                    unquote(node2.value.value)
                  );
                  if (prefixed != null) {
                    node2.value.value = prefixed;
                  }
                }
              });
              if (node.children[0].type === "text" || node.children[0].type === "cdata") {
                node.children[0].value = csstree.generate(cssAst);
              }
              return;
            }
            if (prefixIds && node.attributes.id != null && node.attributes.id.length !== 0) {
              node.attributes.id = prefixId(prefix, node.attributes.id);
            }
            if (prefixClassNames && node.attributes.class != null && node.attributes.class.length !== 0) {
              node.attributes.class = node.attributes.class.split(/\s+/).map((name) => prefixId(prefix, name)).join(" ");
            }
            for (const name of ["href", "xlink:href"]) {
              if (node.attributes[name] != null && node.attributes[name].length !== 0) {
                const prefixed = prefixReference(prefix, node.attributes[name]);
                if (prefixed != null) {
                  node.attributes[name] = prefixed;
                }
              }
            }
            for (const name of referencesProps) {
              if (node.attributes[name] != null && node.attributes[name].length !== 0) {
                node.attributes[name] = node.attributes[name].replace(
                  /url\((.*?)\)/gi,
                  (match, url) => {
                    const prefixed = prefixReference(prefix, url);
                    if (prefixed == null) {
                      return match;
                    }
                    return `url(${prefixed})`;
                  }
                );
              }
            }
            for (const name of ["begin", "end"]) {
              if (node.attributes[name] != null && node.attributes[name].length !== 0) {
                const parts = node.attributes[name].split(/\s*;\s+/).map((val) => {
                  if (val.endsWith(".end") || val.endsWith(".start")) {
                    const [id, postfix] = val.split(".");
                    return `${prefixId(prefix, id)}.${postfix}`;
                  }
                  return val;
                });
                node.attributes[name] = parts.join("; ");
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeAttributesBySelector.js
var require_removeAttributesBySelector = __commonJS({
  "node_modules/svgo/plugins/removeAttributesBySelector.js"(exports2) {
    "use strict";
    var { querySelectorAll } = require_xast();
    exports2.name = "removeAttributesBySelector";
    exports2.type = "visitor";
    exports2.active = false;
    exports2.description = "removes attributes of elements that match a css selector";
    exports2.fn = (root, params) => {
      const selectors = Array.isArray(params.selectors) ? params.selectors : [params];
      for (const { selector, attributes } of selectors) {
        const nodes = querySelectorAll(root, selector);
        for (const node of nodes) {
          if (node.type === "element") {
            if (Array.isArray(attributes)) {
              for (const name of attributes) {
                delete node.attributes[name];
              }
            } else {
              delete node.attributes[attributes];
            }
          }
        }
      }
      return {};
    };
  }
});

// node_modules/svgo/plugins/removeAttrs.js
var require_removeAttrs = __commonJS({
  "node_modules/svgo/plugins/removeAttrs.js"(exports2) {
    "use strict";
    exports2.name = "removeAttrs";
    exports2.type = "visitor";
    exports2.active = false;
    exports2.description = "removes specified attributes";
    var DEFAULT_SEPARATOR = ":";
    var ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.
It should have a pattern to remove, otherwise the plugin is a noop.
Config example:

plugins: [
  {
    name: "removeAttrs",
    params: {
      attrs: "(fill|stroke)"
    }
  }
]
`;
    exports2.fn = (root, params) => {
      if (typeof params.attrs == "undefined") {
        console.warn(ENOATTRS);
        return null;
      }
      const elemSeparator = typeof params.elemSeparator == "string" ? params.elemSeparator : DEFAULT_SEPARATOR;
      const preserveCurrentColor = typeof params.preserveCurrentColor == "boolean" ? params.preserveCurrentColor : false;
      const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];
      return {
        element: {
          enter: (node) => {
            for (let pattern of attrs) {
              if (pattern.includes(elemSeparator) === false) {
                pattern = [".*", elemSeparator, pattern, elemSeparator, ".*"].join(
                  ""
                );
              } else if (pattern.split(elemSeparator).length < 3) {
                pattern = [pattern, elemSeparator, ".*"].join("");
              }
              const list = pattern.split(elemSeparator).map((value) => {
                if (value === "*") {
                  value = ".*";
                }
                return new RegExp(["^", value, "$"].join(""), "i");
              });
              if (list[0].test(node.name)) {
                for (const [name, value] of Object.entries(node.attributes)) {
                  const isFillCurrentColor = preserveCurrentColor && name == "fill" && value == "currentColor";
                  const isStrokeCurrentColor = preserveCurrentColor && name == "stroke" && value == "currentColor";
                  if (!isFillCurrentColor && !isStrokeCurrentColor && // matches attribute name
                  list[1].test(name) && // matches attribute value
                  list[2].test(value)) {
                    delete node.attributes[name];
                  }
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeDimensions.js
var require_removeDimensions = __commonJS({
  "node_modules/svgo/plugins/removeDimensions.js"(exports2) {
    "use strict";
    exports2.name = "removeDimensions";
    exports2.type = "perItem";
    exports2.active = false;
    exports2.description = "removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)";
    exports2.fn = function(item) {
      if (item.type === "element" && item.name === "svg") {
        if (item.attributes.viewBox != null) {
          delete item.attributes.width;
          delete item.attributes.height;
        } else if (item.attributes.width != null && item.attributes.height != null && Number.isNaN(Number(item.attributes.width)) === false && Number.isNaN(Number(item.attributes.height)) === false) {
          const width = Number(item.attributes.width);
          const height = Number(item.attributes.height);
          item.attributes.viewBox = `0 0 ${width} ${height}`;
          delete item.attributes.width;
          delete item.attributes.height;
        }
      }
    };
  }
});

// node_modules/svgo/plugins/removeElementsByAttr.js
var require_removeElementsByAttr = __commonJS({
  "node_modules/svgo/plugins/removeElementsByAttr.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeElementsByAttr";
    exports2.type = "visitor";
    exports2.active = false;
    exports2.description = "removes arbitrary elements by ID or className (disabled by default)";
    exports2.fn = (root, params) => {
      const ids = params.id == null ? [] : Array.isArray(params.id) ? params.id : [params.id];
      const classes = params.class == null ? [] : Array.isArray(params.class) ? params.class : [params.class];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.attributes.id != null && ids.length !== 0) {
              if (ids.includes(node.attributes.id)) {
                detachNodeFromParent(node, parentNode);
              }
            }
            if (node.attributes.class && classes.length !== 0) {
              const classList = node.attributes.class.split(" ");
              for (const item of classes) {
                if (classList.includes(item)) {
                  detachNodeFromParent(node, parentNode);
                  break;
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeOffCanvasPaths.js
var require_removeOffCanvasPaths = __commonJS({
  "node_modules/svgo/plugins/removeOffCanvasPaths.js"(exports2) {
    "use strict";
    var { visitSkip, detachNodeFromParent } = require_xast();
    var { parsePathData } = require_path();
    var { intersects } = require_path2();
    exports2.type = "visitor";
    exports2.name = "removeOffCanvasPaths";
    exports2.active = false;
    exports2.description = "removes elements that are drawn outside of the viewbox (disabled by default)";
    exports2.fn = () => {
      let viewBoxData = null;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              let viewBox = "";
              if (node.attributes.viewBox != null) {
                viewBox = node.attributes.viewBox;
              } else if (node.attributes.height != null && node.attributes.width != null) {
                viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;
              }
              viewBox = viewBox.replace(/[,+]|px/g, " ").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
              const m = /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
                viewBox
              );
              if (m == null) {
                return;
              }
              const left = Number.parseFloat(m[1]);
              const top = Number.parseFloat(m[2]);
              const width = Number.parseFloat(m[3]);
              const height = Number.parseFloat(m[4]);
              viewBoxData = {
                left,
                top,
                right: left + width,
                bottom: top + height,
                width,
                height
              };
            }
            if (node.attributes.transform != null) {
              return visitSkip;
            }
            if (node.name === "path" && node.attributes.d != null && viewBoxData != null) {
              const pathData = parsePathData(node.attributes.d);
              let visible = false;
              for (const pathDataItem of pathData) {
                if (pathDataItem.command === "M") {
                  const [x, y] = pathDataItem.args;
                  if (x >= viewBoxData.left && x <= viewBoxData.right && y >= viewBoxData.top && y <= viewBoxData.bottom) {
                    visible = true;
                  }
                }
              }
              if (visible) {
                return;
              }
              if (pathData.length === 2) {
                pathData.push({ command: "z", args: [] });
              }
              const { left, top, width, height } = viewBoxData;
              const viewBoxPathData = [
                { command: "M", args: [left, top] },
                { command: "h", args: [width] },
                { command: "v", args: [height] },
                { command: "H", args: [left] },
                { command: "z", args: [] }
              ];
              if (intersects(viewBoxPathData, pathData) === false) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeRasterImages.js
var require_removeRasterImages = __commonJS({
  "node_modules/svgo/plugins/removeRasterImages.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeRasterImages";
    exports2.type = "visitor";
    exports2.active = false;
    exports2.description = "removes raster images (disabled by default)";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "image" && node.attributes["xlink:href"] != null && /(\.|image\/)(jpg|png|gif)/.test(node.attributes["xlink:href"])) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeScriptElement.js
var require_removeScriptElement = __commonJS({
  "node_modules/svgo/plugins/removeScriptElement.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeScriptElement";
    exports2.type = "visitor";
    exports2.active = false;
    exports2.description = "removes <script> elements (disabled by default)";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "script") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeStyleElement.js
var require_removeStyleElement = __commonJS({
  "node_modules/svgo/plugins/removeStyleElement.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeStyleElement";
    exports2.type = "visitor";
    exports2.active = false;
    exports2.description = "removes <style> element (disabled by default)";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "style") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeXMLNS.js
var require_removeXMLNS = __commonJS({
  "node_modules/svgo/plugins/removeXMLNS.js"(exports2) {
    "use strict";
    exports2.name = "removeXMLNS";
    exports2.type = "perItem";
    exports2.active = false;
    exports2.description = "removes xmlns attribute (for inline svg, disabled by default)";
    exports2.fn = function(item) {
      if (item.type === "element" && item.name === "svg") {
        delete item.attributes.xmlns;
        delete item.attributes["xmlns:xlink"];
      }
    };
  }
});

// node_modules/svgo/plugins/reusePaths.js
var require_reusePaths = __commonJS({
  "node_modules/svgo/plugins/reusePaths.js"(exports2) {
    "use strict";
    var JSAPI = require_jsAPI();
    exports2.type = "visitor";
    exports2.name = "reusePaths";
    exports2.active = false;
    exports2.description = "Finds <path> elements with the same d, fill, and stroke, and converts them to <use> elements referencing a single <path> def.";
    exports2.fn = () => {
      const paths = /* @__PURE__ */ new Map();
      return {
        element: {
          enter: (node) => {
            if (node.name === "path" && node.attributes.d != null) {
              const d = node.attributes.d;
              const fill = node.attributes.fill || "";
              const stroke = node.attributes.stroke || "";
              const key = d + ";s:" + stroke + ";f:" + fill;
              let list = paths.get(key);
              if (list == null) {
                list = [];
                paths.set(key, list);
              }
              list.push(node);
            }
          },
          exit: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              const rawDefs = {
                type: "element",
                name: "defs",
                attributes: {},
                children: []
              };
              const defsTag = new JSAPI(rawDefs, node);
              let index = 0;
              for (const list of paths.values()) {
                if (list.length > 1) {
                  const rawPath = {
                    type: "element",
                    name: "path",
                    attributes: { ...list[0].attributes },
                    children: []
                  };
                  delete rawPath.attributes.transform;
                  let id;
                  if (rawPath.attributes.id == null) {
                    id = "reuse-" + index;
                    index += 1;
                    rawPath.attributes.id = id;
                  } else {
                    id = rawPath.attributes.id;
                    delete list[0].attributes.id;
                  }
                  const reusablePath = new JSAPI(rawPath, defsTag);
                  defsTag.children.push(reusablePath);
                  for (const pathNode of list) {
                    pathNode.name = "use";
                    pathNode.attributes["xlink:href"] = "#" + id;
                    delete pathNode.attributes.d;
                    delete pathNode.attributes.stroke;
                    delete pathNode.attributes.fill;
                  }
                }
              }
              if (defsTag.children.length !== 0) {
                if (node.attributes["xmlns:xlink"] == null) {
                  node.attributes["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
                }
                node.children.unshift(defsTag);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/sortAttrs.js
var require_sortAttrs = __commonJS({
  "node_modules/svgo/plugins/sortAttrs.js"(exports2) {
    "use strict";
    exports2.type = "visitor";
    exports2.name = "sortAttrs";
    exports2.active = false;
    exports2.description = "Sort element attributes for better compression";
    exports2.fn = (_root, params) => {
      const {
        order = [
          "id",
          "width",
          "height",
          "x",
          "x1",
          "x2",
          "y",
          "y1",
          "y2",
          "cx",
          "cy",
          "r",
          "fill",
          "stroke",
          "marker",
          "d",
          "points"
        ],
        xmlnsOrder = "front"
      } = params;
      const getNsPriority = (name) => {
        if (xmlnsOrder === "front") {
          if (name === "xmlns") {
            return 3;
          }
          if (name.startsWith("xmlns:")) {
            return 2;
          }
        }
        if (name.includes(":")) {
          return 1;
        }
        return 0;
      };
      const compareAttrs = ([aName], [bName]) => {
        const aPriority = getNsPriority(aName);
        const bPriority = getNsPriority(bName);
        const priorityNs = bPriority - aPriority;
        if (priorityNs !== 0) {
          return priorityNs;
        }
        const [aPart] = aName.split("-");
        const [bPart] = bName.split("-");
        if (aPart !== bPart) {
          const aInOrderFlag = order.includes(aPart) ? 1 : 0;
          const bInOrderFlag = order.includes(bPart) ? 1 : 0;
          if (aInOrderFlag === 1 && bInOrderFlag === 1) {
            return order.indexOf(aPart) - order.indexOf(bPart);
          }
          const priorityOrder = bInOrderFlag - aInOrderFlag;
          if (priorityOrder !== 0) {
            return priorityOrder;
          }
        }
        return aName < bName ? -1 : 1;
      };
      return {
        element: {
          enter: (node) => {
            const attrs = Object.entries(node.attributes);
            attrs.sort(compareAttrs);
            const sortedAttributes = {};
            for (const [name, value] of attrs) {
              sortedAttributes[name] = value;
            }
            node.attributes = sortedAttributes;
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/plugins.js
var require_plugins2 = __commonJS({
  "node_modules/svgo/plugins/plugins.js"(exports2) {
    "use strict";
    exports2["preset-default"] = require_preset_default();
    exports2.addAttributesToSVGElement = require_addAttributesToSVGElement();
    exports2.addClassesToSVGElement = require_addClassesToSVGElement();
    exports2.cleanupAttrs = require_cleanupAttrs();
    exports2.cleanupEnableBackground = require_cleanupEnableBackground();
    exports2.cleanupIDs = require_cleanupIDs();
    exports2.cleanupListOfValues = require_cleanupListOfValues();
    exports2.cleanupNumericValues = require_cleanupNumericValues();
    exports2.collapseGroups = require_collapseGroups();
    exports2.convertColors = require_convertColors();
    exports2.convertEllipseToCircle = require_convertEllipseToCircle();
    exports2.convertPathData = require_convertPathData();
    exports2.convertShapeToPath = require_convertShapeToPath();
    exports2.convertStyleToAttrs = require_convertStyleToAttrs();
    exports2.convertTransform = require_convertTransform();
    exports2.mergeStyles = require_mergeStyles();
    exports2.inlineStyles = require_inlineStyles();
    exports2.mergePaths = require_mergePaths();
    exports2.minifyStyles = require_minifyStyles();
    exports2.moveElemsAttrsToGroup = require_moveElemsAttrsToGroup();
    exports2.moveGroupAttrsToElems = require_moveGroupAttrsToElems();
    exports2.prefixIds = require_prefixIds();
    exports2.removeAttributesBySelector = require_removeAttributesBySelector();
    exports2.removeAttrs = require_removeAttrs();
    exports2.removeComments = require_removeComments();
    exports2.removeDesc = require_removeDesc();
    exports2.removeDimensions = require_removeDimensions();
    exports2.removeDoctype = require_removeDoctype();
    exports2.removeEditorsNSData = require_removeEditorsNSData();
    exports2.removeElementsByAttr = require_removeElementsByAttr();
    exports2.removeEmptyAttrs = require_removeEmptyAttrs();
    exports2.removeEmptyContainers = require_removeEmptyContainers();
    exports2.removeEmptyText = require_removeEmptyText();
    exports2.removeHiddenElems = require_removeHiddenElems();
    exports2.removeMetadata = require_removeMetadata();
    exports2.removeNonInheritableGroupAttrs = require_removeNonInheritableGroupAttrs();
    exports2.removeOffCanvasPaths = require_removeOffCanvasPaths();
    exports2.removeRasterImages = require_removeRasterImages();
    exports2.removeScriptElement = require_removeScriptElement();
    exports2.removeStyleElement = require_removeStyleElement();
    exports2.removeTitle = require_removeTitle();
    exports2.removeUnknownsAndDefaults = require_removeUnknownsAndDefaults();
    exports2.removeUnusedNS = require_removeUnusedNS();
    exports2.removeUselessDefs = require_removeUselessDefs();
    exports2.removeUselessStrokeAndFill = require_removeUselessStrokeAndFill();
    exports2.removeViewBox = require_removeViewBox();
    exports2.removeXMLNS = require_removeXMLNS();
    exports2.removeXMLProcInst = require_removeXMLProcInst();
    exports2.reusePaths = require_reusePaths();
    exports2.sortAttrs = require_sortAttrs();
    exports2.sortDefsChildren = require_sortDefsChildren();
  }
});

// node_modules/svgo/lib/svgo/config.js
var require_config = __commonJS({
  "node_modules/svgo/lib/svgo/config.js"(exports2) {
    "use strict";
    var pluginsMap = require_plugins2();
    var pluginsOrder = [
      "removeDoctype",
      "removeXMLProcInst",
      "removeComments",
      "removeMetadata",
      "removeXMLNS",
      "removeEditorsNSData",
      "cleanupAttrs",
      "mergeStyles",
      "inlineStyles",
      "minifyStyles",
      "convertStyleToAttrs",
      "cleanupIDs",
      "prefixIds",
      "removeRasterImages",
      "removeUselessDefs",
      "cleanupNumericValues",
      "cleanupListOfValues",
      "convertColors",
      "removeUnknownsAndDefaults",
      "removeNonInheritableGroupAttrs",
      "removeUselessStrokeAndFill",
      "removeViewBox",
      "cleanupEnableBackground",
      "removeHiddenElems",
      "removeEmptyText",
      "convertShapeToPath",
      "convertEllipseToCircle",
      "moveElemsAttrsToGroup",
      "moveGroupAttrsToElems",
      "collapseGroups",
      "convertPathData",
      "convertTransform",
      "removeEmptyAttrs",
      "removeEmptyContainers",
      "mergePaths",
      "removeUnusedNS",
      "sortAttrs",
      "sortDefsChildren",
      "removeTitle",
      "removeDesc",
      "removeDimensions",
      "removeAttrs",
      "removeAttributesBySelector",
      "removeElementsByAttr",
      "addClassesToSVGElement",
      "removeStyleElement",
      "removeScriptElement",
      "addAttributesToSVGElement",
      "removeOffCanvasPaths",
      "reusePaths"
    ];
    var defaultPlugins = pluginsOrder.filter((name) => pluginsMap[name].active);
    exports2.defaultPlugins = defaultPlugins;
    var extendDefaultPlugins = (plugins) => {
      console.warn(
        `
"extendDefaultPlugins" utility is deprecated.
Use "preset-default" plugin with overrides instead.
For example:
{
  name: 'preset-default',
  params: {
    overrides: {
      // customize plugin options
      convertShapeToPath: {
        convertArcs: true
      },
      // disable plugins
      convertPathData: false
    }
  }
}
`
      );
      const extendedPlugins = pluginsOrder.map((name) => ({
        name,
        active: pluginsMap[name].active
      }));
      for (const plugin of plugins) {
        const resolvedPlugin = resolvePluginConfig(plugin);
        const index = pluginsOrder.indexOf(resolvedPlugin.name);
        if (index === -1) {
          extendedPlugins.push(plugin);
        } else {
          extendedPlugins[index] = plugin;
        }
      }
      return extendedPlugins;
    };
    exports2.extendDefaultPlugins = extendDefaultPlugins;
    var resolvePluginConfig = (plugin) => {
      let configParams = {};
      if (typeof plugin === "string") {
        const pluginConfig = pluginsMap[plugin];
        if (pluginConfig == null) {
          throw Error(`Unknown builtin plugin "${plugin}" specified.`);
        }
        return {
          ...pluginConfig,
          name: plugin,
          active: true,
          params: { ...pluginConfig.params, ...configParams }
        };
      }
      if (typeof plugin === "object" && plugin != null) {
        if (plugin.name == null) {
          throw Error(`Plugin name should be specified`);
        }
        if (plugin.fn) {
          return {
            active: true,
            ...plugin,
            params: { ...configParams, ...plugin.params }
          };
        } else {
          const pluginConfig = pluginsMap[plugin.name];
          if (pluginConfig == null) {
            throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
          }
          return {
            ...pluginConfig,
            active: true,
            ...plugin,
            params: { ...pluginConfig.params, ...configParams, ...plugin.params }
          };
        }
      }
      return null;
    };
    exports2.resolvePluginConfig = resolvePluginConfig;
  }
});

// node_modules/@trysound/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@trysound/sax/lib/sax.js"(exports2) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, reason) {
        closeText(parser);
        const message = reason + "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        const error2 = new Error(message);
        error2.reason = reason;
        error2.line = parser.line;
        error2.column = parser.column;
        parser.error = error2;
        emit(parser, "onerror", error2);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t--) {
          var close = parser.tags[t];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.state === S.TEXT_ENTITY && !sax.ENTITIES[parser.entity] && parsedEntity !== "&" + parser.entity + ";") {
                  chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i);
                } else {
                  parser[buffer] += parsedEntity;
                }
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
    })(typeof exports2 === "undefined" ? exports2.sax = {} : exports2);
  }
});

// node_modules/svgo/lib/parser.js
var require_parser2 = __commonJS({
  "node_modules/svgo/lib/parser.js"(exports2) {
    "use strict";
    var SAX = require_sax();
    var JSAPI = require_jsAPI();
    var { textElems } = require_collections();
    var SvgoParserError = class _SvgoParserError extends Error {
      /**
       * @param message {string}
       * @param line {number}
       * @param column {number}
       * @param source {string}
       * @param file {void | string}
       */
      constructor(message, line, column, source, file) {
        super(message);
        this.name = "SvgoParserError";
        this.message = `${file || "<input>"}:${line}:${column}: ${message}`;
        this.reason = message;
        this.line = line;
        this.column = column;
        this.source = source;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _SvgoParserError);
        }
      }
      toString() {
        const lines = this.source.split(/\r?\n/);
        const startLine = Math.max(this.line - 3, 0);
        const endLine = Math.min(this.line + 2, lines.length);
        const lineNumberWidth = String(endLine).length;
        const startColumn = Math.max(this.column - 54, 0);
        const endColumn = Math.max(this.column + 20, 80);
        const code = lines.slice(startLine, endLine).map((line, index) => {
          const lineSlice = line.slice(startColumn, endColumn);
          let ellipsisPrefix = "";
          let ellipsisSuffix = "";
          if (startColumn !== 0) {
            ellipsisPrefix = startColumn > line.length - 1 ? " " : "\u2026";
          }
          if (endColumn < line.length - 1) {
            ellipsisSuffix = "\u2026";
          }
          const number = startLine + 1 + index;
          const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
          if (number === this.line) {
            const gutterSpacing = gutter.replace(/[^|]/g, " ");
            const lineSpacing = (ellipsisPrefix + line.slice(startColumn, this.column - 1)).replace(/[^\t]/g, " ");
            const spacing = gutterSpacing + lineSpacing;
            return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}
 ${spacing}^`;
          }
          return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
        }).join("\n");
        return `${this.name}: ${this.message}

${code}
`;
      }
    };
    var entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;
    var config = {
      strict: true,
      trim: false,
      normalize: false,
      lowercase: true,
      xmlns: true,
      position: true
    };
    var parseSvg = (data, from) => {
      const sax = SAX.parser(config.strict, config);
      const root = new JSAPI({ type: "root", children: [] });
      let current = root;
      const stack = [root];
      const pushToContent = (node) => {
        const wrapped = new JSAPI(node, current);
        current.children.push(wrapped);
        return wrapped;
      };
      sax.ondoctype = (doctype) => {
        const node = {
          type: "doctype",
          // TODO parse doctype for name, public and system to match xast
          name: "svg",
          data: {
            doctype
          }
        };
        pushToContent(node);
        const subsetStart = doctype.indexOf("[");
        if (subsetStart >= 0) {
          entityDeclaration.lastIndex = subsetStart;
          let entityMatch = entityDeclaration.exec(data);
          while (entityMatch != null) {
            sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
            entityMatch = entityDeclaration.exec(data);
          }
        }
      };
      sax.onprocessinginstruction = (data2) => {
        const node = {
          type: "instruction",
          name: data2.name,
          value: data2.body
        };
        pushToContent(node);
      };
      sax.oncomment = (comment) => {
        const node = {
          type: "comment",
          value: comment.trim()
        };
        pushToContent(node);
      };
      sax.oncdata = (cdata) => {
        const node = {
          type: "cdata",
          value: cdata
        };
        pushToContent(node);
      };
      sax.onopentag = (data2) => {
        let element = {
          type: "element",
          name: data2.name,
          attributes: {},
          children: []
        };
        for (const [name, attr] of Object.entries(data2.attributes)) {
          element.attributes[name] = attr.value;
        }
        element = pushToContent(element);
        current = element;
        stack.push(element);
      };
      sax.ontext = (text) => {
        if (current.type === "element") {
          if (textElems.includes(current.name)) {
            const node = {
              type: "text",
              value: text
            };
            pushToContent(node);
          } else if (/\S/.test(text)) {
            const node = {
              type: "text",
              value: text.trim()
            };
            pushToContent(node);
          }
        }
      };
      sax.onclosetag = () => {
        stack.pop();
        current = stack[stack.length - 1];
      };
      sax.onerror = (e) => {
        const error = new SvgoParserError(
          e.reason,
          e.line + 1,
          e.column,
          data,
          from
        );
        if (e.message.indexOf("Unexpected end") === -1) {
          throw error;
        }
      };
      sax.write(data).close();
      return root;
    };
    exports2.parseSvg = parseSvg;
  }
});

// node_modules/svgo/lib/stringifier.js
var require_stringifier = __commonJS({
  "node_modules/svgo/lib/stringifier.js"(exports2) {
    "use strict";
    var { textElems } = require_collections();
    var encodeEntity = (char) => {
      return entities[char];
    };
    var defaults = {
      doctypeStart: "<!DOCTYPE",
      doctypeEnd: ">",
      procInstStart: "<?",
      procInstEnd: "?>",
      tagOpenStart: "<",
      tagOpenEnd: ">",
      tagCloseStart: "</",
      tagCloseEnd: ">",
      tagShortStart: "<",
      tagShortEnd: "/>",
      attrStart: '="',
      attrEnd: '"',
      commentStart: "<!--",
      commentEnd: "-->",
      cdataStart: "<![CDATA[",
      cdataEnd: "]]>",
      textStart: "",
      textEnd: "",
      indent: 4,
      regEntities: /[&'"<>]/g,
      regValEntities: /[&"<>]/g,
      encodeEntity,
      pretty: false,
      useShortTags: true,
      eol: "lf",
      finalNewline: false
    };
    var entities = {
      "&": "&amp;",
      "'": "&apos;",
      '"': "&quot;",
      ">": "&gt;",
      "<": "&lt;"
    };
    var stringifySvg = (data, userOptions = {}) => {
      const config = { ...defaults, ...userOptions };
      const indent = config.indent;
      let newIndent = "    ";
      if (typeof indent === "number" && Number.isNaN(indent) === false) {
        newIndent = indent < 0 ? "	" : " ".repeat(indent);
      } else if (typeof indent === "string") {
        newIndent = indent;
      }
      const state = {
        // TODO remove width and height in v3
        width: void 0,
        height: void 0,
        indent: newIndent,
        textContext: null,
        indentLevel: 0
      };
      const eol = config.eol === "crlf" ? "\r\n" : "\n";
      if (config.pretty) {
        config.doctypeEnd += eol;
        config.procInstEnd += eol;
        config.commentEnd += eol;
        config.cdataEnd += eol;
        config.tagShortEnd += eol;
        config.tagOpenEnd += eol;
        config.tagCloseEnd += eol;
        config.textEnd += eol;
      }
      let svg = stringifyNode(data, config, state);
      if (config.finalNewline && svg.length > 0 && svg[svg.length - 1] !== "\n") {
        svg += eol;
      }
      return {
        data: svg,
        info: {
          width: state.width,
          height: state.height
        }
      };
    };
    exports2.stringifySvg = stringifySvg;
    var stringifyNode = (data, config, state) => {
      let svg = "";
      state.indentLevel += 1;
      for (const item of data.children) {
        if (item.type === "element") {
          svg += stringifyElement(item, config, state);
        }
        if (item.type === "text") {
          svg += stringifyText(item, config, state);
        }
        if (item.type === "doctype") {
          svg += stringifyDoctype(item, config);
        }
        if (item.type === "instruction") {
          svg += stringifyInstruction(item, config);
        }
        if (item.type === "comment") {
          svg += stringifyComment(item, config);
        }
        if (item.type === "cdata") {
          svg += stringifyCdata(item, config, state);
        }
      }
      state.indentLevel -= 1;
      return svg;
    };
    var createIndent = (config, state) => {
      let indent = "";
      if (config.pretty && state.textContext == null) {
        indent = state.indent.repeat(state.indentLevel - 1);
      }
      return indent;
    };
    var stringifyDoctype = (node, config) => {
      return config.doctypeStart + node.data.doctype + config.doctypeEnd;
    };
    var stringifyInstruction = (node, config) => {
      return config.procInstStart + node.name + " " + node.value + config.procInstEnd;
    };
    var stringifyComment = (node, config) => {
      return config.commentStart + node.value + config.commentEnd;
    };
    var stringifyCdata = (node, config, state) => {
      return createIndent(config, state) + config.cdataStart + node.value + config.cdataEnd;
    };
    var stringifyElement = (node, config, state) => {
      if (node.name === "svg" && node.attributes.width != null && node.attributes.height != null) {
        state.width = node.attributes.width;
        state.height = node.attributes.height;
      }
      if (node.children.length === 0) {
        if (config.useShortTags) {
          return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagShortEnd;
        } else {
          return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagOpenEnd + config.tagCloseStart + node.name + config.tagCloseEnd;
        }
      } else {
        let tagOpenStart = config.tagOpenStart;
        let tagOpenEnd = config.tagOpenEnd;
        let tagCloseStart = config.tagCloseStart;
        let tagCloseEnd = config.tagCloseEnd;
        let openIndent = createIndent(config, state);
        let closeIndent = createIndent(config, state);
        if (state.textContext) {
          tagOpenStart = defaults.tagOpenStart;
          tagOpenEnd = defaults.tagOpenEnd;
          tagCloseStart = defaults.tagCloseStart;
          tagCloseEnd = defaults.tagCloseEnd;
          openIndent = "";
        } else if (textElems.includes(node.name)) {
          tagOpenEnd = defaults.tagOpenEnd;
          tagCloseStart = defaults.tagCloseStart;
          closeIndent = "";
          state.textContext = node;
        }
        const children = stringifyNode(node, config, state);
        if (state.textContext === node) {
          state.textContext = null;
        }
        return openIndent + tagOpenStart + node.name + stringifyAttributes(node, config) + tagOpenEnd + children + closeIndent + tagCloseStart + node.name + tagCloseEnd;
      }
    };
    var stringifyAttributes = (node, config) => {
      let attrs = "";
      for (const [name, value] of Object.entries(node.attributes)) {
        if (value !== void 0) {
          const encodedValue = value.toString().replace(config.regValEntities, config.encodeEntity);
          attrs += " " + name + config.attrStart + encodedValue + config.attrEnd;
        } else {
          attrs += " " + name;
        }
      }
      return attrs;
    };
    var stringifyText = (node, config, state) => {
      return createIndent(config, state) + config.textStart + node.value.replace(config.regEntities, config.encodeEntity) + (state.textContext ? "" : config.textEnd);
    };
  }
});

// node_modules/svgo/lib/svgo.js
var require_svgo = __commonJS({
  "node_modules/svgo/lib/svgo.js"(exports2) {
    "use strict";
    var {
      defaultPlugins,
      resolvePluginConfig,
      extendDefaultPlugins
    } = require_config();
    var { parseSvg } = require_parser2();
    var { stringifySvg } = require_stringifier();
    var { invokePlugins } = require_plugins();
    var JSAPI = require_jsAPI();
    var { encodeSVGDatauri } = require_tools();
    exports2.extendDefaultPlugins = extendDefaultPlugins;
    var optimize = (input, config) => {
      if (config == null) {
        config = {};
      }
      if (typeof config !== "object") {
        throw Error("Config should be an object");
      }
      const maxPassCount = config.multipass ? 10 : 1;
      let prevResultSize = Number.POSITIVE_INFINITY;
      let svgjs = null;
      const info = {};
      if (config.path != null) {
        info.path = config.path;
      }
      for (let i = 0; i < maxPassCount; i += 1) {
        info.multipassCount = i;
        try {
          svgjs = parseSvg(input, config.path);
        } catch (error) {
          return { error: error.toString(), modernError: error };
        }
        if (svgjs.error != null) {
          if (config.path != null) {
            svgjs.path = config.path;
          }
          return svgjs;
        }
        const plugins = config.plugins || defaultPlugins;
        if (Array.isArray(plugins) === false) {
          throw Error(
            "Invalid plugins list. Provided 'plugins' in config should be an array."
          );
        }
        const resolvedPlugins = plugins.map(resolvePluginConfig);
        const globalOverrides = {};
        if (config.floatPrecision != null) {
          globalOverrides.floatPrecision = config.floatPrecision;
        }
        svgjs = invokePlugins(svgjs, info, resolvedPlugins, null, globalOverrides);
        svgjs = stringifySvg(svgjs, config.js2svg);
        if (svgjs.data.length < prevResultSize) {
          input = svgjs.data;
          prevResultSize = svgjs.data.length;
        } else {
          if (config.datauri) {
            svgjs.data = encodeSVGDatauri(svgjs.data, config.datauri);
          }
          if (config.path != null) {
            svgjs.path = config.path;
          }
          return svgjs;
        }
      }
      return svgjs;
    };
    exports2.optimize = optimize;
    var createContentItem = (data) => {
      return new JSAPI(data);
    };
    exports2.createContentItem = createContentItem;
  }
});

// node_modules/svgo/lib/svgo-node.js
var require_svgo_node = __commonJS({
  "node_modules/svgo/lib/svgo-node.js"(exports2) {
    "use strict";
    var os = require("os");
    var fs = require("fs");
    var { pathToFileURL } = require("url");
    var path = require("path");
    var {
      extendDefaultPlugins,
      optimize: optimizeAgnostic,
      createContentItem
    } = require_svgo();
    exports2.extendDefaultPlugins = extendDefaultPlugins;
    exports2.createContentItem = createContentItem;
    var importConfig = async (configFile) => {
      let config;
      if (configFile.endsWith(".cjs")) {
        config = require(configFile);
      } else {
        try {
          const { default: imported } = await import(pathToFileURL(configFile));
          config = imported;
        } catch (importError) {
          try {
            config = require(configFile);
          } catch (requireError) {
            if (requireError.code === "ERR_REQUIRE_ESM") {
              throw importError;
            } else {
              throw requireError;
            }
          }
        }
      }
      if (config == null || typeof config !== "object" || Array.isArray(config)) {
        throw Error(`Invalid config file "${configFile}"`);
      }
      return config;
    };
    var isFile = async (file) => {
      try {
        const stats = await fs.promises.stat(file);
        return stats.isFile();
      } catch {
        return false;
      }
    };
    var loadConfig = async (configFile, cwd = process.cwd()) => {
      if (configFile != null) {
        if (path.isAbsolute(configFile)) {
          return await importConfig(configFile);
        } else {
          return await importConfig(path.join(cwd, configFile));
        }
      }
      let dir = cwd;
      while (true) {
        const js = path.join(dir, "svgo.config.js");
        if (await isFile(js)) {
          return await importConfig(js);
        }
        const mjs = path.join(dir, "svgo.config.mjs");
        if (await isFile(mjs)) {
          return await importConfig(mjs);
        }
        const cjs = path.join(dir, "svgo.config.cjs");
        if (await isFile(cjs)) {
          return await importConfig(cjs);
        }
        const parent = path.dirname(dir);
        if (dir === parent) {
          return null;
        }
        dir = parent;
      }
    };
    exports2.loadConfig = loadConfig;
    var optimize = (input, config) => {
      if (config == null) {
        config = {};
      }
      if (typeof config !== "object") {
        throw Error("Config should be an object");
      }
      return optimizeAgnostic(input, {
        ...config,
        js2svg: {
          // platform specific default for end of line
          eol: os.EOL === "\r\n" ? "crlf" : "lf",
          ...config.js2svg
        }
      });
    };
    exports2.optimize = optimize;
  }
});

// node_modules/lodash.isplainobject/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.isplainobject/index.js"(exports2, module2) {
    var objectTag = "[object Object]";
    function isHostObject(value) {
      var result = false;
      if (value != null && typeof value.toString != "function") {
        try {
          result = !!(value + "");
        } catch (e) {
        }
      }
      return result;
    }
    function overArg(func, transform) {
      return function(arg) {
        return func(transform(arg));
      };
    }
    var funcProto = Function.prototype;
    var objectProto = Object.prototype;
    var funcToString = funcProto.toString;
    var hasOwnProperty2 = objectProto.hasOwnProperty;
    var objectCtorString = funcToString.call(Object);
    var objectToString = objectProto.toString;
    var getPrototype = overArg(Object.getPrototypeOf, Object);
    function isObjectLike(value) {
      return !!value && typeof value == "object";
    }
    function isPlainObject(value) {
      if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty2.call(proto, "constructor") && proto.constructor;
      return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
    }
    module2.exports = isPlainObject;
  }
});

// lib/optimize.js
var require_optimize = __commonJS({
  "lib/optimize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = optimize;
    var SVGO = _interopRequireWildcard(require_svgo_node());
    var _lodash = _interopRequireDefault2(require_lodash());
    function _interopRequireDefault2(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    function _getRequireWildcardCache(e) {
      if ("function" != typeof WeakMap) return null;
      var r = /* @__PURE__ */ new WeakMap(), t = /* @__PURE__ */ new WeakMap();
      return (_getRequireWildcardCache = function _getRequireWildcardCache2(e2) {
        return e2 ? t : r;
      })(e);
    }
    function _interopRequireWildcard(e, r) {
      if (!r && e && e.__esModule) return e;
      if (null === e || "object" != _typeof2(e) && "function" != typeof e) return { "default": e };
      var t = _getRequireWildcardCache(r);
      if (t && t.has(e)) return t.get(e);
      var n = { __proto__: null }, a = Object.defineProperty && Object.getOwnPropertyDescriptor;
      for (var u in e) if ("default" !== u && {}.hasOwnProperty.call(e, u)) {
        var i = a ? Object.getOwnPropertyDescriptor(e, u) : null;
        i && (i.get || i.set) ? Object.defineProperty(n, u, i) : n[u] = e[u];
      }
      return n["default"] = e, t && t.set(e, n), n;
    }
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof2(o);
    }
    function _defineProperty2(e, r, t) {
      return (r = _toPropertyKey2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey2(t) {
      var i = _toPrimitive2(t, "string");
      return "symbol" == _typeof2(i) ? i : i + "";
    }
    function _toPrimitive2(t, r) {
      if ("object" != _typeof2(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof2(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    var essentialPlugins = ["removeDoctype", "removeComments"];
    function isEssentialPlugin(p) {
      return essentialPlugins.indexOf(p) !== -1;
    }
    function validateAndFix(opts) {
      if (!(0, _lodash["default"])(opts)) return;
      if (opts.full) {
        if (typeof opts.plugins === "undefined" || Array.isArray(opts.plugins) && opts.plugins.length === 0) {
          opts.plugins = [].concat(essentialPlugins);
          return;
        }
      }
      if (typeof opts.plugins === "undefined") return;
      if (Array.isArray(opts.plugins) && opts.plugins.length === 0) return;
      var state = essentialPlugins.reduce(function(p, c) {
        return Object.assign(p, _defineProperty2({}, c, false));
      }, {});
      opts.plugins.forEach(function(p) {
        if (typeof p === "string" && isEssentialPlugin(p)) {
          state[p] = true;
        } else if (_typeof2(p) === "object") {
          Object.keys(p).forEach(function(k) {
            if (isEssentialPlugin(k)) {
              if (!p[k]) p[k] = true;
              state[k] = true;
            }
          });
        }
      });
      Object.keys(state).filter(function(key) {
        return !state[key];
      }).forEach(function(key) {
        return opts.plugins.push(key);
      });
    }
    function optimize(content) {
      var opts = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
      validateAndFix(opts);
      return SVGO.optimize(content, opts);
    }
  }
});

// lib/escapeBraces.js
var require_escapeBraces = __commonJS({
  "lib/escapeBraces.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = escapeBraces;
    function _typeof2(o) {
      "@babel/helpers - typeof";
      return _typeof2 = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
        return typeof o2;
      } : function(o2) {
        return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
      }, _typeof2(o);
    }
    function ownKeys2(e, r) {
      var t = Object.keys(e);
      if (Object.getOwnPropertySymbols) {
        var o = Object.getOwnPropertySymbols(e);
        r && (o = o.filter(function(r2) {
          return Object.getOwnPropertyDescriptor(e, r2).enumerable;
        })), t.push.apply(t, o);
      }
      return t;
    }
    function _objectSpread2(e) {
      for (var r = 1; r < arguments.length; r++) {
        var t = null != arguments[r] ? arguments[r] : {};
        r % 2 ? ownKeys2(Object(t), true).forEach(function(r2) {
          _defineProperty2(e, r2, t[r2]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys2(Object(t)).forEach(function(r2) {
          Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
        });
      }
      return e;
    }
    function _defineProperty2(e, r, t) {
      return (r = _toPropertyKey2(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
    }
    function _toPropertyKey2(t) {
      var i = _toPrimitive2(t, "string");
      return "symbol" == _typeof2(i) ? i : i + "";
    }
    function _toPrimitive2(t, r) {
      if ("object" != _typeof2(t) || !t) return t;
      var e = t[Symbol.toPrimitive];
      if (void 0 !== e) {
        var i = e.call(t, r || "default");
        if ("object" != _typeof2(i)) return i;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return ("string" === r ? String : Number)(t);
    }
    function escapeBraces(raw) {
      return _objectSpread2(_objectSpread2({}, raw), {}, {
        data: raw.data.replace(/(\{|\})/g, "{`$1`}")
      });
    }
  }
});

// lib/camelize.js
var require_camelize = __commonJS({
  "lib/camelize.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.hyphenToCamel = hyphenToCamel;
    exports2.namespaceToCamel = namespaceToCamel;
    function hyphenToCamel(name) {
      return name.replace(/-([a-z])/g, function(g) {
        return g[1].toUpperCase();
      });
    }
    function namespaceToCamel(namespace, name) {
      return namespace + name.charAt(0).toUpperCase() + name.slice(1);
    }
  }
});

// lib/cssToObj.js
var require_cssToObj = __commonJS({
  "lib/cssToObj.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = cssToObj;
    function cssToObj(css) {
      var o = {};
      css.split(";").filter(function(el) {
        return !!el;
      }).forEach(function(el) {
        var s = el.split(":");
        var key = s.shift().trim();
        var value = s.join(":").trim();
        o[key] = value;
      });
      return o;
    }
  }
});

// lib/transformSvg.js
var require_transformSvg = __commonJS({
  "lib/transformSvg.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = void 0;
    var _camelize = require_camelize();
    var _cssToObj = _interopRequireDefault2(require_cssToObj());
    function _interopRequireDefault2(e) {
      return e && e.__esModule ? e : { "default": e };
    }
    var _default2 = exports2["default"] = function _default3(t) {
      return {
        JSXAttribute: function JSXAttribute(_ref) {
          var node = _ref.node;
          var originalName = node.name;
          if (t.isJSXNamespacedName(originalName)) {
            node.name = t.jSXIdentifier((0, _camelize.namespaceToCamel)(originalName.namespace.name, originalName.name.name));
          } else if (t.isJSXIdentifier(originalName)) {
            if (originalName.name === "class") {
              originalName.name = "className";
            }
            if (originalName.name === "style") {
              var csso = (0, _cssToObj["default"])(node.value.value);
              var properties = Object.keys(csso).map(function(prop) {
                return t.objectProperty(t.identifier((0, _camelize.hyphenToCamel)(prop)), t.stringLiteral(csso[prop]));
              });
              node.value = t.jSXExpressionContainer(t.objectExpression(properties));
            }
            if (/^data-|^aria-/.test(originalName.name)) {
              originalName.name = "'".concat(originalName.name, "'");
            } else {
              originalName.name = (0, _camelize.hyphenToCamel)(originalName.name);
            }
          }
        },
        // converts
        // <svg>
        // to
        // <svg {...props}>
        // after passing through attributes visitors
        JSXOpeningElement: function JSXOpeningElement(_ref2) {
          var _ref2$node = _ref2.node, name = _ref2$node.name, attributes = _ref2$node.attributes;
          if (name.name.toLowerCase() === "svg") {
            attributes.push(t.jSXSpreadAttribute(t.identifier("props")));
          }
        }
      };
    };
  }
});

// lib/fileExistsWithCaseSync.js
var require_fileExistsWithCaseSync = __commonJS({
  "lib/fileExistsWithCaseSync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2["default"] = fileExistsWithCaseSync;
    var fs = require("fs");
    var path = require("path");
    function fileExistsWithCaseSync(filepath) {
      var dir = path.dirname(filepath);
      if (dir === "/" || dir === ".") return true;
      var filenames = fs.readdirSync(dir);
      return filenames.indexOf(path.basename(filepath)) !== -1;
    }
  }
});

// lib/index.js
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _path = require("path");
var _fs = require("fs");
var _parser = require_lib();
var _helperPluginUtils = require_lib2();
var _sync = _interopRequireDefault(require_sync());
var _optimize = _interopRequireDefault(require_optimize());
var _escapeBraces = _interopRequireDefault(require_escapeBraces());
var _transformSvg = _interopRequireDefault(require_transformSvg());
var _fileExistsWithCaseSync = _interopRequireDefault(require_fileExistsWithCaseSync());
function _interopRequireDefault(e) {
  return e && e.__esModule ? e : { "default": e };
}
function _typeof(o) {
  "@babel/helpers - typeof";
  return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(o2) {
    return typeof o2;
  } : function(o2) {
    return o2 && "function" == typeof Symbol && o2.constructor === Symbol && o2 !== Symbol.prototype ? "symbol" : typeof o2;
  }, _typeof(o);
}
function _slicedToArray(r, e) {
  return _arrayWithHoles(r) || _iterableToArrayLimit(r, e) || _unsupportedIterableToArray(r, e) || _nonIterableRest();
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function _unsupportedIterableToArray(r, a) {
  if (r) {
    if ("string" == typeof r) return _arrayLikeToArray(r, a);
    var t = {}.toString.call(r).slice(8, -1);
    return "Object" === t && r.constructor && (t = r.constructor.name), "Map" === t || "Set" === t ? Array.from(r) : "Arguments" === t || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t) ? _arrayLikeToArray(r, a) : void 0;
  }
}
function _arrayLikeToArray(r, a) {
  (null == a || a > r.length) && (a = r.length);
  for (var e = 0, n = Array(a); e < a; e++) n[e] = r[e];
  return n;
}
function _iterableToArrayLimit(r, l) {
  var t = null == r ? null : "undefined" != typeof Symbol && r[Symbol.iterator] || r["@@iterator"];
  if (null != t) {
    var e, n, i, u, a = [], f = true, o = false;
    try {
      if (i = (t = t.call(r)).next, 0 === l) {
        if (Object(t) !== t) return;
        f = false;
      } else for (; !(f = (e = i.call(t)).done) && (a.push(e.value), a.length !== l); f = true) ;
    } catch (r2) {
      o = true, n = r2;
    } finally {
      try {
        if (!f && null != t["return"] && (u = t["return"](), Object(u) !== u)) return;
      } finally {
        if (o) throw n;
      }
    }
    return a;
  }
}
function _arrayWithHoles(r) {
  if (Array.isArray(r)) return r;
}
function ownKeys(e, r) {
  var t = Object.keys(e);
  if (Object.getOwnPropertySymbols) {
    var o = Object.getOwnPropertySymbols(e);
    r && (o = o.filter(function(r2) {
      return Object.getOwnPropertyDescriptor(e, r2).enumerable;
    })), t.push.apply(t, o);
  }
  return t;
}
function _objectSpread(e) {
  for (var r = 1; r < arguments.length; r++) {
    var t = null != arguments[r] ? arguments[r] : {};
    r % 2 ? ownKeys(Object(t), true).forEach(function(r2) {
      _defineProperty(e, r2, t[r2]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e, Object.getOwnPropertyDescriptors(t)) : ownKeys(Object(t)).forEach(function(r2) {
      Object.defineProperty(e, r2, Object.getOwnPropertyDescriptor(t, r2));
    });
  }
  return e;
}
function _defineProperty(e, r, t) {
  return (r = _toPropertyKey(r)) in e ? Object.defineProperty(e, r, { value: t, enumerable: true, configurable: true, writable: true }) : e[r] = t, e;
}
function _toPropertyKey(t) {
  var i = _toPrimitive(t, "string");
  return "symbol" == _typeof(i) ? i : i + "";
}
function _toPrimitive(t, r) {
  if ("object" != _typeof(t) || !t) return t;
  var e = t[Symbol.toPrimitive];
  if (void 0 !== e) {
    var i = e.call(t, r || "default");
    if ("object" != _typeof(i)) return i;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r ? String : Number)(t);
}
var ignoreRegex;
var _default = exports["default"] = (0, _helperPluginUtils.declare)(function(_ref) {
  var assertVersion = _ref.assertVersion, template = _ref.template, traverse = _ref.traverse, t = _ref.types;
  assertVersion(7);
  var buildSvg = function buildSvg2(_ref2) {
    var IS_EXPORT = _ref2.IS_EXPORT, EXPORT_FILENAME = _ref2.EXPORT_FILENAME, SVG_NAME = _ref2.SVG_NAME, SVG_CODE = _ref2.SVG_CODE, SVG_DEFAULT_PROPS_CODE = _ref2.SVG_DEFAULT_PROPS_CODE;
    var namedTemplate = "\n      var SVG_NAME = function SVG_NAME(props) { return SVG_CODE; };\n      ".concat(SVG_DEFAULT_PROPS_CODE ? "SVG_NAME.defaultProps = SVG_DEFAULT_PROPS_CODE;" : "", "\n      ").concat(IS_EXPORT ? "export { SVG_NAME };" : "", "\n    ");
    var anonymousTemplate = "\n      var Component = function (props) { return SVG_CODE; };\n      ".concat(SVG_DEFAULT_PROPS_CODE ? "Component.defaultProps = SVG_DEFAULT_PROPS_CODE;" : "", "\n      Component.displayName = 'EXPORT_FILENAME';\n      export default Component;\n    ");
    if (SVG_NAME !== "default") {
      var _substitutions = {
        SVG_CODE,
        SVG_NAME
      };
      if (SVG_DEFAULT_PROPS_CODE) {
        _substitutions.SVG_DEFAULT_PROPS_CODE = SVG_DEFAULT_PROPS_CODE;
      }
      return template(namedTemplate)(_substitutions);
    }
    var substitutions = {
      SVG_CODE,
      EXPORT_FILENAME
    };
    if (SVG_DEFAULT_PROPS_CODE) {
      substitutions.SVG_DEFAULT_PROPS_CODE = SVG_DEFAULT_PROPS_CODE;
    }
    return template(anonymousTemplate)(substitutions);
  };
  function applyPlugin(importIdentifier, importPath, path, state, isExport, exportFilename) {
    if (typeof importPath !== "string") {
      throw new TypeError("`applyPlugin` `importPath` must be a string");
    }
    var _state$opts = state.opts, ignorePattern = _state$opts.ignorePattern, caseSensitive = _state$opts.caseSensitive, providedFilename = _state$opts.filename;
    var file = state.file, filename = state.filename;
    var newPath;
    if (ignorePattern) {
      ignoreRegex = ignoreRegex || new RegExp(ignorePattern);
      if (ignoreRegex.test(importPath)) {
        return void 0;
      }
    }
    if ((0, _path.extname)(importPath) === ".svg") {
      var iconPath = filename || providedFilename;
      var svgPath = (0, _sync["default"])(importPath, {
        basedir: (0, _path.dirname)(iconPath),
        preserveSymlinks: true
      });
      if (caseSensitive && !(0, _fileExistsWithCaseSync["default"])(svgPath)) {
        throw new Error("File path didn't match case of file on disk: ".concat(svgPath));
      }
      if (!svgPath) {
        throw new Error("File path does not exist: ".concat(importPath));
      }
      var rawSource = (0, _fs.readFileSync)(svgPath, "utf8");
      var optimizedSource = state.opts.svgo === false ? {
        data: rawSource
      } : (0, _optimize["default"])(rawSource, _objectSpread(_objectSpread({}, state.opts.svgo), {}, {
        path: svgPath
      }));
      var escapeSvgSource = (0, _escapeBraces["default"])(optimizedSource);
      var parsedSvgAst = (0, _parser.parse)(escapeSvgSource.data, {
        sourceType: "module",
        plugins: ["jsx"]
      });
      traverse(parsedSvgAst, (0, _transformSvg["default"])(t));
      var svgCode = traverse.removeProperties(parsedSvgAst.program.body[0].expression);
      var opts = {
        SVG_NAME: importIdentifier,
        SVG_CODE: svgCode,
        IS_EXPORT: isExport,
        EXPORT_FILENAME: exportFilename
      };
      if (state.opts.spreadDefaultProps !== true && svgCode.openingElement.attributes.length > 1) {
        var keepProps = [];
        var defaultProps = [];
        svgCode.openingElement.attributes.forEach(function(prop) {
          if (prop.type === "JSXSpreadAttribute") {
            keepProps.push(prop);
          } else if (prop.value.type === "JSXExpressionContainer") {
            var objectExpression = t.objectExpression(prop.value.expression.properties);
            defaultProps.push(t.objectProperty(t.identifier(prop.name.name), objectExpression));
          } else {
            defaultProps.push(t.objectProperty(t.identifier(prop.name.name), prop.value));
          }
        });
        svgCode.openingElement.attributes = keepProps;
        opts.SVG_DEFAULT_PROPS_CODE = t.objectExpression(defaultProps);
      }
      var svgReplacement = buildSvg(opts);
      if (svgReplacement.length > 1) {
        var _path$replaceWithMult = path.replaceWithMultiple(svgReplacement);
        var _path$replaceWithMult2 = _slicedToArray(_path$replaceWithMult, 1);
        newPath = _path$replaceWithMult2[0];
      } else {
        newPath = path.replaceWith(svgReplacement);
      }
      file.get("ensureReact")();
      file.set("ensureReact", function() {
      });
    }
    return newPath;
  }
  return {
    visitor: {
      Program: {
        enter: function enter(path, _ref3) {
          var file = _ref3.file, opts = _ref3.opts, filename = _ref3.filename;
          if (typeof filename === "string" && typeof opts.filename !== "undefined") {
            throw new TypeError('the "filename" option may only be provided when transforming code');
          }
          if (typeof filename === "undefined" && typeof opts.filename !== "string") {
            throw new TypeError('the "filename" option is required when transforming code');
          }
          if (!path.scope.hasBinding("React")) {
            var reactImportDeclaration = t.importDeclaration([t.importDefaultSpecifier(t.identifier("React"))], t.stringLiteral("react"));
            file.set("ensureReact", function() {
              var _path$unshiftContaine = path.unshiftContainer("body", reactImportDeclaration), _path$unshiftContaine2 = _slicedToArray(_path$unshiftContaine, 1), newPath = _path$unshiftContaine2[0];
              newPath.get("specifiers").forEach(function(specifier) {
                path.scope.registerBinding("module", specifier);
              });
            });
          } else {
            file.set("ensureReact", function() {
            });
          }
        }
      },
      CallExpression: function CallExpression(path, state) {
        var node = path.node;
        var requireArg = node.arguments.length > 0 ? node.arguments[0] : null;
        var filePath = t.isStringLiteral(requireArg) ? requireArg.value : null;
        if (node.callee.name === "require" && t.isVariableDeclarator(path.parent) && filePath) {
          applyPlugin(path.parent.id, filePath, path.parentPath.parentPath, state);
        }
      },
      ImportDeclaration: function ImportDeclaration(path, state) {
        var node = path.node;
        if (node.specifiers.length > 0) {
          applyPlugin(node.specifiers[0].local, node.source.value, path, state);
        }
      },
      ExportNamedDeclaration: function ExportNamedDeclaration(path, state) {
        var node = path.node, scope = path.scope;
        if (node.specifiers.length > 0 && node.specifiers[0].local && node.specifiers[0].local.name === "default") {
          var exportName = node.specifiers[0].exported.name;
          var filename = (0, _path.parse)(node.source.value).name;
          var newPath = applyPlugin(exportName, node.source.value, path, state, true, filename);
          if (newPath) {
            scope.registerDeclaration(newPath);
          }
        }
      }
    }
  };
});
/*! Bundled license information:

stable/stable.js:
  (*! stable.js 0.1.8, https://github.com/Two-Screen/stable *)
  (*! © 2018 Angry Bytes and contributors. MIT licensed. *)
*/
